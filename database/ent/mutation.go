// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jianbo-zh/jydata/database/ent/access"
	"github.com/jianbo-zh/jydata/database/ent/account"
	"github.com/jianbo-zh/jydata/database/ent/activityorder"
	"github.com/jianbo-zh/jydata/database/ent/apppush"
	"github.com/jianbo-zh/jydata/database/ent/appversion"
	"github.com/jianbo-zh/jydata/database/ent/billingstrategy"
	"github.com/jianbo-zh/jydata/database/ent/car"
	"github.com/jianbo-zh/jydata/database/ent/caralarm"
	"github.com/jianbo-zh/jydata/database/ent/carconfig"
	"github.com/jianbo-zh/jydata/database/ent/carconfigdownload"
	"github.com/jianbo-zh/jydata/database/ent/carconfigpack"
	"github.com/jianbo-zh/jydata/database/ent/carconfigstatus"
	"github.com/jianbo-zh/jydata/database/ent/carcumulative"
	"github.com/jianbo-zh/jydata/database/ent/carextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/carlogupload"
	"github.com/jianbo-zh/jydata/database/ent/carsflight"
	"github.com/jianbo-zh/jydata/database/ent/carsflightextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/carsmodels"
	"github.com/jianbo-zh/jydata/database/ent/carsmodelsgroups"
	"github.com/jianbo-zh/jydata/database/ent/carsmodelsgroupsparams"
	"github.com/jianbo-zh/jydata/database/ent/carsoperatelog"
	"github.com/jianbo-zh/jydata/database/ent/coupon"
	"github.com/jianbo-zh/jydata/database/ent/feedback"
	"github.com/jianbo-zh/jydata/database/ent/file"
	"github.com/jianbo-zh/jydata/database/ent/mapversion"
	"github.com/jianbo-zh/jydata/database/ent/operationuser"
	"github.com/jianbo-zh/jydata/database/ent/order"
	"github.com/jianbo-zh/jydata/database/ent/orderappeal"
	"github.com/jianbo-zh/jydata/database/ent/orderbilling"
	"github.com/jianbo-zh/jydata/database/ent/orderextendflight"
	"github.com/jianbo-zh/jydata/database/ent/orderrefund"
	"github.com/jianbo-zh/jydata/database/ent/ordersharing"
	"github.com/jianbo-zh/jydata/database/ent/otabtree"
	"github.com/jianbo-zh/jydata/database/ent/otadeploy"
	"github.com/jianbo-zh/jydata/database/ent/otaversion"
	"github.com/jianbo-zh/jydata/database/ent/paymentaccount"
	"github.com/jianbo-zh/jydata/database/ent/paytxbill"
	"github.com/jianbo-zh/jydata/database/ent/poi"
	"github.com/jianbo-zh/jydata/database/ent/poiextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/predicate"
	"github.com/jianbo-zh/jydata/database/ent/profitreceiver"
	"github.com/jianbo-zh/jydata/database/ent/role"
	"github.com/jianbo-zh/jydata/database/ent/route"
	"github.com/jianbo-zh/jydata/database/ent/scenicarea"
	"github.com/jianbo-zh/jydata/database/ent/scenicareaextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/scenicareamap"
	"github.com/jianbo-zh/jydata/database/ent/schetask"
	"github.com/jianbo-zh/jydata/database/ent/schetaskevent"
	"github.com/jianbo-zh/jydata/database/ent/sshaccount"
	"github.com/jianbo-zh/jydata/database/ent/statsdaily"
	"github.com/jianbo-zh/jydata/database/ent/statsdailycar"
	"github.com/jianbo-zh/jydata/database/ent/statsdailyscenicarea"
	"github.com/jianbo-zh/jydata/database/ent/statshourlycar"
	"github.com/jianbo-zh/jydata/database/ent/statshourlyscenicarea"
	"github.com/jianbo-zh/jydata/database/ent/systemconfig"
	"github.com/jianbo-zh/jydata/database/ent/systemlog"
	"github.com/jianbo-zh/jydata/database/ent/task"
	"github.com/jianbo-zh/jydata/database/ent/user"
	"github.com/jianbo-zh/jydata/database/schema/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccess                 = "Access"
	TypeAccount                = "Account"
	TypeActivityOrder          = "ActivityOrder"
	TypeAppPush                = "AppPush"
	TypeAppVersion             = "AppVersion"
	TypeBillingStrategy        = "BillingStrategy"
	TypeCar                    = "Car"
	TypeCarAlarm               = "CarAlarm"
	TypeCarConfig              = "CarConfig"
	TypeCarConfigDownload      = "CarConfigDownload"
	TypeCarConfigPack          = "CarConfigPack"
	TypeCarConfigStatus        = "CarConfigStatus"
	TypeCarCumulative          = "CarCumulative"
	TypeCarExtendYokee         = "CarExtendYokee"
	TypeCarLogUpload           = "CarLogUpload"
	TypeCarsFlight             = "CarsFlight"
	TypeCarsFlightExtendYokee  = "CarsFlightExtendYokee"
	TypeCarsModels             = "CarsModels"
	TypeCarsModelsGroups       = "CarsModelsGroups"
	TypeCarsModelsGroupsParams = "CarsModelsGroupsParams"
	TypeCarsOperateLog         = "CarsOperateLog"
	TypeCoupon                 = "Coupon"
	TypeFeedback               = "Feedback"
	TypeFile                   = "File"
	TypeMapVersion             = "MapVersion"
	TypeOperationUser          = "OperationUser"
	TypeOrder                  = "Order"
	TypeOrderAppeal            = "OrderAppeal"
	TypeOrderBilling           = "OrderBilling"
	TypeOrderExtendFlight      = "OrderExtendFlight"
	TypeOrderRefund            = "OrderRefund"
	TypeOrderSharing           = "OrderSharing"
	TypeOtaBtree               = "OtaBtree"
	TypeOtaDeploy              = "OtaDeploy"
	TypeOtaVersion             = "OtaVersion"
	TypePayTxBill              = "PayTxBill"
	TypePaymentAccount         = "PaymentAccount"
	TypePoi                    = "Poi"
	TypePoiExtendYokee         = "PoiExtendYokee"
	TypeProfitReceiver         = "ProfitReceiver"
	TypeRole                   = "Role"
	TypeRoute                  = "Route"
	TypeScenicArea             = "ScenicArea"
	TypeScenicAreaExtendYokee  = "ScenicAreaExtendYokee"
	TypeScenicAreaMap          = "ScenicAreaMap"
	TypeScheTask               = "ScheTask"
	TypeScheTaskEvent          = "ScheTaskEvent"
	TypeSshAccount             = "SshAccount"
	TypeStatsDaily             = "StatsDaily"
	TypeStatsDailyCar          = "StatsDailyCar"
	TypeStatsDailyScenicArea   = "StatsDailyScenicArea"
	TypeStatsHourlyCar         = "StatsHourlyCar"
	TypeStatsHourlyScenicArea  = "StatsHourlyScenicArea"
	TypeSystemConfig           = "SystemConfig"
	TypeSystemLog              = "SystemLog"
	TypeTask                   = "Task"
	TypeUser                   = "User"
)

// AccessMutation represents an operation that mutates the Access nodes in the graph.
type AccessMutation struct {
	config
	op            Op
	typ           string
	id            *int
	pid           *int
	addpid        *int
	code          *string
	name          *string
	url           *string
	sort          *int
	addsort       *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Access, error)
	predicates    []predicate.Access
}

var _ ent.Mutation = (*AccessMutation)(nil)

// accessOption allows management of the mutation configuration using functional options.
type accessOption func(*AccessMutation)

// newAccessMutation creates new mutation for the Access entity.
func newAccessMutation(c config, op Op, opts ...accessOption) *AccessMutation {
	m := &AccessMutation{
		config:        c,
		op:            op,
		typ:           TypeAccess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessID sets the ID field of the mutation.
func withAccessID(id int) accessOption {
	return func(m *AccessMutation) {
		var (
			err   error
			once  sync.Once
			value *Access
		)
		m.oldValue = func(ctx context.Context) (*Access, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Access.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccess sets the old Access of the mutation.
func withAccess(node *Access) accessOption {
	return func(m *AccessMutation) {
		m.oldValue = func(context.Context) (*Access, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Access entities.
func (m *AccessMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Access.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPid sets the "pid" field.
func (m *AccessMutation) SetPid(i int) {
	m.pid = &i
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *AccessMutation) Pid() (r int, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldPid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds i to the "pid" field.
func (m *AccessMutation) AddPid(i int) {
	if m.addpid != nil {
		*m.addpid += i
	} else {
		m.addpid = &i
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *AccessMutation) AddedPid() (r int, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *AccessMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// SetCode sets the "code" field.
func (m *AccessMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AccessMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AccessMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *AccessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccessMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *AccessMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AccessMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AccessMutation) ResetURL() {
	m.url = nil
}

// SetSort sets the "sort" field.
func (m *AccessMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AccessMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AccessMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AccessMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *AccessMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AccessMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccessMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccessMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccessMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccessMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Access entity.
// If the Access object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccessMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the AccessMutation builder.
func (m *AccessMutation) Where(ps ...predicate.Access) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Access, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Access).
func (m *AccessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.pid != nil {
		fields = append(fields, access.FieldPid)
	}
	if m.code != nil {
		fields = append(fields, access.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, access.FieldName)
	}
	if m.url != nil {
		fields = append(fields, access.FieldURL)
	}
	if m.sort != nil {
		fields = append(fields, access.FieldSort)
	}
	if m.create_time != nil {
		fields = append(fields, access.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, access.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case access.FieldPid:
		return m.Pid()
	case access.FieldCode:
		return m.Code()
	case access.FieldName:
		return m.Name()
	case access.FieldURL:
		return m.URL()
	case access.FieldSort:
		return m.Sort()
	case access.FieldCreateTime:
		return m.CreateTime()
	case access.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case access.FieldPid:
		return m.OldPid(ctx)
	case access.FieldCode:
		return m.OldCode(ctx)
	case access.FieldName:
		return m.OldName(ctx)
	case access.FieldURL:
		return m.OldURL(ctx)
	case access.FieldSort:
		return m.OldSort(ctx)
	case access.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case access.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Access field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case access.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case access.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case access.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case access.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case access.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case access.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case access.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Access field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessMutation) AddedFields() []string {
	var fields []string
	if m.addpid != nil {
		fields = append(fields, access.FieldPid)
	}
	if m.addsort != nil {
		fields = append(fields, access.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case access.FieldPid:
		return m.AddedPid()
	case access.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case access.FieldPid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case access.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Access numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Access nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessMutation) ResetField(name string) error {
	switch name {
	case access.FieldPid:
		m.ResetPid()
		return nil
	case access.FieldCode:
		m.ResetCode()
		return nil
	case access.FieldName:
		m.ResetName()
		return nil
	case access.FieldURL:
		m.ResetURL()
		return nil
	case access.FieldSort:
		m.ResetSort()
		return nil
	case access.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case access.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Access field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Access unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Access edge %s", name)
}

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	name                          *string
	account                       *string
	password                      *string
	role_id                       *int
	addrole_id                    *int
	status                        *int
	addstatus                     *int
	is_super                      *bool
	token_hash                    *string
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*Account, error)
	predicates                    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *AccountMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *AccountMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *AccountMutation) ClearScenicAreaID() {
	m.background_scenic_area = nil
	m.clearedFields[account.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *AccountMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[account.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *AccountMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
	delete(m.clearedFields, account.FieldScenicAreaID)
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetAccount sets the "account" field.
func (m *AccountMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *AccountMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *AccountMutation) ResetAccount() {
	m.account = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetRoleID sets the "role_id" field.
func (m *AccountMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AccountMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *AccountMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *AccountMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AccountMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AccountMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AccountMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsSuper sets the "is_super" field.
func (m *AccountMutation) SetIsSuper(b bool) {
	m.is_super = &b
}

// IsSuper returns the value of the "is_super" field in the mutation.
func (m *AccountMutation) IsSuper() (r bool, exists bool) {
	v := m.is_super
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuper returns the old "is_super" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldIsSuper(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuper: %w", err)
	}
	return oldValue.IsSuper, nil
}

// ResetIsSuper resets all changes to the "is_super" field.
func (m *AccountMutation) ResetIsSuper() {
	m.is_super = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *AccountMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *AccountMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *AccountMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *AccountMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *AccountMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[account.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *AccountMutation) BackgroundScenicAreaCleared() bool {
	return m.ScenicAreaIDCleared() || m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *AccountMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *AccountMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.background_scenic_area != nil {
		fields = append(fields, account.FieldScenicAreaID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.account != nil {
		fields = append(fields, account.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.role_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.is_super != nil {
		fields = append(fields, account.FieldIsSuper)
	}
	if m.token_hash != nil {
		fields = append(fields, account.FieldTokenHash)
	}
	if m.create_time != nil {
		fields = append(fields, account.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, account.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldScenicAreaID:
		return m.ScenicAreaID()
	case account.FieldName:
		return m.Name()
	case account.FieldAccount:
		return m.Account()
	case account.FieldPassword:
		return m.Password()
	case account.FieldRoleID:
		return m.RoleID()
	case account.FieldStatus:
		return m.Status()
	case account.FieldIsSuper:
		return m.IsSuper()
	case account.FieldTokenHash:
		return m.TokenHash()
	case account.FieldCreateTime:
		return m.CreateTime()
	case account.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldAccount:
		return m.OldAccount(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldRoleID:
		return m.OldRoleID(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldIsSuper:
		return m.OldIsSuper(ctx)
	case account.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case account.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case account.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldIsSuper:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuper(v)
		return nil
	case account.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case account.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case account.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, account.FieldRoleID)
	}
	if m.addstatus != nil {
		fields = append(fields, account.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldRoleID:
		return m.AddedRoleID()
	case account.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldScenicAreaID) {
		fields = append(fields, account.FieldScenicAreaID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldAccount:
		m.ResetAccount()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldRoleID:
		m.ResetRoleID()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldIsSuper:
		m.ResetIsSuper()
		return nil
	case account.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case account.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case account.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, account.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, account.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// ActivityOrderMutation represents an operation that mutates the ActivityOrder nodes in the graph.
type ActivityOrderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	order_no          *string
	wx_tx_id          *string
	scenic_area_id    *int
	addscenic_area_id *int
	mch_id            *string
	scenic_area_name  *string
	user_id           *int
	adduser_id        *int
	open_id           *string
	order_amount      *int
	addorder_amount   *int
	order_state       *int
	addorder_state    *int
	remark            *string
	paid_time         *time.Time
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ActivityOrder, error)
	predicates        []predicate.ActivityOrder
}

var _ ent.Mutation = (*ActivityOrderMutation)(nil)

// activityorderOption allows management of the mutation configuration using functional options.
type activityorderOption func(*ActivityOrderMutation)

// newActivityOrderMutation creates new mutation for the ActivityOrder entity.
func newActivityOrderMutation(c config, op Op, opts ...activityorderOption) *ActivityOrderMutation {
	m := &ActivityOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityOrderID sets the ID field of the mutation.
func withActivityOrderID(id int) activityorderOption {
	return func(m *ActivityOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityOrder
		)
		m.oldValue = func(ctx context.Context) (*ActivityOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityOrder sets the old ActivityOrder of the mutation.
func withActivityOrder(node *ActivityOrder) activityorderOption {
	return func(m *ActivityOrderMutation) {
		m.oldValue = func(context.Context) (*ActivityOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActivityOrder entities.
func (m *ActivityOrderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderNo sets the "order_no" field.
func (m *ActivityOrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *ActivityOrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *ActivityOrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetWxTxID sets the "wx_tx_id" field.
func (m *ActivityOrderMutation) SetWxTxID(s string) {
	m.wx_tx_id = &s
}

// WxTxID returns the value of the "wx_tx_id" field in the mutation.
func (m *ActivityOrderMutation) WxTxID() (r string, exists bool) {
	v := m.wx_tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWxTxID returns the old "wx_tx_id" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldWxTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWxTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWxTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxTxID: %w", err)
	}
	return oldValue.WxTxID, nil
}

// ResetWxTxID resets all changes to the "wx_tx_id" field.
func (m *ActivityOrderMutation) ResetWxTxID() {
	m.wx_tx_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *ActivityOrderMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *ActivityOrderMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *ActivityOrderMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *ActivityOrderMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *ActivityOrderMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetMchID sets the "mch_id" field.
func (m *ActivityOrderMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *ActivityOrderMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *ActivityOrderMutation) ResetMchID() {
	m.mch_id = nil
}

// SetScenicAreaName sets the "scenic_area_name" field.
func (m *ActivityOrderMutation) SetScenicAreaName(s string) {
	m.scenic_area_name = &s
}

// ScenicAreaName returns the value of the "scenic_area_name" field in the mutation.
func (m *ActivityOrderMutation) ScenicAreaName() (r string, exists bool) {
	v := m.scenic_area_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaName returns the old "scenic_area_name" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldScenicAreaName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaName: %w", err)
	}
	return oldValue.ScenicAreaName, nil
}

// ResetScenicAreaName resets all changes to the "scenic_area_name" field.
func (m *ActivityOrderMutation) ResetScenicAreaName() {
	m.scenic_area_name = nil
}

// SetUserID sets the "user_id" field.
func (m *ActivityOrderMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ActivityOrderMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ActivityOrderMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ActivityOrderMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ActivityOrderMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOpenID sets the "open_id" field.
func (m *ActivityOrderMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *ActivityOrderMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *ActivityOrderMutation) ResetOpenID() {
	m.open_id = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *ActivityOrderMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *ActivityOrderMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *ActivityOrderMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *ActivityOrderMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *ActivityOrderMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderState sets the "order_state" field.
func (m *ActivityOrderMutation) SetOrderState(i int) {
	m.order_state = &i
	m.addorder_state = nil
}

// OrderState returns the value of the "order_state" field in the mutation.
func (m *ActivityOrderMutation) OrderState() (r int, exists bool) {
	v := m.order_state
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderState returns the old "order_state" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldOrderState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderState: %w", err)
	}
	return oldValue.OrderState, nil
}

// AddOrderState adds i to the "order_state" field.
func (m *ActivityOrderMutation) AddOrderState(i int) {
	if m.addorder_state != nil {
		*m.addorder_state += i
	} else {
		m.addorder_state = &i
	}
}

// AddedOrderState returns the value that was added to the "order_state" field in this mutation.
func (m *ActivityOrderMutation) AddedOrderState() (r int, exists bool) {
	v := m.addorder_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderState resets all changes to the "order_state" field.
func (m *ActivityOrderMutation) ResetOrderState() {
	m.order_state = nil
	m.addorder_state = nil
}

// SetRemark sets the "remark" field.
func (m *ActivityOrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ActivityOrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ActivityOrderMutation) ResetRemark() {
	m.remark = nil
}

// SetPaidTime sets the "paid_time" field.
func (m *ActivityOrderMutation) SetPaidTime(t time.Time) {
	m.paid_time = &t
}

// PaidTime returns the value of the "paid_time" field in the mutation.
func (m *ActivityOrderMutation) PaidTime() (r time.Time, exists bool) {
	v := m.paid_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidTime returns the old "paid_time" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldPaidTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidTime: %w", err)
	}
	return oldValue.PaidTime, nil
}

// ClearPaidTime clears the value of the "paid_time" field.
func (m *ActivityOrderMutation) ClearPaidTime() {
	m.paid_time = nil
	m.clearedFields[activityorder.FieldPaidTime] = struct{}{}
}

// PaidTimeCleared returns if the "paid_time" field was cleared in this mutation.
func (m *ActivityOrderMutation) PaidTimeCleared() bool {
	_, ok := m.clearedFields[activityorder.FieldPaidTime]
	return ok
}

// ResetPaidTime resets all changes to the "paid_time" field.
func (m *ActivityOrderMutation) ResetPaidTime() {
	m.paid_time = nil
	delete(m.clearedFields, activityorder.FieldPaidTime)
}

// SetCreateTime sets the "create_time" field.
func (m *ActivityOrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ActivityOrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ActivityOrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ActivityOrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ActivityOrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ActivityOrder entity.
// If the ActivityOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityOrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ActivityOrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the ActivityOrderMutation builder.
func (m *ActivityOrderMutation) Where(ps ...predicate.ActivityOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityOrder).
func (m *ActivityOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityOrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.order_no != nil {
		fields = append(fields, activityorder.FieldOrderNo)
	}
	if m.wx_tx_id != nil {
		fields = append(fields, activityorder.FieldWxTxID)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, activityorder.FieldScenicAreaID)
	}
	if m.mch_id != nil {
		fields = append(fields, activityorder.FieldMchID)
	}
	if m.scenic_area_name != nil {
		fields = append(fields, activityorder.FieldScenicAreaName)
	}
	if m.user_id != nil {
		fields = append(fields, activityorder.FieldUserID)
	}
	if m.open_id != nil {
		fields = append(fields, activityorder.FieldOpenID)
	}
	if m.order_amount != nil {
		fields = append(fields, activityorder.FieldOrderAmount)
	}
	if m.order_state != nil {
		fields = append(fields, activityorder.FieldOrderState)
	}
	if m.remark != nil {
		fields = append(fields, activityorder.FieldRemark)
	}
	if m.paid_time != nil {
		fields = append(fields, activityorder.FieldPaidTime)
	}
	if m.create_time != nil {
		fields = append(fields, activityorder.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, activityorder.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activityorder.FieldOrderNo:
		return m.OrderNo()
	case activityorder.FieldWxTxID:
		return m.WxTxID()
	case activityorder.FieldScenicAreaID:
		return m.ScenicAreaID()
	case activityorder.FieldMchID:
		return m.MchID()
	case activityorder.FieldScenicAreaName:
		return m.ScenicAreaName()
	case activityorder.FieldUserID:
		return m.UserID()
	case activityorder.FieldOpenID:
		return m.OpenID()
	case activityorder.FieldOrderAmount:
		return m.OrderAmount()
	case activityorder.FieldOrderState:
		return m.OrderState()
	case activityorder.FieldRemark:
		return m.Remark()
	case activityorder.FieldPaidTime:
		return m.PaidTime()
	case activityorder.FieldCreateTime:
		return m.CreateTime()
	case activityorder.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activityorder.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case activityorder.FieldWxTxID:
		return m.OldWxTxID(ctx)
	case activityorder.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case activityorder.FieldMchID:
		return m.OldMchID(ctx)
	case activityorder.FieldScenicAreaName:
		return m.OldScenicAreaName(ctx)
	case activityorder.FieldUserID:
		return m.OldUserID(ctx)
	case activityorder.FieldOpenID:
		return m.OldOpenID(ctx)
	case activityorder.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case activityorder.FieldOrderState:
		return m.OldOrderState(ctx)
	case activityorder.FieldRemark:
		return m.OldRemark(ctx)
	case activityorder.FieldPaidTime:
		return m.OldPaidTime(ctx)
	case activityorder.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case activityorder.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activityorder.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case activityorder.FieldWxTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxTxID(v)
		return nil
	case activityorder.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case activityorder.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case activityorder.FieldScenicAreaName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaName(v)
		return nil
	case activityorder.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case activityorder.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case activityorder.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case activityorder.FieldOrderState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderState(v)
		return nil
	case activityorder.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case activityorder.FieldPaidTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidTime(v)
		return nil
	case activityorder.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case activityorder.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityOrderMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, activityorder.FieldScenicAreaID)
	}
	if m.adduser_id != nil {
		fields = append(fields, activityorder.FieldUserID)
	}
	if m.addorder_amount != nil {
		fields = append(fields, activityorder.FieldOrderAmount)
	}
	if m.addorder_state != nil {
		fields = append(fields, activityorder.FieldOrderState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activityorder.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case activityorder.FieldUserID:
		return m.AddedUserID()
	case activityorder.FieldOrderAmount:
		return m.AddedOrderAmount()
	case activityorder.FieldOrderState:
		return m.AddedOrderState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activityorder.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case activityorder.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case activityorder.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case activityorder.FieldOrderState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderState(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activityorder.FieldPaidTime) {
		fields = append(fields, activityorder.FieldPaidTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityOrderMutation) ClearField(name string) error {
	switch name {
	case activityorder.FieldPaidTime:
		m.ClearPaidTime()
		return nil
	}
	return fmt.Errorf("unknown ActivityOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityOrderMutation) ResetField(name string) error {
	switch name {
	case activityorder.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case activityorder.FieldWxTxID:
		m.ResetWxTxID()
		return nil
	case activityorder.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case activityorder.FieldMchID:
		m.ResetMchID()
		return nil
	case activityorder.FieldScenicAreaName:
		m.ResetScenicAreaName()
		return nil
	case activityorder.FieldUserID:
		m.ResetUserID()
		return nil
	case activityorder.FieldOpenID:
		m.ResetOpenID()
		return nil
	case activityorder.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case activityorder.FieldOrderState:
		m.ResetOrderState()
		return nil
	case activityorder.FieldRemark:
		m.ResetRemark()
		return nil
	case activityorder.FieldPaidTime:
		m.ResetPaidTime()
		return nil
	case activityorder.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case activityorder.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ActivityOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ActivityOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ActivityOrder edge %s", name)
}

// AppPushMutation represents an operation that mutates the AppPush nodes in the graph.
type AppPushMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user          *string
	title         *string
	content       *string
	state         *int
	addstate      *int
	remark        *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppPush, error)
	predicates    []predicate.AppPush
}

var _ ent.Mutation = (*AppPushMutation)(nil)

// apppushOption allows management of the mutation configuration using functional options.
type apppushOption func(*AppPushMutation)

// newAppPushMutation creates new mutation for the AppPush entity.
func newAppPushMutation(c config, op Op, opts ...apppushOption) *AppPushMutation {
	m := &AppPushMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPush,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPushID sets the ID field of the mutation.
func withAppPushID(id int) apppushOption {
	return func(m *AppPushMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPush
		)
		m.oldValue = func(ctx context.Context) (*AppPush, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPush.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPush sets the old AppPush of the mutation.
func withAppPush(node *AppPush) apppushOption {
	return func(m *AppPushMutation) {
		m.oldValue = func(context.Context) (*AppPush, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPushMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPushMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPush entities.
func (m *AppPushMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPushMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPushMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPush.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUser sets the "user" field.
func (m *AppPushMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *AppPushMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *AppPushMutation) ResetUser() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *AppPushMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AppPushMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AppPushMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *AppPushMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AppPushMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AppPushMutation) ResetContent() {
	m.content = nil
}

// SetState sets the "state" field.
func (m *AppPushMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *AppPushMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *AppPushMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *AppPushMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *AppPushMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetRemark sets the "remark" field.
func (m *AppPushMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AppPushMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *AppPushMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AppPushMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppPushMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppPushMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AppPushMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AppPushMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AppPush entity.
// If the AppPush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPushMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AppPushMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the AppPushMutation builder.
func (m *AppPushMutation) Where(ps ...predicate.AppPush) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPushMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPushMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPush, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPushMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPushMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPush).
func (m *AppPushMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPushMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, apppush.FieldUser)
	}
	if m.title != nil {
		fields = append(fields, apppush.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, apppush.FieldContent)
	}
	if m.state != nil {
		fields = append(fields, apppush.FieldState)
	}
	if m.remark != nil {
		fields = append(fields, apppush.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, apppush.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, apppush.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPushMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppush.FieldUser:
		return m.User()
	case apppush.FieldTitle:
		return m.Title()
	case apppush.FieldContent:
		return m.Content()
	case apppush.FieldState:
		return m.State()
	case apppush.FieldRemark:
		return m.Remark()
	case apppush.FieldCreateTime:
		return m.CreateTime()
	case apppush.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPushMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppush.FieldUser:
		return m.OldUser(ctx)
	case apppush.FieldTitle:
		return m.OldTitle(ctx)
	case apppush.FieldContent:
		return m.OldContent(ctx)
	case apppush.FieldState:
		return m.OldState(ctx)
	case apppush.FieldRemark:
		return m.OldRemark(ctx)
	case apppush.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case apppush.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AppPush field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPushMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppush.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case apppush.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case apppush.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case apppush.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case apppush.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case apppush.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case apppush.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppPush field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPushMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, apppush.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPushMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppush.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPushMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppush.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown AppPush numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPushMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPushMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPushMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppPush nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPushMutation) ResetField(name string) error {
	switch name {
	case apppush.FieldUser:
		m.ResetUser()
		return nil
	case apppush.FieldTitle:
		m.ResetTitle()
		return nil
	case apppush.FieldContent:
		m.ResetContent()
		return nil
	case apppush.FieldState:
		m.ResetState()
		return nil
	case apppush.FieldRemark:
		m.ResetRemark()
		return nil
	case apppush.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case apppush.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AppPush field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPushMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPushMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPushMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPushMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPushMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPushMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPushMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppPush unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPushMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppPush edge %s", name)
}

// AppVersionMutation represents an operation that mutates the AppVersion nodes in the graph.
type AppVersionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	platform         *string
	app_name         *string
	version          *string
	content          *string
	is_force_upgrade *bool
	file_id          *int
	addfile_id       *int
	state            *int
	addstate         *int
	publish_time     *time.Time
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AppVersion, error)
	predicates       []predicate.AppVersion
}

var _ ent.Mutation = (*AppVersionMutation)(nil)

// appversionOption allows management of the mutation configuration using functional options.
type appversionOption func(*AppVersionMutation)

// newAppVersionMutation creates new mutation for the AppVersion entity.
func newAppVersionMutation(c config, op Op, opts ...appversionOption) *AppVersionMutation {
	m := &AppVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppVersionID sets the ID field of the mutation.
func withAppVersionID(id int) appversionOption {
	return func(m *AppVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppVersion
		)
		m.oldValue = func(ctx context.Context) (*AppVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppVersion sets the old AppVersion of the mutation.
func withAppVersion(node *AppVersion) appversionOption {
	return func(m *AppVersionMutation) {
		m.oldValue = func(context.Context) (*AppVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppVersion entities.
func (m *AppVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *AppVersionMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AppVersionMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AppVersionMutation) ResetPlatform() {
	m.platform = nil
}

// SetAppName sets the "app_name" field.
func (m *AppVersionMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AppVersionMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AppVersionMutation) ResetAppName() {
	m.app_name = nil
}

// SetVersion sets the "version" field.
func (m *AppVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AppVersionMutation) ResetVersion() {
	m.version = nil
}

// SetContent sets the "content" field.
func (m *AppVersionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AppVersionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AppVersionMutation) ResetContent() {
	m.content = nil
}

// SetIsForceUpgrade sets the "is_force_upgrade" field.
func (m *AppVersionMutation) SetIsForceUpgrade(b bool) {
	m.is_force_upgrade = &b
}

// IsForceUpgrade returns the value of the "is_force_upgrade" field in the mutation.
func (m *AppVersionMutation) IsForceUpgrade() (r bool, exists bool) {
	v := m.is_force_upgrade
	if v == nil {
		return
	}
	return *v, true
}

// OldIsForceUpgrade returns the old "is_force_upgrade" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldIsForceUpgrade(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsForceUpgrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsForceUpgrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsForceUpgrade: %w", err)
	}
	return oldValue.IsForceUpgrade, nil
}

// ResetIsForceUpgrade resets all changes to the "is_force_upgrade" field.
func (m *AppVersionMutation) ResetIsForceUpgrade() {
	m.is_force_upgrade = nil
}

// SetFileID sets the "file_id" field.
func (m *AppVersionMutation) SetFileID(i int) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *AppVersionMutation) FileID() (r int, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *AppVersionMutation) AddFileID(i int) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *AppVersionMutation) AddedFileID() (r int, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *AppVersionMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetState sets the "state" field.
func (m *AppVersionMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *AppVersionMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *AppVersionMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *AppVersionMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *AppVersionMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetPublishTime sets the "publish_time" field.
func (m *AppVersionMutation) SetPublishTime(t time.Time) {
	m.publish_time = &t
}

// PublishTime returns the value of the "publish_time" field in the mutation.
func (m *AppVersionMutation) PublishTime() (r time.Time, exists bool) {
	v := m.publish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publish_time" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldPublishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ResetPublishTime resets all changes to the "publish_time" field.
func (m *AppVersionMutation) ResetPublishTime() {
	m.publish_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AppVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AppVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AppVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AppVersion entity.
// If the AppVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppVersionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AppVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the AppVersionMutation builder.
func (m *AppVersionMutation) Where(ps ...predicate.AppVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppVersion).
func (m *AppVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppVersionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.platform != nil {
		fields = append(fields, appversion.FieldPlatform)
	}
	if m.app_name != nil {
		fields = append(fields, appversion.FieldAppName)
	}
	if m.version != nil {
		fields = append(fields, appversion.FieldVersion)
	}
	if m.content != nil {
		fields = append(fields, appversion.FieldContent)
	}
	if m.is_force_upgrade != nil {
		fields = append(fields, appversion.FieldIsForceUpgrade)
	}
	if m.file_id != nil {
		fields = append(fields, appversion.FieldFileID)
	}
	if m.state != nil {
		fields = append(fields, appversion.FieldState)
	}
	if m.publish_time != nil {
		fields = append(fields, appversion.FieldPublishTime)
	}
	if m.create_time != nil {
		fields = append(fields, appversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, appversion.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldPlatform:
		return m.Platform()
	case appversion.FieldAppName:
		return m.AppName()
	case appversion.FieldVersion:
		return m.Version()
	case appversion.FieldContent:
		return m.Content()
	case appversion.FieldIsForceUpgrade:
		return m.IsForceUpgrade()
	case appversion.FieldFileID:
		return m.FileID()
	case appversion.FieldState:
		return m.State()
	case appversion.FieldPublishTime:
		return m.PublishTime()
	case appversion.FieldCreateTime:
		return m.CreateTime()
	case appversion.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appversion.FieldPlatform:
		return m.OldPlatform(ctx)
	case appversion.FieldAppName:
		return m.OldAppName(ctx)
	case appversion.FieldVersion:
		return m.OldVersion(ctx)
	case appversion.FieldContent:
		return m.OldContent(ctx)
	case appversion.FieldIsForceUpgrade:
		return m.OldIsForceUpgrade(ctx)
	case appversion.FieldFileID:
		return m.OldFileID(ctx)
	case appversion.FieldState:
		return m.OldState(ctx)
	case appversion.FieldPublishTime:
		return m.OldPublishTime(ctx)
	case appversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown AppVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case appversion.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case appversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case appversion.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case appversion.FieldIsForceUpgrade:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsForceUpgrade(v)
		return nil
	case appversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case appversion.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case appversion.FieldPublishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	case appversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppVersionMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, appversion.FieldFileID)
	}
	if m.addstate != nil {
		fields = append(fields, appversion.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appversion.FieldFileID:
		return m.AddedFileID()
	case appversion.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case appversion.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown AppVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppVersionMutation) ResetField(name string) error {
	switch name {
	case appversion.FieldPlatform:
		m.ResetPlatform()
		return nil
	case appversion.FieldAppName:
		m.ResetAppName()
		return nil
	case appversion.FieldVersion:
		m.ResetVersion()
		return nil
	case appversion.FieldContent:
		m.ResetContent()
		return nil
	case appversion.FieldIsForceUpgrade:
		m.ResetIsForceUpgrade()
		return nil
	case appversion.FieldFileID:
		m.ResetFileID()
		return nil
	case appversion.FieldState:
		m.ResetState()
		return nil
	case appversion.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	case appversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown AppVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppVersion edge %s", name)
}

// BillingStrategyMutation represents an operation that mutates the BillingStrategy nodes in the graph.
type BillingStrategyMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	name                          *string
	model_id                      *int
	addmodel_id                   *int
	main_mode                     *int
	addmain_mode                  *int
	start_time_price              *int
	addstart_time_price           *int
	start_time_unit               *int
	addstart_time_unit            *int
	normal_time_price             *int
	addnormal_time_price          *int
	normal_time_unit              *int
	addnormal_time_unit           *int
	start_mileage_price           *int
	addstart_mileage_price        *int
	start_mileage_unit            *int
	addstart_mileage_unit         *int
	normal_mileage_price          *int
	addnormal_mileage_price       *int
	normal_mileage_unit           *int
	addnormal_mileage_unit        *int
	start_stop_price              *int
	addstart_stop_price           *int
	start_stop_unit               *int
	addstart_stop_unit            *int
	normal_stop_price             *int
	addnormal_stop_price          *int
	normal_stop_unit              *int
	addnormal_stop_unit           *int
	capped_amount                 *int
	addcapped_amount              *int
	deposit_amount                *int
	adddeposit_amount             *int
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*BillingStrategy, error)
	predicates                    []predicate.BillingStrategy
}

var _ ent.Mutation = (*BillingStrategyMutation)(nil)

// billingstrategyOption allows management of the mutation configuration using functional options.
type billingstrategyOption func(*BillingStrategyMutation)

// newBillingStrategyMutation creates new mutation for the BillingStrategy entity.
func newBillingStrategyMutation(c config, op Op, opts ...billingstrategyOption) *BillingStrategyMutation {
	m := &BillingStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingStrategyID sets the ID field of the mutation.
func withBillingStrategyID(id int) billingstrategyOption {
	return func(m *BillingStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingStrategy
		)
		m.oldValue = func(ctx context.Context) (*BillingStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingStrategy sets the old BillingStrategy of the mutation.
func withBillingStrategy(node *BillingStrategy) billingstrategyOption {
	return func(m *BillingStrategyMutation) {
		m.oldValue = func(context.Context) (*BillingStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingStrategy entities.
func (m *BillingStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BillingStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BillingStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BillingStrategyMutation) ResetName() {
	m.name = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *BillingStrategyMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *BillingStrategyMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *BillingStrategyMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetModelID sets the "model_id" field.
func (m *BillingStrategyMutation) SetModelID(i int) {
	m.model_id = &i
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *BillingStrategyMutation) ModelID() (r int, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds i to the "model_id" field.
func (m *BillingStrategyMutation) AddModelID(i int) {
	if m.addmodel_id != nil {
		*m.addmodel_id += i
	} else {
		m.addmodel_id = &i
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *BillingStrategyMutation) AddedModelID() (r int, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetModelID resets all changes to the "model_id" field.
func (m *BillingStrategyMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
}

// SetMainMode sets the "main_mode" field.
func (m *BillingStrategyMutation) SetMainMode(i int) {
	m.main_mode = &i
	m.addmain_mode = nil
}

// MainMode returns the value of the "main_mode" field in the mutation.
func (m *BillingStrategyMutation) MainMode() (r int, exists bool) {
	v := m.main_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMainMode returns the old "main_mode" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldMainMode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainMode: %w", err)
	}
	return oldValue.MainMode, nil
}

// AddMainMode adds i to the "main_mode" field.
func (m *BillingStrategyMutation) AddMainMode(i int) {
	if m.addmain_mode != nil {
		*m.addmain_mode += i
	} else {
		m.addmain_mode = &i
	}
}

// AddedMainMode returns the value that was added to the "main_mode" field in this mutation.
func (m *BillingStrategyMutation) AddedMainMode() (r int, exists bool) {
	v := m.addmain_mode
	if v == nil {
		return
	}
	return *v, true
}

// ResetMainMode resets all changes to the "main_mode" field.
func (m *BillingStrategyMutation) ResetMainMode() {
	m.main_mode = nil
	m.addmain_mode = nil
}

// SetStartTimePrice sets the "start_time_price" field.
func (m *BillingStrategyMutation) SetStartTimePrice(i int) {
	m.start_time_price = &i
	m.addstart_time_price = nil
}

// StartTimePrice returns the value of the "start_time_price" field in the mutation.
func (m *BillingStrategyMutation) StartTimePrice() (r int, exists bool) {
	v := m.start_time_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimePrice returns the old "start_time_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartTimePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimePrice: %w", err)
	}
	return oldValue.StartTimePrice, nil
}

// AddStartTimePrice adds i to the "start_time_price" field.
func (m *BillingStrategyMutation) AddStartTimePrice(i int) {
	if m.addstart_time_price != nil {
		*m.addstart_time_price += i
	} else {
		m.addstart_time_price = &i
	}
}

// AddedStartTimePrice returns the value that was added to the "start_time_price" field in this mutation.
func (m *BillingStrategyMutation) AddedStartTimePrice() (r int, exists bool) {
	v := m.addstart_time_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTimePrice resets all changes to the "start_time_price" field.
func (m *BillingStrategyMutation) ResetStartTimePrice() {
	m.start_time_price = nil
	m.addstart_time_price = nil
}

// SetStartTimeUnit sets the "start_time_unit" field.
func (m *BillingStrategyMutation) SetStartTimeUnit(i int) {
	m.start_time_unit = &i
	m.addstart_time_unit = nil
}

// StartTimeUnit returns the value of the "start_time_unit" field in the mutation.
func (m *BillingStrategyMutation) StartTimeUnit() (r int, exists bool) {
	v := m.start_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimeUnit returns the old "start_time_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartTimeUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimeUnit: %w", err)
	}
	return oldValue.StartTimeUnit, nil
}

// AddStartTimeUnit adds i to the "start_time_unit" field.
func (m *BillingStrategyMutation) AddStartTimeUnit(i int) {
	if m.addstart_time_unit != nil {
		*m.addstart_time_unit += i
	} else {
		m.addstart_time_unit = &i
	}
}

// AddedStartTimeUnit returns the value that was added to the "start_time_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedStartTimeUnit() (r int, exists bool) {
	v := m.addstart_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTimeUnit resets all changes to the "start_time_unit" field.
func (m *BillingStrategyMutation) ResetStartTimeUnit() {
	m.start_time_unit = nil
	m.addstart_time_unit = nil
}

// SetNormalTimePrice sets the "normal_time_price" field.
func (m *BillingStrategyMutation) SetNormalTimePrice(i int) {
	m.normal_time_price = &i
	m.addnormal_time_price = nil
}

// NormalTimePrice returns the value of the "normal_time_price" field in the mutation.
func (m *BillingStrategyMutation) NormalTimePrice() (r int, exists bool) {
	v := m.normal_time_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTimePrice returns the old "normal_time_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalTimePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTimePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTimePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTimePrice: %w", err)
	}
	return oldValue.NormalTimePrice, nil
}

// AddNormalTimePrice adds i to the "normal_time_price" field.
func (m *BillingStrategyMutation) AddNormalTimePrice(i int) {
	if m.addnormal_time_price != nil {
		*m.addnormal_time_price += i
	} else {
		m.addnormal_time_price = &i
	}
}

// AddedNormalTimePrice returns the value that was added to the "normal_time_price" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalTimePrice() (r int, exists bool) {
	v := m.addnormal_time_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTimePrice resets all changes to the "normal_time_price" field.
func (m *BillingStrategyMutation) ResetNormalTimePrice() {
	m.normal_time_price = nil
	m.addnormal_time_price = nil
}

// SetNormalTimeUnit sets the "normal_time_unit" field.
func (m *BillingStrategyMutation) SetNormalTimeUnit(i int) {
	m.normal_time_unit = &i
	m.addnormal_time_unit = nil
}

// NormalTimeUnit returns the value of the "normal_time_unit" field in the mutation.
func (m *BillingStrategyMutation) NormalTimeUnit() (r int, exists bool) {
	v := m.normal_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTimeUnit returns the old "normal_time_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalTimeUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTimeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTimeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTimeUnit: %w", err)
	}
	return oldValue.NormalTimeUnit, nil
}

// AddNormalTimeUnit adds i to the "normal_time_unit" field.
func (m *BillingStrategyMutation) AddNormalTimeUnit(i int) {
	if m.addnormal_time_unit != nil {
		*m.addnormal_time_unit += i
	} else {
		m.addnormal_time_unit = &i
	}
}

// AddedNormalTimeUnit returns the value that was added to the "normal_time_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalTimeUnit() (r int, exists bool) {
	v := m.addnormal_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTimeUnit resets all changes to the "normal_time_unit" field.
func (m *BillingStrategyMutation) ResetNormalTimeUnit() {
	m.normal_time_unit = nil
	m.addnormal_time_unit = nil
}

// SetStartMileagePrice sets the "start_mileage_price" field.
func (m *BillingStrategyMutation) SetStartMileagePrice(i int) {
	m.start_mileage_price = &i
	m.addstart_mileage_price = nil
}

// StartMileagePrice returns the value of the "start_mileage_price" field in the mutation.
func (m *BillingStrategyMutation) StartMileagePrice() (r int, exists bool) {
	v := m.start_mileage_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMileagePrice returns the old "start_mileage_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartMileagePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMileagePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMileagePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMileagePrice: %w", err)
	}
	return oldValue.StartMileagePrice, nil
}

// AddStartMileagePrice adds i to the "start_mileage_price" field.
func (m *BillingStrategyMutation) AddStartMileagePrice(i int) {
	if m.addstart_mileage_price != nil {
		*m.addstart_mileage_price += i
	} else {
		m.addstart_mileage_price = &i
	}
}

// AddedStartMileagePrice returns the value that was added to the "start_mileage_price" field in this mutation.
func (m *BillingStrategyMutation) AddedStartMileagePrice() (r int, exists bool) {
	v := m.addstart_mileage_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartMileagePrice resets all changes to the "start_mileage_price" field.
func (m *BillingStrategyMutation) ResetStartMileagePrice() {
	m.start_mileage_price = nil
	m.addstart_mileage_price = nil
}

// SetStartMileageUnit sets the "start_mileage_unit" field.
func (m *BillingStrategyMutation) SetStartMileageUnit(i int) {
	m.start_mileage_unit = &i
	m.addstart_mileage_unit = nil
}

// StartMileageUnit returns the value of the "start_mileage_unit" field in the mutation.
func (m *BillingStrategyMutation) StartMileageUnit() (r int, exists bool) {
	v := m.start_mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldStartMileageUnit returns the old "start_mileage_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartMileageUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartMileageUnit: %w", err)
	}
	return oldValue.StartMileageUnit, nil
}

// AddStartMileageUnit adds i to the "start_mileage_unit" field.
func (m *BillingStrategyMutation) AddStartMileageUnit(i int) {
	if m.addstart_mileage_unit != nil {
		*m.addstart_mileage_unit += i
	} else {
		m.addstart_mileage_unit = &i
	}
}

// AddedStartMileageUnit returns the value that was added to the "start_mileage_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedStartMileageUnit() (r int, exists bool) {
	v := m.addstart_mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartMileageUnit resets all changes to the "start_mileage_unit" field.
func (m *BillingStrategyMutation) ResetStartMileageUnit() {
	m.start_mileage_unit = nil
	m.addstart_mileage_unit = nil
}

// SetNormalMileagePrice sets the "normal_mileage_price" field.
func (m *BillingStrategyMutation) SetNormalMileagePrice(i int) {
	m.normal_mileage_price = &i
	m.addnormal_mileage_price = nil
}

// NormalMileagePrice returns the value of the "normal_mileage_price" field in the mutation.
func (m *BillingStrategyMutation) NormalMileagePrice() (r int, exists bool) {
	v := m.normal_mileage_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalMileagePrice returns the old "normal_mileage_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalMileagePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalMileagePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalMileagePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalMileagePrice: %w", err)
	}
	return oldValue.NormalMileagePrice, nil
}

// AddNormalMileagePrice adds i to the "normal_mileage_price" field.
func (m *BillingStrategyMutation) AddNormalMileagePrice(i int) {
	if m.addnormal_mileage_price != nil {
		*m.addnormal_mileage_price += i
	} else {
		m.addnormal_mileage_price = &i
	}
}

// AddedNormalMileagePrice returns the value that was added to the "normal_mileage_price" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalMileagePrice() (r int, exists bool) {
	v := m.addnormal_mileage_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalMileagePrice resets all changes to the "normal_mileage_price" field.
func (m *BillingStrategyMutation) ResetNormalMileagePrice() {
	m.normal_mileage_price = nil
	m.addnormal_mileage_price = nil
}

// SetNormalMileageUnit sets the "normal_mileage_unit" field.
func (m *BillingStrategyMutation) SetNormalMileageUnit(i int) {
	m.normal_mileage_unit = &i
	m.addnormal_mileage_unit = nil
}

// NormalMileageUnit returns the value of the "normal_mileage_unit" field in the mutation.
func (m *BillingStrategyMutation) NormalMileageUnit() (r int, exists bool) {
	v := m.normal_mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalMileageUnit returns the old "normal_mileage_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalMileageUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalMileageUnit: %w", err)
	}
	return oldValue.NormalMileageUnit, nil
}

// AddNormalMileageUnit adds i to the "normal_mileage_unit" field.
func (m *BillingStrategyMutation) AddNormalMileageUnit(i int) {
	if m.addnormal_mileage_unit != nil {
		*m.addnormal_mileage_unit += i
	} else {
		m.addnormal_mileage_unit = &i
	}
}

// AddedNormalMileageUnit returns the value that was added to the "normal_mileage_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalMileageUnit() (r int, exists bool) {
	v := m.addnormal_mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalMileageUnit resets all changes to the "normal_mileage_unit" field.
func (m *BillingStrategyMutation) ResetNormalMileageUnit() {
	m.normal_mileage_unit = nil
	m.addnormal_mileage_unit = nil
}

// SetStartStopPrice sets the "start_stop_price" field.
func (m *BillingStrategyMutation) SetStartStopPrice(i int) {
	m.start_stop_price = &i
	m.addstart_stop_price = nil
}

// StartStopPrice returns the value of the "start_stop_price" field in the mutation.
func (m *BillingStrategyMutation) StartStopPrice() (r int, exists bool) {
	v := m.start_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStopPrice returns the old "start_stop_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartStopPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStopPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStopPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStopPrice: %w", err)
	}
	return oldValue.StartStopPrice, nil
}

// AddStartStopPrice adds i to the "start_stop_price" field.
func (m *BillingStrategyMutation) AddStartStopPrice(i int) {
	if m.addstart_stop_price != nil {
		*m.addstart_stop_price += i
	} else {
		m.addstart_stop_price = &i
	}
}

// AddedStartStopPrice returns the value that was added to the "start_stop_price" field in this mutation.
func (m *BillingStrategyMutation) AddedStartStopPrice() (r int, exists bool) {
	v := m.addstart_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartStopPrice resets all changes to the "start_stop_price" field.
func (m *BillingStrategyMutation) ResetStartStopPrice() {
	m.start_stop_price = nil
	m.addstart_stop_price = nil
}

// SetStartStopUnit sets the "start_stop_unit" field.
func (m *BillingStrategyMutation) SetStartStopUnit(i int) {
	m.start_stop_unit = &i
	m.addstart_stop_unit = nil
}

// StartStopUnit returns the value of the "start_stop_unit" field in the mutation.
func (m *BillingStrategyMutation) StartStopUnit() (r int, exists bool) {
	v := m.start_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStopUnit returns the old "start_stop_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldStartStopUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStopUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStopUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStopUnit: %w", err)
	}
	return oldValue.StartStopUnit, nil
}

// AddStartStopUnit adds i to the "start_stop_unit" field.
func (m *BillingStrategyMutation) AddStartStopUnit(i int) {
	if m.addstart_stop_unit != nil {
		*m.addstart_stop_unit += i
	} else {
		m.addstart_stop_unit = &i
	}
}

// AddedStartStopUnit returns the value that was added to the "start_stop_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedStartStopUnit() (r int, exists bool) {
	v := m.addstart_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartStopUnit resets all changes to the "start_stop_unit" field.
func (m *BillingStrategyMutation) ResetStartStopUnit() {
	m.start_stop_unit = nil
	m.addstart_stop_unit = nil
}

// SetNormalStopPrice sets the "normal_stop_price" field.
func (m *BillingStrategyMutation) SetNormalStopPrice(i int) {
	m.normal_stop_price = &i
	m.addnormal_stop_price = nil
}

// NormalStopPrice returns the value of the "normal_stop_price" field in the mutation.
func (m *BillingStrategyMutation) NormalStopPrice() (r int, exists bool) {
	v := m.normal_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalStopPrice returns the old "normal_stop_price" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalStopPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalStopPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalStopPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalStopPrice: %w", err)
	}
	return oldValue.NormalStopPrice, nil
}

// AddNormalStopPrice adds i to the "normal_stop_price" field.
func (m *BillingStrategyMutation) AddNormalStopPrice(i int) {
	if m.addnormal_stop_price != nil {
		*m.addnormal_stop_price += i
	} else {
		m.addnormal_stop_price = &i
	}
}

// AddedNormalStopPrice returns the value that was added to the "normal_stop_price" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalStopPrice() (r int, exists bool) {
	v := m.addnormal_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalStopPrice resets all changes to the "normal_stop_price" field.
func (m *BillingStrategyMutation) ResetNormalStopPrice() {
	m.normal_stop_price = nil
	m.addnormal_stop_price = nil
}

// SetNormalStopUnit sets the "normal_stop_unit" field.
func (m *BillingStrategyMutation) SetNormalStopUnit(i int) {
	m.normal_stop_unit = &i
	m.addnormal_stop_unit = nil
}

// NormalStopUnit returns the value of the "normal_stop_unit" field in the mutation.
func (m *BillingStrategyMutation) NormalStopUnit() (r int, exists bool) {
	v := m.normal_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalStopUnit returns the old "normal_stop_unit" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldNormalStopUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalStopUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalStopUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalStopUnit: %w", err)
	}
	return oldValue.NormalStopUnit, nil
}

// AddNormalStopUnit adds i to the "normal_stop_unit" field.
func (m *BillingStrategyMutation) AddNormalStopUnit(i int) {
	if m.addnormal_stop_unit != nil {
		*m.addnormal_stop_unit += i
	} else {
		m.addnormal_stop_unit = &i
	}
}

// AddedNormalStopUnit returns the value that was added to the "normal_stop_unit" field in this mutation.
func (m *BillingStrategyMutation) AddedNormalStopUnit() (r int, exists bool) {
	v := m.addnormal_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalStopUnit resets all changes to the "normal_stop_unit" field.
func (m *BillingStrategyMutation) ResetNormalStopUnit() {
	m.normal_stop_unit = nil
	m.addnormal_stop_unit = nil
}

// SetCappedAmount sets the "capped_amount" field.
func (m *BillingStrategyMutation) SetCappedAmount(i int) {
	m.capped_amount = &i
	m.addcapped_amount = nil
}

// CappedAmount returns the value of the "capped_amount" field in the mutation.
func (m *BillingStrategyMutation) CappedAmount() (r int, exists bool) {
	v := m.capped_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCappedAmount returns the old "capped_amount" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldCappedAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCappedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCappedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCappedAmount: %w", err)
	}
	return oldValue.CappedAmount, nil
}

// AddCappedAmount adds i to the "capped_amount" field.
func (m *BillingStrategyMutation) AddCappedAmount(i int) {
	if m.addcapped_amount != nil {
		*m.addcapped_amount += i
	} else {
		m.addcapped_amount = &i
	}
}

// AddedCappedAmount returns the value that was added to the "capped_amount" field in this mutation.
func (m *BillingStrategyMutation) AddedCappedAmount() (r int, exists bool) {
	v := m.addcapped_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCappedAmount resets all changes to the "capped_amount" field.
func (m *BillingStrategyMutation) ResetCappedAmount() {
	m.capped_amount = nil
	m.addcapped_amount = nil
}

// SetDepositAmount sets the "deposit_amount" field.
func (m *BillingStrategyMutation) SetDepositAmount(i int) {
	m.deposit_amount = &i
	m.adddeposit_amount = nil
}

// DepositAmount returns the value of the "deposit_amount" field in the mutation.
func (m *BillingStrategyMutation) DepositAmount() (r int, exists bool) {
	v := m.deposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositAmount returns the old "deposit_amount" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldDepositAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositAmount: %w", err)
	}
	return oldValue.DepositAmount, nil
}

// AddDepositAmount adds i to the "deposit_amount" field.
func (m *BillingStrategyMutation) AddDepositAmount(i int) {
	if m.adddeposit_amount != nil {
		*m.adddeposit_amount += i
	} else {
		m.adddeposit_amount = &i
	}
}

// AddedDepositAmount returns the value that was added to the "deposit_amount" field in this mutation.
func (m *BillingStrategyMutation) AddedDepositAmount() (r int, exists bool) {
	v := m.adddeposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepositAmount resets all changes to the "deposit_amount" field.
func (m *BillingStrategyMutation) ResetDepositAmount() {
	m.deposit_amount = nil
	m.adddeposit_amount = nil
}

// SetCreateTime sets the "create_time" field.
func (m *BillingStrategyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BillingStrategyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BillingStrategyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BillingStrategyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BillingStrategyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BillingStrategy entity.
// If the BillingStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingStrategyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BillingStrategyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *BillingStrategyMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *BillingStrategyMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[billingstrategy.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *BillingStrategyMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *BillingStrategyMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *BillingStrategyMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *BillingStrategyMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the BillingStrategyMutation builder.
func (m *BillingStrategyMutation) Where(ps ...predicate.BillingStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingStrategy).
func (m *BillingStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingStrategyMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.name != nil {
		fields = append(fields, billingstrategy.FieldName)
	}
	if m.background_scenic_area != nil {
		fields = append(fields, billingstrategy.FieldScenicAreaID)
	}
	if m.model_id != nil {
		fields = append(fields, billingstrategy.FieldModelID)
	}
	if m.main_mode != nil {
		fields = append(fields, billingstrategy.FieldMainMode)
	}
	if m.start_time_price != nil {
		fields = append(fields, billingstrategy.FieldStartTimePrice)
	}
	if m.start_time_unit != nil {
		fields = append(fields, billingstrategy.FieldStartTimeUnit)
	}
	if m.normal_time_price != nil {
		fields = append(fields, billingstrategy.FieldNormalTimePrice)
	}
	if m.normal_time_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalTimeUnit)
	}
	if m.start_mileage_price != nil {
		fields = append(fields, billingstrategy.FieldStartMileagePrice)
	}
	if m.start_mileage_unit != nil {
		fields = append(fields, billingstrategy.FieldStartMileageUnit)
	}
	if m.normal_mileage_price != nil {
		fields = append(fields, billingstrategy.FieldNormalMileagePrice)
	}
	if m.normal_mileage_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalMileageUnit)
	}
	if m.start_stop_price != nil {
		fields = append(fields, billingstrategy.FieldStartStopPrice)
	}
	if m.start_stop_unit != nil {
		fields = append(fields, billingstrategy.FieldStartStopUnit)
	}
	if m.normal_stop_price != nil {
		fields = append(fields, billingstrategy.FieldNormalStopPrice)
	}
	if m.normal_stop_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalStopUnit)
	}
	if m.capped_amount != nil {
		fields = append(fields, billingstrategy.FieldCappedAmount)
	}
	if m.deposit_amount != nil {
		fields = append(fields, billingstrategy.FieldDepositAmount)
	}
	if m.create_time != nil {
		fields = append(fields, billingstrategy.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, billingstrategy.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingstrategy.FieldName:
		return m.Name()
	case billingstrategy.FieldScenicAreaID:
		return m.ScenicAreaID()
	case billingstrategy.FieldModelID:
		return m.ModelID()
	case billingstrategy.FieldMainMode:
		return m.MainMode()
	case billingstrategy.FieldStartTimePrice:
		return m.StartTimePrice()
	case billingstrategy.FieldStartTimeUnit:
		return m.StartTimeUnit()
	case billingstrategy.FieldNormalTimePrice:
		return m.NormalTimePrice()
	case billingstrategy.FieldNormalTimeUnit:
		return m.NormalTimeUnit()
	case billingstrategy.FieldStartMileagePrice:
		return m.StartMileagePrice()
	case billingstrategy.FieldStartMileageUnit:
		return m.StartMileageUnit()
	case billingstrategy.FieldNormalMileagePrice:
		return m.NormalMileagePrice()
	case billingstrategy.FieldNormalMileageUnit:
		return m.NormalMileageUnit()
	case billingstrategy.FieldStartStopPrice:
		return m.StartStopPrice()
	case billingstrategy.FieldStartStopUnit:
		return m.StartStopUnit()
	case billingstrategy.FieldNormalStopPrice:
		return m.NormalStopPrice()
	case billingstrategy.FieldNormalStopUnit:
		return m.NormalStopUnit()
	case billingstrategy.FieldCappedAmount:
		return m.CappedAmount()
	case billingstrategy.FieldDepositAmount:
		return m.DepositAmount()
	case billingstrategy.FieldCreateTime:
		return m.CreateTime()
	case billingstrategy.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingstrategy.FieldName:
		return m.OldName(ctx)
	case billingstrategy.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case billingstrategy.FieldModelID:
		return m.OldModelID(ctx)
	case billingstrategy.FieldMainMode:
		return m.OldMainMode(ctx)
	case billingstrategy.FieldStartTimePrice:
		return m.OldStartTimePrice(ctx)
	case billingstrategy.FieldStartTimeUnit:
		return m.OldStartTimeUnit(ctx)
	case billingstrategy.FieldNormalTimePrice:
		return m.OldNormalTimePrice(ctx)
	case billingstrategy.FieldNormalTimeUnit:
		return m.OldNormalTimeUnit(ctx)
	case billingstrategy.FieldStartMileagePrice:
		return m.OldStartMileagePrice(ctx)
	case billingstrategy.FieldStartMileageUnit:
		return m.OldStartMileageUnit(ctx)
	case billingstrategy.FieldNormalMileagePrice:
		return m.OldNormalMileagePrice(ctx)
	case billingstrategy.FieldNormalMileageUnit:
		return m.OldNormalMileageUnit(ctx)
	case billingstrategy.FieldStartStopPrice:
		return m.OldStartStopPrice(ctx)
	case billingstrategy.FieldStartStopUnit:
		return m.OldStartStopUnit(ctx)
	case billingstrategy.FieldNormalStopPrice:
		return m.OldNormalStopPrice(ctx)
	case billingstrategy.FieldNormalStopUnit:
		return m.OldNormalStopUnit(ctx)
	case billingstrategy.FieldCappedAmount:
		return m.OldCappedAmount(ctx)
	case billingstrategy.FieldDepositAmount:
		return m.OldDepositAmount(ctx)
	case billingstrategy.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case billingstrategy.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown BillingStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingstrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case billingstrategy.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case billingstrategy.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case billingstrategy.FieldMainMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainMode(v)
		return nil
	case billingstrategy.FieldStartTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimePrice(v)
		return nil
	case billingstrategy.FieldStartTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimeUnit(v)
		return nil
	case billingstrategy.FieldNormalTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTimePrice(v)
		return nil
	case billingstrategy.FieldNormalTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTimeUnit(v)
		return nil
	case billingstrategy.FieldStartMileagePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMileagePrice(v)
		return nil
	case billingstrategy.FieldStartMileageUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartMileageUnit(v)
		return nil
	case billingstrategy.FieldNormalMileagePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalMileagePrice(v)
		return nil
	case billingstrategy.FieldNormalMileageUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalMileageUnit(v)
		return nil
	case billingstrategy.FieldStartStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStopPrice(v)
		return nil
	case billingstrategy.FieldStartStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStopUnit(v)
		return nil
	case billingstrategy.FieldNormalStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalStopPrice(v)
		return nil
	case billingstrategy.FieldNormalStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalStopUnit(v)
		return nil
	case billingstrategy.FieldCappedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCappedAmount(v)
		return nil
	case billingstrategy.FieldDepositAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositAmount(v)
		return nil
	case billingstrategy.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case billingstrategy.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown BillingStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingStrategyMutation) AddedFields() []string {
	var fields []string
	if m.addmodel_id != nil {
		fields = append(fields, billingstrategy.FieldModelID)
	}
	if m.addmain_mode != nil {
		fields = append(fields, billingstrategy.FieldMainMode)
	}
	if m.addstart_time_price != nil {
		fields = append(fields, billingstrategy.FieldStartTimePrice)
	}
	if m.addstart_time_unit != nil {
		fields = append(fields, billingstrategy.FieldStartTimeUnit)
	}
	if m.addnormal_time_price != nil {
		fields = append(fields, billingstrategy.FieldNormalTimePrice)
	}
	if m.addnormal_time_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalTimeUnit)
	}
	if m.addstart_mileage_price != nil {
		fields = append(fields, billingstrategy.FieldStartMileagePrice)
	}
	if m.addstart_mileage_unit != nil {
		fields = append(fields, billingstrategy.FieldStartMileageUnit)
	}
	if m.addnormal_mileage_price != nil {
		fields = append(fields, billingstrategy.FieldNormalMileagePrice)
	}
	if m.addnormal_mileage_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalMileageUnit)
	}
	if m.addstart_stop_price != nil {
		fields = append(fields, billingstrategy.FieldStartStopPrice)
	}
	if m.addstart_stop_unit != nil {
		fields = append(fields, billingstrategy.FieldStartStopUnit)
	}
	if m.addnormal_stop_price != nil {
		fields = append(fields, billingstrategy.FieldNormalStopPrice)
	}
	if m.addnormal_stop_unit != nil {
		fields = append(fields, billingstrategy.FieldNormalStopUnit)
	}
	if m.addcapped_amount != nil {
		fields = append(fields, billingstrategy.FieldCappedAmount)
	}
	if m.adddeposit_amount != nil {
		fields = append(fields, billingstrategy.FieldDepositAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingStrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case billingstrategy.FieldModelID:
		return m.AddedModelID()
	case billingstrategy.FieldMainMode:
		return m.AddedMainMode()
	case billingstrategy.FieldStartTimePrice:
		return m.AddedStartTimePrice()
	case billingstrategy.FieldStartTimeUnit:
		return m.AddedStartTimeUnit()
	case billingstrategy.FieldNormalTimePrice:
		return m.AddedNormalTimePrice()
	case billingstrategy.FieldNormalTimeUnit:
		return m.AddedNormalTimeUnit()
	case billingstrategy.FieldStartMileagePrice:
		return m.AddedStartMileagePrice()
	case billingstrategy.FieldStartMileageUnit:
		return m.AddedStartMileageUnit()
	case billingstrategy.FieldNormalMileagePrice:
		return m.AddedNormalMileagePrice()
	case billingstrategy.FieldNormalMileageUnit:
		return m.AddedNormalMileageUnit()
	case billingstrategy.FieldStartStopPrice:
		return m.AddedStartStopPrice()
	case billingstrategy.FieldStartStopUnit:
		return m.AddedStartStopUnit()
	case billingstrategy.FieldNormalStopPrice:
		return m.AddedNormalStopPrice()
	case billingstrategy.FieldNormalStopUnit:
		return m.AddedNormalStopUnit()
	case billingstrategy.FieldCappedAmount:
		return m.AddedCappedAmount()
	case billingstrategy.FieldDepositAmount:
		return m.AddedDepositAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case billingstrategy.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case billingstrategy.FieldMainMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMainMode(v)
		return nil
	case billingstrategy.FieldStartTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimePrice(v)
		return nil
	case billingstrategy.FieldStartTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimeUnit(v)
		return nil
	case billingstrategy.FieldNormalTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTimePrice(v)
		return nil
	case billingstrategy.FieldNormalTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTimeUnit(v)
		return nil
	case billingstrategy.FieldStartMileagePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartMileagePrice(v)
		return nil
	case billingstrategy.FieldStartMileageUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartMileageUnit(v)
		return nil
	case billingstrategy.FieldNormalMileagePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalMileagePrice(v)
		return nil
	case billingstrategy.FieldNormalMileageUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalMileageUnit(v)
		return nil
	case billingstrategy.FieldStartStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartStopPrice(v)
		return nil
	case billingstrategy.FieldStartStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartStopUnit(v)
		return nil
	case billingstrategy.FieldNormalStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalStopPrice(v)
		return nil
	case billingstrategy.FieldNormalStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalStopUnit(v)
		return nil
	case billingstrategy.FieldCappedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCappedAmount(v)
		return nil
	case billingstrategy.FieldDepositAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositAmount(v)
		return nil
	}
	return fmt.Errorf("unknown BillingStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingStrategyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingStrategyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingStrategyMutation) ResetField(name string) error {
	switch name {
	case billingstrategy.FieldName:
		m.ResetName()
		return nil
	case billingstrategy.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case billingstrategy.FieldModelID:
		m.ResetModelID()
		return nil
	case billingstrategy.FieldMainMode:
		m.ResetMainMode()
		return nil
	case billingstrategy.FieldStartTimePrice:
		m.ResetStartTimePrice()
		return nil
	case billingstrategy.FieldStartTimeUnit:
		m.ResetStartTimeUnit()
		return nil
	case billingstrategy.FieldNormalTimePrice:
		m.ResetNormalTimePrice()
		return nil
	case billingstrategy.FieldNormalTimeUnit:
		m.ResetNormalTimeUnit()
		return nil
	case billingstrategy.FieldStartMileagePrice:
		m.ResetStartMileagePrice()
		return nil
	case billingstrategy.FieldStartMileageUnit:
		m.ResetStartMileageUnit()
		return nil
	case billingstrategy.FieldNormalMileagePrice:
		m.ResetNormalMileagePrice()
		return nil
	case billingstrategy.FieldNormalMileageUnit:
		m.ResetNormalMileageUnit()
		return nil
	case billingstrategy.FieldStartStopPrice:
		m.ResetStartStopPrice()
		return nil
	case billingstrategy.FieldStartStopUnit:
		m.ResetStartStopUnit()
		return nil
	case billingstrategy.FieldNormalStopPrice:
		m.ResetNormalStopPrice()
		return nil
	case billingstrategy.FieldNormalStopUnit:
		m.ResetNormalStopUnit()
		return nil
	case billingstrategy.FieldCappedAmount:
		m.ResetCappedAmount()
		return nil
	case billingstrategy.FieldDepositAmount:
		m.ResetDepositAmount()
		return nil
	case billingstrategy.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case billingstrategy.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown BillingStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, billingstrategy.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingStrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingstrategy.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingStrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, billingstrategy.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingStrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case billingstrategy.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingStrategyMutation) ClearEdge(name string) error {
	switch name {
	case billingstrategy.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown BillingStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingStrategyMutation) ResetEdge(name string) error {
	switch name {
	case billingstrategy.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown BillingStrategy edge %s", name)
}

// CarMutation represents an operation that mutates the Car nodes in the graph.
type CarMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	delete_time                   *time.Time
	operation_mode                *int
	addoperation_mode             *int
	car_name                      *string
	device_id                     *string
	images                        *[]int
	appendimages                  []int
	license_plate                 *string
	passengers                    *int
	addpassengers                 *int
	reserved_seats                *int
	addreserved_seats             *int
	produce_time                  *time.Time
	power_threshold               *int
	addpower_threshold            *int
	activate_code                 *string
	state                         *int
	addstate                      *int
	use_state                     *int
	adduse_state                  *int
	driving_state                 *int
	adddriving_state              *int
	emergency_state               *int
	addemergency_state            *int
	use_order_id                  *int
	adduse_order_id               *int
	dispatch_task_id              *int
	adddispatch_task_id           *int
	use_flight_id                 *int
	adduse_flight_id              *int
	bind_order_count              *int
	addbind_order_count           *int
	total_order_mileage           *int
	addtotal_order_mileage        *int
	total_order_time              *int
	addtotal_order_time           *int
	total_order_count             *int
	addtotal_order_count          *int
	total_order_amount            *int
	addtotal_order_amount         *int
	power_remaining               *int
	addpower_remaining            *int
	error_count                   *int
	adderror_count                *int
	error_message                 *string
	is_deleted                    *int
	addis_deleted                 *int
	is_commercial_car             *int
	addis_commercial_car          *int
	is_driving_state_valid        *int
	addis_driving_state_valid     *int
	map_version                   *string
	next_map_version              *string
	next_map_version_state        *string
	next_map_version_process      *int
	addnext_map_version_process   *int
	gr_auto_version               *string
	gr_ui_version                 *string
	carproxy_id                   *string
	extend_yokee_id               *int
	addextend_yokee_id            *int
	alive_time                    *time.Time
	register_time                 *time.Time
	driving_state_time            *time.Time
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	cars_models                   *int
	clearedcars_models            bool
	car_operate_logs              map[int]struct{}
	removedcar_operate_logs       map[int]struct{}
	clearedcar_operate_logs       bool
	orders                        map[int]struct{}
	removedorders                 map[int]struct{}
	clearedorders                 bool
	stats_hourly_car              map[int]struct{}
	removedstats_hourly_car       map[int]struct{}
	clearedstats_hourly_car       bool
	sche_task                     map[int]struct{}
	removedsche_task              map[int]struct{}
	clearedsche_task              bool
	config_files                  map[int]struct{}
	removedconfig_files           map[int]struct{}
	clearedconfig_files           bool
	car_configs                   map[int]struct{}
	removedcar_configs            map[int]struct{}
	clearedcar_configs            bool
	done                          bool
	oldValue                      func(context.Context) (*Car, error)
	predicates                    []predicate.Car
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows management of the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for the Car entity.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the ID field of the mutation.
func withCarID(id int) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Car entities.
func (m *CarMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Car.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *CarMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CarMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CarMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[car.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CarMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[car.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CarMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, car.FieldDeleteTime)
}

// SetOperationMode sets the "operation_mode" field.
func (m *CarMutation) SetOperationMode(i int) {
	m.operation_mode = &i
	m.addoperation_mode = nil
}

// OperationMode returns the value of the "operation_mode" field in the mutation.
func (m *CarMutation) OperationMode() (r int, exists bool) {
	v := m.operation_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationMode returns the old "operation_mode" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldOperationMode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationMode: %w", err)
	}
	return oldValue.OperationMode, nil
}

// AddOperationMode adds i to the "operation_mode" field.
func (m *CarMutation) AddOperationMode(i int) {
	if m.addoperation_mode != nil {
		*m.addoperation_mode += i
	} else {
		m.addoperation_mode = &i
	}
}

// AddedOperationMode returns the value that was added to the "operation_mode" field in this mutation.
func (m *CarMutation) AddedOperationMode() (r int, exists bool) {
	v := m.addoperation_mode
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationMode resets all changes to the "operation_mode" field.
func (m *CarMutation) ResetOperationMode() {
	m.operation_mode = nil
	m.addoperation_mode = nil
}

// SetCarName sets the "car_name" field.
func (m *CarMutation) SetCarName(s string) {
	m.car_name = &s
}

// CarName returns the value of the "car_name" field in the mutation.
func (m *CarMutation) CarName() (r string, exists bool) {
	v := m.car_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCarName returns the old "car_name" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldCarName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarName: %w", err)
	}
	return oldValue.CarName, nil
}

// ResetCarName resets all changes to the "car_name" field.
func (m *CarMutation) ResetCarName() {
	m.car_name = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CarMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CarMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CarMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetModelID sets the "model_id" field.
func (m *CarMutation) SetModelID(i int) {
	m.cars_models = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CarMutation) ModelID() (r int, exists bool) {
	v := m.cars_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CarMutation) ResetModelID() {
	m.cars_models = nil
}

// SetImages sets the "images" field.
func (m *CarMutation) SetImages(i []int) {
	m.images = &i
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *CarMutation) Images() (r []int, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldImages(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds i to the "images" field.
func (m *CarMutation) AppendImages(i []int) {
	m.appendimages = append(m.appendimages, i...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *CarMutation) AppendedImages() ([]int, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ResetImages resets all changes to the "images" field.
func (m *CarMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
}

// SetLicensePlate sets the "license_plate" field.
func (m *CarMutation) SetLicensePlate(s string) {
	m.license_plate = &s
}

// LicensePlate returns the value of the "license_plate" field in the mutation.
func (m *CarMutation) LicensePlate() (r string, exists bool) {
	v := m.license_plate
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensePlate returns the old "license_plate" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldLicensePlate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicensePlate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicensePlate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensePlate: %w", err)
	}
	return oldValue.LicensePlate, nil
}

// ResetLicensePlate resets all changes to the "license_plate" field.
func (m *CarMutation) ResetLicensePlate() {
	m.license_plate = nil
}

// SetPassengers sets the "passengers" field.
func (m *CarMutation) SetPassengers(i int) {
	m.passengers = &i
	m.addpassengers = nil
}

// Passengers returns the value of the "passengers" field in the mutation.
func (m *CarMutation) Passengers() (r int, exists bool) {
	v := m.passengers
	if v == nil {
		return
	}
	return *v, true
}

// OldPassengers returns the old "passengers" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldPassengers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassengers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassengers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassengers: %w", err)
	}
	return oldValue.Passengers, nil
}

// AddPassengers adds i to the "passengers" field.
func (m *CarMutation) AddPassengers(i int) {
	if m.addpassengers != nil {
		*m.addpassengers += i
	} else {
		m.addpassengers = &i
	}
}

// AddedPassengers returns the value that was added to the "passengers" field in this mutation.
func (m *CarMutation) AddedPassengers() (r int, exists bool) {
	v := m.addpassengers
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassengers resets all changes to the "passengers" field.
func (m *CarMutation) ResetPassengers() {
	m.passengers = nil
	m.addpassengers = nil
}

// SetReservedSeats sets the "reserved_seats" field.
func (m *CarMutation) SetReservedSeats(i int) {
	m.reserved_seats = &i
	m.addreserved_seats = nil
}

// ReservedSeats returns the value of the "reserved_seats" field in the mutation.
func (m *CarMutation) ReservedSeats() (r int, exists bool) {
	v := m.reserved_seats
	if v == nil {
		return
	}
	return *v, true
}

// OldReservedSeats returns the old "reserved_seats" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldReservedSeats(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservedSeats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservedSeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservedSeats: %w", err)
	}
	return oldValue.ReservedSeats, nil
}

// AddReservedSeats adds i to the "reserved_seats" field.
func (m *CarMutation) AddReservedSeats(i int) {
	if m.addreserved_seats != nil {
		*m.addreserved_seats += i
	} else {
		m.addreserved_seats = &i
	}
}

// AddedReservedSeats returns the value that was added to the "reserved_seats" field in this mutation.
func (m *CarMutation) AddedReservedSeats() (r int, exists bool) {
	v := m.addreserved_seats
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservedSeats resets all changes to the "reserved_seats" field.
func (m *CarMutation) ResetReservedSeats() {
	m.reserved_seats = nil
	m.addreserved_seats = nil
}

// SetProduceTime sets the "produce_time" field.
func (m *CarMutation) SetProduceTime(t time.Time) {
	m.produce_time = &t
}

// ProduceTime returns the value of the "produce_time" field in the mutation.
func (m *CarMutation) ProduceTime() (r time.Time, exists bool) {
	v := m.produce_time
	if v == nil {
		return
	}
	return *v, true
}

// OldProduceTime returns the old "produce_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldProduceTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProduceTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProduceTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProduceTime: %w", err)
	}
	return oldValue.ProduceTime, nil
}

// ResetProduceTime resets all changes to the "produce_time" field.
func (m *CarMutation) ResetProduceTime() {
	m.produce_time = nil
}

// SetPowerThreshold sets the "power_threshold" field.
func (m *CarMutation) SetPowerThreshold(i int) {
	m.power_threshold = &i
	m.addpower_threshold = nil
}

// PowerThreshold returns the value of the "power_threshold" field in the mutation.
func (m *CarMutation) PowerThreshold() (r int, exists bool) {
	v := m.power_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerThreshold returns the old "power_threshold" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldPowerThreshold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerThreshold: %w", err)
	}
	return oldValue.PowerThreshold, nil
}

// AddPowerThreshold adds i to the "power_threshold" field.
func (m *CarMutation) AddPowerThreshold(i int) {
	if m.addpower_threshold != nil {
		*m.addpower_threshold += i
	} else {
		m.addpower_threshold = &i
	}
}

// AddedPowerThreshold returns the value that was added to the "power_threshold" field in this mutation.
func (m *CarMutation) AddedPowerThreshold() (r int, exists bool) {
	v := m.addpower_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetPowerThreshold resets all changes to the "power_threshold" field.
func (m *CarMutation) ResetPowerThreshold() {
	m.power_threshold = nil
	m.addpower_threshold = nil
}

// SetActivateCode sets the "activate_code" field.
func (m *CarMutation) SetActivateCode(s string) {
	m.activate_code = &s
}

// ActivateCode returns the value of the "activate_code" field in the mutation.
func (m *CarMutation) ActivateCode() (r string, exists bool) {
	v := m.activate_code
	if v == nil {
		return
	}
	return *v, true
}

// OldActivateCode returns the old "activate_code" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldActivateCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivateCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivateCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivateCode: %w", err)
	}
	return oldValue.ActivateCode, nil
}

// ResetActivateCode resets all changes to the "activate_code" field.
func (m *CarMutation) ResetActivateCode() {
	m.activate_code = nil
}

// SetState sets the "state" field.
func (m *CarMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CarMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CarMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CarMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CarMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetUseState sets the "use_state" field.
func (m *CarMutation) SetUseState(i int) {
	m.use_state = &i
	m.adduse_state = nil
}

// UseState returns the value of the "use_state" field in the mutation.
func (m *CarMutation) UseState() (r int, exists bool) {
	v := m.use_state
	if v == nil {
		return
	}
	return *v, true
}

// OldUseState returns the old "use_state" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUseState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseState: %w", err)
	}
	return oldValue.UseState, nil
}

// AddUseState adds i to the "use_state" field.
func (m *CarMutation) AddUseState(i int) {
	if m.adduse_state != nil {
		*m.adduse_state += i
	} else {
		m.adduse_state = &i
	}
}

// AddedUseState returns the value that was added to the "use_state" field in this mutation.
func (m *CarMutation) AddedUseState() (r int, exists bool) {
	v := m.adduse_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseState resets all changes to the "use_state" field.
func (m *CarMutation) ResetUseState() {
	m.use_state = nil
	m.adduse_state = nil
}

// SetDrivingState sets the "driving_state" field.
func (m *CarMutation) SetDrivingState(i int) {
	m.driving_state = &i
	m.adddriving_state = nil
}

// DrivingState returns the value of the "driving_state" field in the mutation.
func (m *CarMutation) DrivingState() (r int, exists bool) {
	v := m.driving_state
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingState returns the old "driving_state" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldDrivingState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingState: %w", err)
	}
	return oldValue.DrivingState, nil
}

// AddDrivingState adds i to the "driving_state" field.
func (m *CarMutation) AddDrivingState(i int) {
	if m.adddriving_state != nil {
		*m.adddriving_state += i
	} else {
		m.adddriving_state = &i
	}
}

// AddedDrivingState returns the value that was added to the "driving_state" field in this mutation.
func (m *CarMutation) AddedDrivingState() (r int, exists bool) {
	v := m.adddriving_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetDrivingState resets all changes to the "driving_state" field.
func (m *CarMutation) ResetDrivingState() {
	m.driving_state = nil
	m.adddriving_state = nil
}

// SetEmergencyState sets the "emergency_state" field.
func (m *CarMutation) SetEmergencyState(i int) {
	m.emergency_state = &i
	m.addemergency_state = nil
}

// EmergencyState returns the value of the "emergency_state" field in the mutation.
func (m *CarMutation) EmergencyState() (r int, exists bool) {
	v := m.emergency_state
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyState returns the old "emergency_state" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldEmergencyState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyState: %w", err)
	}
	return oldValue.EmergencyState, nil
}

// AddEmergencyState adds i to the "emergency_state" field.
func (m *CarMutation) AddEmergencyState(i int) {
	if m.addemergency_state != nil {
		*m.addemergency_state += i
	} else {
		m.addemergency_state = &i
	}
}

// AddedEmergencyState returns the value that was added to the "emergency_state" field in this mutation.
func (m *CarMutation) AddedEmergencyState() (r int, exists bool) {
	v := m.addemergency_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmergencyState resets all changes to the "emergency_state" field.
func (m *CarMutation) ResetEmergencyState() {
	m.emergency_state = nil
	m.addemergency_state = nil
}

// SetUseOrderID sets the "use_order_id" field.
func (m *CarMutation) SetUseOrderID(i int) {
	m.use_order_id = &i
	m.adduse_order_id = nil
}

// UseOrderID returns the value of the "use_order_id" field in the mutation.
func (m *CarMutation) UseOrderID() (r int, exists bool) {
	v := m.use_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUseOrderID returns the old "use_order_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUseOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseOrderID: %w", err)
	}
	return oldValue.UseOrderID, nil
}

// AddUseOrderID adds i to the "use_order_id" field.
func (m *CarMutation) AddUseOrderID(i int) {
	if m.adduse_order_id != nil {
		*m.adduse_order_id += i
	} else {
		m.adduse_order_id = &i
	}
}

// AddedUseOrderID returns the value that was added to the "use_order_id" field in this mutation.
func (m *CarMutation) AddedUseOrderID() (r int, exists bool) {
	v := m.adduse_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseOrderID resets all changes to the "use_order_id" field.
func (m *CarMutation) ResetUseOrderID() {
	m.use_order_id = nil
	m.adduse_order_id = nil
}

// SetDispatchTaskID sets the "dispatch_task_id" field.
func (m *CarMutation) SetDispatchTaskID(i int) {
	m.dispatch_task_id = &i
	m.adddispatch_task_id = nil
}

// DispatchTaskID returns the value of the "dispatch_task_id" field in the mutation.
func (m *CarMutation) DispatchTaskID() (r int, exists bool) {
	v := m.dispatch_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDispatchTaskID returns the old "dispatch_task_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldDispatchTaskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDispatchTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDispatchTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDispatchTaskID: %w", err)
	}
	return oldValue.DispatchTaskID, nil
}

// AddDispatchTaskID adds i to the "dispatch_task_id" field.
func (m *CarMutation) AddDispatchTaskID(i int) {
	if m.adddispatch_task_id != nil {
		*m.adddispatch_task_id += i
	} else {
		m.adddispatch_task_id = &i
	}
}

// AddedDispatchTaskID returns the value that was added to the "dispatch_task_id" field in this mutation.
func (m *CarMutation) AddedDispatchTaskID() (r int, exists bool) {
	v := m.adddispatch_task_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDispatchTaskID resets all changes to the "dispatch_task_id" field.
func (m *CarMutation) ResetDispatchTaskID() {
	m.dispatch_task_id = nil
	m.adddispatch_task_id = nil
}

// SetUseFlightID sets the "use_flight_id" field.
func (m *CarMutation) SetUseFlightID(i int) {
	m.use_flight_id = &i
	m.adduse_flight_id = nil
}

// UseFlightID returns the value of the "use_flight_id" field in the mutation.
func (m *CarMutation) UseFlightID() (r int, exists bool) {
	v := m.use_flight_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUseFlightID returns the old "use_flight_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUseFlightID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseFlightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseFlightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseFlightID: %w", err)
	}
	return oldValue.UseFlightID, nil
}

// AddUseFlightID adds i to the "use_flight_id" field.
func (m *CarMutation) AddUseFlightID(i int) {
	if m.adduse_flight_id != nil {
		*m.adduse_flight_id += i
	} else {
		m.adduse_flight_id = &i
	}
}

// AddedUseFlightID returns the value that was added to the "use_flight_id" field in this mutation.
func (m *CarMutation) AddedUseFlightID() (r int, exists bool) {
	v := m.adduse_flight_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseFlightID resets all changes to the "use_flight_id" field.
func (m *CarMutation) ResetUseFlightID() {
	m.use_flight_id = nil
	m.adduse_flight_id = nil
}

// SetBindOrderCount sets the "bind_order_count" field.
func (m *CarMutation) SetBindOrderCount(i int) {
	m.bind_order_count = &i
	m.addbind_order_count = nil
}

// BindOrderCount returns the value of the "bind_order_count" field in the mutation.
func (m *CarMutation) BindOrderCount() (r int, exists bool) {
	v := m.bind_order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBindOrderCount returns the old "bind_order_count" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldBindOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindOrderCount: %w", err)
	}
	return oldValue.BindOrderCount, nil
}

// AddBindOrderCount adds i to the "bind_order_count" field.
func (m *CarMutation) AddBindOrderCount(i int) {
	if m.addbind_order_count != nil {
		*m.addbind_order_count += i
	} else {
		m.addbind_order_count = &i
	}
}

// AddedBindOrderCount returns the value that was added to the "bind_order_count" field in this mutation.
func (m *CarMutation) AddedBindOrderCount() (r int, exists bool) {
	v := m.addbind_order_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBindOrderCount resets all changes to the "bind_order_count" field.
func (m *CarMutation) ResetBindOrderCount() {
	m.bind_order_count = nil
	m.addbind_order_count = nil
}

// SetTotalOrderMileage sets the "total_order_mileage" field.
func (m *CarMutation) SetTotalOrderMileage(i int) {
	m.total_order_mileage = &i
	m.addtotal_order_mileage = nil
}

// TotalOrderMileage returns the value of the "total_order_mileage" field in the mutation.
func (m *CarMutation) TotalOrderMileage() (r int, exists bool) {
	v := m.total_order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOrderMileage returns the old "total_order_mileage" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTotalOrderMileage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalOrderMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalOrderMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOrderMileage: %w", err)
	}
	return oldValue.TotalOrderMileage, nil
}

// AddTotalOrderMileage adds i to the "total_order_mileage" field.
func (m *CarMutation) AddTotalOrderMileage(i int) {
	if m.addtotal_order_mileage != nil {
		*m.addtotal_order_mileage += i
	} else {
		m.addtotal_order_mileage = &i
	}
}

// AddedTotalOrderMileage returns the value that was added to the "total_order_mileage" field in this mutation.
func (m *CarMutation) AddedTotalOrderMileage() (r int, exists bool) {
	v := m.addtotal_order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOrderMileage resets all changes to the "total_order_mileage" field.
func (m *CarMutation) ResetTotalOrderMileage() {
	m.total_order_mileage = nil
	m.addtotal_order_mileage = nil
}

// SetTotalOrderTime sets the "total_order_time" field.
func (m *CarMutation) SetTotalOrderTime(i int) {
	m.total_order_time = &i
	m.addtotal_order_time = nil
}

// TotalOrderTime returns the value of the "total_order_time" field in the mutation.
func (m *CarMutation) TotalOrderTime() (r int, exists bool) {
	v := m.total_order_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOrderTime returns the old "total_order_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTotalOrderTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalOrderTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalOrderTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOrderTime: %w", err)
	}
	return oldValue.TotalOrderTime, nil
}

// AddTotalOrderTime adds i to the "total_order_time" field.
func (m *CarMutation) AddTotalOrderTime(i int) {
	if m.addtotal_order_time != nil {
		*m.addtotal_order_time += i
	} else {
		m.addtotal_order_time = &i
	}
}

// AddedTotalOrderTime returns the value that was added to the "total_order_time" field in this mutation.
func (m *CarMutation) AddedTotalOrderTime() (r int, exists bool) {
	v := m.addtotal_order_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOrderTime resets all changes to the "total_order_time" field.
func (m *CarMutation) ResetTotalOrderTime() {
	m.total_order_time = nil
	m.addtotal_order_time = nil
}

// SetTotalOrderCount sets the "total_order_count" field.
func (m *CarMutation) SetTotalOrderCount(i int) {
	m.total_order_count = &i
	m.addtotal_order_count = nil
}

// TotalOrderCount returns the value of the "total_order_count" field in the mutation.
func (m *CarMutation) TotalOrderCount() (r int, exists bool) {
	v := m.total_order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOrderCount returns the old "total_order_count" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTotalOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOrderCount: %w", err)
	}
	return oldValue.TotalOrderCount, nil
}

// AddTotalOrderCount adds i to the "total_order_count" field.
func (m *CarMutation) AddTotalOrderCount(i int) {
	if m.addtotal_order_count != nil {
		*m.addtotal_order_count += i
	} else {
		m.addtotal_order_count = &i
	}
}

// AddedTotalOrderCount returns the value that was added to the "total_order_count" field in this mutation.
func (m *CarMutation) AddedTotalOrderCount() (r int, exists bool) {
	v := m.addtotal_order_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOrderCount resets all changes to the "total_order_count" field.
func (m *CarMutation) ResetTotalOrderCount() {
	m.total_order_count = nil
	m.addtotal_order_count = nil
}

// SetTotalOrderAmount sets the "total_order_amount" field.
func (m *CarMutation) SetTotalOrderAmount(i int) {
	m.total_order_amount = &i
	m.addtotal_order_amount = nil
}

// TotalOrderAmount returns the value of the "total_order_amount" field in the mutation.
func (m *CarMutation) TotalOrderAmount() (r int, exists bool) {
	v := m.total_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalOrderAmount returns the old "total_order_amount" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTotalOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalOrderAmount: %w", err)
	}
	return oldValue.TotalOrderAmount, nil
}

// AddTotalOrderAmount adds i to the "total_order_amount" field.
func (m *CarMutation) AddTotalOrderAmount(i int) {
	if m.addtotal_order_amount != nil {
		*m.addtotal_order_amount += i
	} else {
		m.addtotal_order_amount = &i
	}
}

// AddedTotalOrderAmount returns the value that was added to the "total_order_amount" field in this mutation.
func (m *CarMutation) AddedTotalOrderAmount() (r int, exists bool) {
	v := m.addtotal_order_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalOrderAmount resets all changes to the "total_order_amount" field.
func (m *CarMutation) ResetTotalOrderAmount() {
	m.total_order_amount = nil
	m.addtotal_order_amount = nil
}

// SetPowerRemaining sets the "power_remaining" field.
func (m *CarMutation) SetPowerRemaining(i int) {
	m.power_remaining = &i
	m.addpower_remaining = nil
}

// PowerRemaining returns the value of the "power_remaining" field in the mutation.
func (m *CarMutation) PowerRemaining() (r int, exists bool) {
	v := m.power_remaining
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerRemaining returns the old "power_remaining" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldPowerRemaining(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerRemaining is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerRemaining requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerRemaining: %w", err)
	}
	return oldValue.PowerRemaining, nil
}

// AddPowerRemaining adds i to the "power_remaining" field.
func (m *CarMutation) AddPowerRemaining(i int) {
	if m.addpower_remaining != nil {
		*m.addpower_remaining += i
	} else {
		m.addpower_remaining = &i
	}
}

// AddedPowerRemaining returns the value that was added to the "power_remaining" field in this mutation.
func (m *CarMutation) AddedPowerRemaining() (r int, exists bool) {
	v := m.addpower_remaining
	if v == nil {
		return
	}
	return *v, true
}

// ResetPowerRemaining resets all changes to the "power_remaining" field.
func (m *CarMutation) ResetPowerRemaining() {
	m.power_remaining = nil
	m.addpower_remaining = nil
}

// SetErrorCount sets the "error_count" field.
func (m *CarMutation) SetErrorCount(i int) {
	m.error_count = &i
	m.adderror_count = nil
}

// ErrorCount returns the value of the "error_count" field in the mutation.
func (m *CarMutation) ErrorCount() (r int, exists bool) {
	v := m.error_count
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCount returns the old "error_count" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldErrorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCount: %w", err)
	}
	return oldValue.ErrorCount, nil
}

// AddErrorCount adds i to the "error_count" field.
func (m *CarMutation) AddErrorCount(i int) {
	if m.adderror_count != nil {
		*m.adderror_count += i
	} else {
		m.adderror_count = &i
	}
}

// AddedErrorCount returns the value that was added to the "error_count" field in this mutation.
func (m *CarMutation) AddedErrorCount() (r int, exists bool) {
	v := m.adderror_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrorCount resets all changes to the "error_count" field.
func (m *CarMutation) ResetErrorCount() {
	m.error_count = nil
	m.adderror_count = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *CarMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *CarMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *CarMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CarMutation) SetIsDeleted(i int) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CarMutation) IsDeleted() (r int, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldIsDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *CarMutation) AddIsDeleted(i int) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *CarMutation) AddedIsDeleted() (r int, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CarMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetIsCommercialCar sets the "is_commercial_car" field.
func (m *CarMutation) SetIsCommercialCar(i int) {
	m.is_commercial_car = &i
	m.addis_commercial_car = nil
}

// IsCommercialCar returns the value of the "is_commercial_car" field in the mutation.
func (m *CarMutation) IsCommercialCar() (r int, exists bool) {
	v := m.is_commercial_car
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCommercialCar returns the old "is_commercial_car" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldIsCommercialCar(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCommercialCar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCommercialCar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCommercialCar: %w", err)
	}
	return oldValue.IsCommercialCar, nil
}

// AddIsCommercialCar adds i to the "is_commercial_car" field.
func (m *CarMutation) AddIsCommercialCar(i int) {
	if m.addis_commercial_car != nil {
		*m.addis_commercial_car += i
	} else {
		m.addis_commercial_car = &i
	}
}

// AddedIsCommercialCar returns the value that was added to the "is_commercial_car" field in this mutation.
func (m *CarMutation) AddedIsCommercialCar() (r int, exists bool) {
	v := m.addis_commercial_car
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsCommercialCar resets all changes to the "is_commercial_car" field.
func (m *CarMutation) ResetIsCommercialCar() {
	m.is_commercial_car = nil
	m.addis_commercial_car = nil
}

// SetIsDrivingStateValid sets the "is_driving_state_valid" field.
func (m *CarMutation) SetIsDrivingStateValid(i int) {
	m.is_driving_state_valid = &i
	m.addis_driving_state_valid = nil
}

// IsDrivingStateValid returns the value of the "is_driving_state_valid" field in the mutation.
func (m *CarMutation) IsDrivingStateValid() (r int, exists bool) {
	v := m.is_driving_state_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDrivingStateValid returns the old "is_driving_state_valid" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldIsDrivingStateValid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDrivingStateValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDrivingStateValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDrivingStateValid: %w", err)
	}
	return oldValue.IsDrivingStateValid, nil
}

// AddIsDrivingStateValid adds i to the "is_driving_state_valid" field.
func (m *CarMutation) AddIsDrivingStateValid(i int) {
	if m.addis_driving_state_valid != nil {
		*m.addis_driving_state_valid += i
	} else {
		m.addis_driving_state_valid = &i
	}
}

// AddedIsDrivingStateValid returns the value that was added to the "is_driving_state_valid" field in this mutation.
func (m *CarMutation) AddedIsDrivingStateValid() (r int, exists bool) {
	v := m.addis_driving_state_valid
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDrivingStateValid resets all changes to the "is_driving_state_valid" field.
func (m *CarMutation) ResetIsDrivingStateValid() {
	m.is_driving_state_valid = nil
	m.addis_driving_state_valid = nil
}

// SetMapVersion sets the "map_version" field.
func (m *CarMutation) SetMapVersion(s string) {
	m.map_version = &s
}

// MapVersion returns the value of the "map_version" field in the mutation.
func (m *CarMutation) MapVersion() (r string, exists bool) {
	v := m.map_version
	if v == nil {
		return
	}
	return *v, true
}

// OldMapVersion returns the old "map_version" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldMapVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapVersion: %w", err)
	}
	return oldValue.MapVersion, nil
}

// ResetMapVersion resets all changes to the "map_version" field.
func (m *CarMutation) ResetMapVersion() {
	m.map_version = nil
}

// SetNextMapVersion sets the "next_map_version" field.
func (m *CarMutation) SetNextMapVersion(s string) {
	m.next_map_version = &s
}

// NextMapVersion returns the value of the "next_map_version" field in the mutation.
func (m *CarMutation) NextMapVersion() (r string, exists bool) {
	v := m.next_map_version
	if v == nil {
		return
	}
	return *v, true
}

// OldNextMapVersion returns the old "next_map_version" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldNextMapVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextMapVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextMapVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextMapVersion: %w", err)
	}
	return oldValue.NextMapVersion, nil
}

// ResetNextMapVersion resets all changes to the "next_map_version" field.
func (m *CarMutation) ResetNextMapVersion() {
	m.next_map_version = nil
}

// SetNextMapVersionState sets the "next_map_version_state" field.
func (m *CarMutation) SetNextMapVersionState(s string) {
	m.next_map_version_state = &s
}

// NextMapVersionState returns the value of the "next_map_version_state" field in the mutation.
func (m *CarMutation) NextMapVersionState() (r string, exists bool) {
	v := m.next_map_version_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNextMapVersionState returns the old "next_map_version_state" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldNextMapVersionState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextMapVersionState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextMapVersionState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextMapVersionState: %w", err)
	}
	return oldValue.NextMapVersionState, nil
}

// ResetNextMapVersionState resets all changes to the "next_map_version_state" field.
func (m *CarMutation) ResetNextMapVersionState() {
	m.next_map_version_state = nil
}

// SetNextMapVersionProcess sets the "next_map_version_process" field.
func (m *CarMutation) SetNextMapVersionProcess(i int) {
	m.next_map_version_process = &i
	m.addnext_map_version_process = nil
}

// NextMapVersionProcess returns the value of the "next_map_version_process" field in the mutation.
func (m *CarMutation) NextMapVersionProcess() (r int, exists bool) {
	v := m.next_map_version_process
	if v == nil {
		return
	}
	return *v, true
}

// OldNextMapVersionProcess returns the old "next_map_version_process" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldNextMapVersionProcess(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextMapVersionProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextMapVersionProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextMapVersionProcess: %w", err)
	}
	return oldValue.NextMapVersionProcess, nil
}

// AddNextMapVersionProcess adds i to the "next_map_version_process" field.
func (m *CarMutation) AddNextMapVersionProcess(i int) {
	if m.addnext_map_version_process != nil {
		*m.addnext_map_version_process += i
	} else {
		m.addnext_map_version_process = &i
	}
}

// AddedNextMapVersionProcess returns the value that was added to the "next_map_version_process" field in this mutation.
func (m *CarMutation) AddedNextMapVersionProcess() (r int, exists bool) {
	v := m.addnext_map_version_process
	if v == nil {
		return
	}
	return *v, true
}

// ResetNextMapVersionProcess resets all changes to the "next_map_version_process" field.
func (m *CarMutation) ResetNextMapVersionProcess() {
	m.next_map_version_process = nil
	m.addnext_map_version_process = nil
}

// SetGrAutoVersion sets the "gr_auto_version" field.
func (m *CarMutation) SetGrAutoVersion(s string) {
	m.gr_auto_version = &s
}

// GrAutoVersion returns the value of the "gr_auto_version" field in the mutation.
func (m *CarMutation) GrAutoVersion() (r string, exists bool) {
	v := m.gr_auto_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGrAutoVersion returns the old "gr_auto_version" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldGrAutoVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrAutoVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrAutoVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrAutoVersion: %w", err)
	}
	return oldValue.GrAutoVersion, nil
}

// ResetGrAutoVersion resets all changes to the "gr_auto_version" field.
func (m *CarMutation) ResetGrAutoVersion() {
	m.gr_auto_version = nil
}

// SetGrUIVersion sets the "gr_ui_version" field.
func (m *CarMutation) SetGrUIVersion(s string) {
	m.gr_ui_version = &s
}

// GrUIVersion returns the value of the "gr_ui_version" field in the mutation.
func (m *CarMutation) GrUIVersion() (r string, exists bool) {
	v := m.gr_ui_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGrUIVersion returns the old "gr_ui_version" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldGrUIVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrUIVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrUIVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrUIVersion: %w", err)
	}
	return oldValue.GrUIVersion, nil
}

// ResetGrUIVersion resets all changes to the "gr_ui_version" field.
func (m *CarMutation) ResetGrUIVersion() {
	m.gr_ui_version = nil
}

// SetCarproxyID sets the "carproxy_id" field.
func (m *CarMutation) SetCarproxyID(s string) {
	m.carproxy_id = &s
}

// CarproxyID returns the value of the "carproxy_id" field in the mutation.
func (m *CarMutation) CarproxyID() (r string, exists bool) {
	v := m.carproxy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarproxyID returns the old "carproxy_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldCarproxyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarproxyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarproxyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarproxyID: %w", err)
	}
	return oldValue.CarproxyID, nil
}

// ResetCarproxyID resets all changes to the "carproxy_id" field.
func (m *CarMutation) ResetCarproxyID() {
	m.carproxy_id = nil
}

// SetExtendYokeeID sets the "extend_yokee_id" field.
func (m *CarMutation) SetExtendYokeeID(i int) {
	m.extend_yokee_id = &i
	m.addextend_yokee_id = nil
}

// ExtendYokeeID returns the value of the "extend_yokee_id" field in the mutation.
func (m *CarMutation) ExtendYokeeID() (r int, exists bool) {
	v := m.extend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendYokeeID returns the old "extend_yokee_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldExtendYokeeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendYokeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendYokeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendYokeeID: %w", err)
	}
	return oldValue.ExtendYokeeID, nil
}

// AddExtendYokeeID adds i to the "extend_yokee_id" field.
func (m *CarMutation) AddExtendYokeeID(i int) {
	if m.addextend_yokee_id != nil {
		*m.addextend_yokee_id += i
	} else {
		m.addextend_yokee_id = &i
	}
}

// AddedExtendYokeeID returns the value that was added to the "extend_yokee_id" field in this mutation.
func (m *CarMutation) AddedExtendYokeeID() (r int, exists bool) {
	v := m.addextend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtendYokeeID clears the value of the "extend_yokee_id" field.
func (m *CarMutation) ClearExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	m.clearedFields[car.FieldExtendYokeeID] = struct{}{}
}

// ExtendYokeeIDCleared returns if the "extend_yokee_id" field was cleared in this mutation.
func (m *CarMutation) ExtendYokeeIDCleared() bool {
	_, ok := m.clearedFields[car.FieldExtendYokeeID]
	return ok
}

// ResetExtendYokeeID resets all changes to the "extend_yokee_id" field.
func (m *CarMutation) ResetExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	delete(m.clearedFields, car.FieldExtendYokeeID)
}

// SetAliveTime sets the "alive_time" field.
func (m *CarMutation) SetAliveTime(t time.Time) {
	m.alive_time = &t
}

// AliveTime returns the value of the "alive_time" field in the mutation.
func (m *CarMutation) AliveTime() (r time.Time, exists bool) {
	v := m.alive_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAliveTime returns the old "alive_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldAliveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliveTime: %w", err)
	}
	return oldValue.AliveTime, nil
}

// ClearAliveTime clears the value of the "alive_time" field.
func (m *CarMutation) ClearAliveTime() {
	m.alive_time = nil
	m.clearedFields[car.FieldAliveTime] = struct{}{}
}

// AliveTimeCleared returns if the "alive_time" field was cleared in this mutation.
func (m *CarMutation) AliveTimeCleared() bool {
	_, ok := m.clearedFields[car.FieldAliveTime]
	return ok
}

// ResetAliveTime resets all changes to the "alive_time" field.
func (m *CarMutation) ResetAliveTime() {
	m.alive_time = nil
	delete(m.clearedFields, car.FieldAliveTime)
}

// SetRegisterTime sets the "register_time" field.
func (m *CarMutation) SetRegisterTime(t time.Time) {
	m.register_time = &t
}

// RegisterTime returns the value of the "register_time" field in the mutation.
func (m *CarMutation) RegisterTime() (r time.Time, exists bool) {
	v := m.register_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterTime returns the old "register_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldRegisterTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterTime: %w", err)
	}
	return oldValue.RegisterTime, nil
}

// ClearRegisterTime clears the value of the "register_time" field.
func (m *CarMutation) ClearRegisterTime() {
	m.register_time = nil
	m.clearedFields[car.FieldRegisterTime] = struct{}{}
}

// RegisterTimeCleared returns if the "register_time" field was cleared in this mutation.
func (m *CarMutation) RegisterTimeCleared() bool {
	_, ok := m.clearedFields[car.FieldRegisterTime]
	return ok
}

// ResetRegisterTime resets all changes to the "register_time" field.
func (m *CarMutation) ResetRegisterTime() {
	m.register_time = nil
	delete(m.clearedFields, car.FieldRegisterTime)
}

// SetDrivingStateTime sets the "driving_state_time" field.
func (m *CarMutation) SetDrivingStateTime(t time.Time) {
	m.driving_state_time = &t
}

// DrivingStateTime returns the value of the "driving_state_time" field in the mutation.
func (m *CarMutation) DrivingStateTime() (r time.Time, exists bool) {
	v := m.driving_state_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDrivingStateTime returns the old "driving_state_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldDrivingStateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrivingStateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrivingStateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrivingStateTime: %w", err)
	}
	return oldValue.DrivingStateTime, nil
}

// ClearDrivingStateTime clears the value of the "driving_state_time" field.
func (m *CarMutation) ClearDrivingStateTime() {
	m.driving_state_time = nil
	m.clearedFields[car.FieldDrivingStateTime] = struct{}{}
}

// DrivingStateTimeCleared returns if the "driving_state_time" field was cleared in this mutation.
func (m *CarMutation) DrivingStateTimeCleared() bool {
	_, ok := m.clearedFields[car.FieldDrivingStateTime]
	return ok
}

// ResetDrivingStateTime resets all changes to the "driving_state_time" field.
func (m *CarMutation) ResetDrivingStateTime() {
	m.driving_state_time = nil
	delete(m.clearedFields, car.FieldDrivingStateTime)
}

// SetCreateTime sets the "create_time" field.
func (m *CarMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *CarMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *CarMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[car.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *CarMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *CarMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *CarMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *CarMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// SetCarsModelsID sets the "cars_models" edge to the CarsModels entity by id.
func (m *CarMutation) SetCarsModelsID(id int) {
	m.cars_models = &id
}

// ClearCarsModels clears the "cars_models" edge to the CarsModels entity.
func (m *CarMutation) ClearCarsModels() {
	m.clearedcars_models = true
	m.clearedFields[car.FieldModelID] = struct{}{}
}

// CarsModelsCleared reports if the "cars_models" edge to the CarsModels entity was cleared.
func (m *CarMutation) CarsModelsCleared() bool {
	return m.clearedcars_models
}

// CarsModelsID returns the "cars_models" edge ID in the mutation.
func (m *CarMutation) CarsModelsID() (id int, exists bool) {
	if m.cars_models != nil {
		return *m.cars_models, true
	}
	return
}

// CarsModelsIDs returns the "cars_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarsModelsID instead. It exists only for internal usage by the builders.
func (m *CarMutation) CarsModelsIDs() (ids []int) {
	if id := m.cars_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarsModels resets all changes to the "cars_models" edge.
func (m *CarMutation) ResetCarsModels() {
	m.cars_models = nil
	m.clearedcars_models = false
}

// AddCarOperateLogIDs adds the "car_operate_logs" edge to the CarsOperateLog entity by ids.
func (m *CarMutation) AddCarOperateLogIDs(ids ...int) {
	if m.car_operate_logs == nil {
		m.car_operate_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.car_operate_logs[ids[i]] = struct{}{}
	}
}

// ClearCarOperateLogs clears the "car_operate_logs" edge to the CarsOperateLog entity.
func (m *CarMutation) ClearCarOperateLogs() {
	m.clearedcar_operate_logs = true
}

// CarOperateLogsCleared reports if the "car_operate_logs" edge to the CarsOperateLog entity was cleared.
func (m *CarMutation) CarOperateLogsCleared() bool {
	return m.clearedcar_operate_logs
}

// RemoveCarOperateLogIDs removes the "car_operate_logs" edge to the CarsOperateLog entity by IDs.
func (m *CarMutation) RemoveCarOperateLogIDs(ids ...int) {
	if m.removedcar_operate_logs == nil {
		m.removedcar_operate_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.car_operate_logs, ids[i])
		m.removedcar_operate_logs[ids[i]] = struct{}{}
	}
}

// RemovedCarOperateLogs returns the removed IDs of the "car_operate_logs" edge to the CarsOperateLog entity.
func (m *CarMutation) RemovedCarOperateLogsIDs() (ids []int) {
	for id := range m.removedcar_operate_logs {
		ids = append(ids, id)
	}
	return
}

// CarOperateLogsIDs returns the "car_operate_logs" edge IDs in the mutation.
func (m *CarMutation) CarOperateLogsIDs() (ids []int) {
	for id := range m.car_operate_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCarOperateLogs resets all changes to the "car_operate_logs" edge.
func (m *CarMutation) ResetCarOperateLogs() {
	m.car_operate_logs = nil
	m.clearedcar_operate_logs = false
	m.removedcar_operate_logs = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *CarMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *CarMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *CarMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *CarMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *CarMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CarMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CarMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddStatsHourlyCarIDs adds the "stats_hourly_car" edge to the StatsHourlyCar entity by ids.
func (m *CarMutation) AddStatsHourlyCarIDs(ids ...int) {
	if m.stats_hourly_car == nil {
		m.stats_hourly_car = make(map[int]struct{})
	}
	for i := range ids {
		m.stats_hourly_car[ids[i]] = struct{}{}
	}
}

// ClearStatsHourlyCar clears the "stats_hourly_car" edge to the StatsHourlyCar entity.
func (m *CarMutation) ClearStatsHourlyCar() {
	m.clearedstats_hourly_car = true
}

// StatsHourlyCarCleared reports if the "stats_hourly_car" edge to the StatsHourlyCar entity was cleared.
func (m *CarMutation) StatsHourlyCarCleared() bool {
	return m.clearedstats_hourly_car
}

// RemoveStatsHourlyCarIDs removes the "stats_hourly_car" edge to the StatsHourlyCar entity by IDs.
func (m *CarMutation) RemoveStatsHourlyCarIDs(ids ...int) {
	if m.removedstats_hourly_car == nil {
		m.removedstats_hourly_car = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stats_hourly_car, ids[i])
		m.removedstats_hourly_car[ids[i]] = struct{}{}
	}
}

// RemovedStatsHourlyCar returns the removed IDs of the "stats_hourly_car" edge to the StatsHourlyCar entity.
func (m *CarMutation) RemovedStatsHourlyCarIDs() (ids []int) {
	for id := range m.removedstats_hourly_car {
		ids = append(ids, id)
	}
	return
}

// StatsHourlyCarIDs returns the "stats_hourly_car" edge IDs in the mutation.
func (m *CarMutation) StatsHourlyCarIDs() (ids []int) {
	for id := range m.stats_hourly_car {
		ids = append(ids, id)
	}
	return
}

// ResetStatsHourlyCar resets all changes to the "stats_hourly_car" edge.
func (m *CarMutation) ResetStatsHourlyCar() {
	m.stats_hourly_car = nil
	m.clearedstats_hourly_car = false
	m.removedstats_hourly_car = nil
}

// AddScheTaskIDs adds the "sche_task" edge to the ScheTask entity by ids.
func (m *CarMutation) AddScheTaskIDs(ids ...int) {
	if m.sche_task == nil {
		m.sche_task = make(map[int]struct{})
	}
	for i := range ids {
		m.sche_task[ids[i]] = struct{}{}
	}
}

// ClearScheTask clears the "sche_task" edge to the ScheTask entity.
func (m *CarMutation) ClearScheTask() {
	m.clearedsche_task = true
}

// ScheTaskCleared reports if the "sche_task" edge to the ScheTask entity was cleared.
func (m *CarMutation) ScheTaskCleared() bool {
	return m.clearedsche_task
}

// RemoveScheTaskIDs removes the "sche_task" edge to the ScheTask entity by IDs.
func (m *CarMutation) RemoveScheTaskIDs(ids ...int) {
	if m.removedsche_task == nil {
		m.removedsche_task = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sche_task, ids[i])
		m.removedsche_task[ids[i]] = struct{}{}
	}
}

// RemovedScheTask returns the removed IDs of the "sche_task" edge to the ScheTask entity.
func (m *CarMutation) RemovedScheTaskIDs() (ids []int) {
	for id := range m.removedsche_task {
		ids = append(ids, id)
	}
	return
}

// ScheTaskIDs returns the "sche_task" edge IDs in the mutation.
func (m *CarMutation) ScheTaskIDs() (ids []int) {
	for id := range m.sche_task {
		ids = append(ids, id)
	}
	return
}

// ResetScheTask resets all changes to the "sche_task" edge.
func (m *CarMutation) ResetScheTask() {
	m.sche_task = nil
	m.clearedsche_task = false
	m.removedsche_task = nil
}

// AddConfigFileIDs adds the "config_files" edge to the CarConfig entity by ids.
func (m *CarMutation) AddConfigFileIDs(ids ...int) {
	if m.config_files == nil {
		m.config_files = make(map[int]struct{})
	}
	for i := range ids {
		m.config_files[ids[i]] = struct{}{}
	}
}

// ClearConfigFiles clears the "config_files" edge to the CarConfig entity.
func (m *CarMutation) ClearConfigFiles() {
	m.clearedconfig_files = true
}

// ConfigFilesCleared reports if the "config_files" edge to the CarConfig entity was cleared.
func (m *CarMutation) ConfigFilesCleared() bool {
	return m.clearedconfig_files
}

// RemoveConfigFileIDs removes the "config_files" edge to the CarConfig entity by IDs.
func (m *CarMutation) RemoveConfigFileIDs(ids ...int) {
	if m.removedconfig_files == nil {
		m.removedconfig_files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.config_files, ids[i])
		m.removedconfig_files[ids[i]] = struct{}{}
	}
}

// RemovedConfigFiles returns the removed IDs of the "config_files" edge to the CarConfig entity.
func (m *CarMutation) RemovedConfigFilesIDs() (ids []int) {
	for id := range m.removedconfig_files {
		ids = append(ids, id)
	}
	return
}

// ConfigFilesIDs returns the "config_files" edge IDs in the mutation.
func (m *CarMutation) ConfigFilesIDs() (ids []int) {
	for id := range m.config_files {
		ids = append(ids, id)
	}
	return
}

// ResetConfigFiles resets all changes to the "config_files" edge.
func (m *CarMutation) ResetConfigFiles() {
	m.config_files = nil
	m.clearedconfig_files = false
	m.removedconfig_files = nil
}

// AddCarConfigIDs adds the "car_configs" edge to the CarConfigDownload entity by ids.
func (m *CarMutation) AddCarConfigIDs(ids ...int) {
	if m.car_configs == nil {
		m.car_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.car_configs[ids[i]] = struct{}{}
	}
}

// ClearCarConfigs clears the "car_configs" edge to the CarConfigDownload entity.
func (m *CarMutation) ClearCarConfigs() {
	m.clearedcar_configs = true
}

// CarConfigsCleared reports if the "car_configs" edge to the CarConfigDownload entity was cleared.
func (m *CarMutation) CarConfigsCleared() bool {
	return m.clearedcar_configs
}

// RemoveCarConfigIDs removes the "car_configs" edge to the CarConfigDownload entity by IDs.
func (m *CarMutation) RemoveCarConfigIDs(ids ...int) {
	if m.removedcar_configs == nil {
		m.removedcar_configs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.car_configs, ids[i])
		m.removedcar_configs[ids[i]] = struct{}{}
	}
}

// RemovedCarConfigs returns the removed IDs of the "car_configs" edge to the CarConfigDownload entity.
func (m *CarMutation) RemovedCarConfigsIDs() (ids []int) {
	for id := range m.removedcar_configs {
		ids = append(ids, id)
	}
	return
}

// CarConfigsIDs returns the "car_configs" edge IDs in the mutation.
func (m *CarMutation) CarConfigsIDs() (ids []int) {
	for id := range m.car_configs {
		ids = append(ids, id)
	}
	return
}

// ResetCarConfigs resets all changes to the "car_configs" edge.
func (m *CarMutation) ResetCarConfigs() {
	m.car_configs = nil
	m.clearedcar_configs = false
	m.removedcar_configs = nil
}

// Where appends a list predicates to the CarMutation builder.
func (m *CarMutation) Where(ps ...predicate.Car) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Car, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 44)
	if m.delete_time != nil {
		fields = append(fields, car.FieldDeleteTime)
	}
	if m.operation_mode != nil {
		fields = append(fields, car.FieldOperationMode)
	}
	if m.car_name != nil {
		fields = append(fields, car.FieldCarName)
	}
	if m.background_scenic_area != nil {
		fields = append(fields, car.FieldScenicAreaID)
	}
	if m.device_id != nil {
		fields = append(fields, car.FieldDeviceID)
	}
	if m.cars_models != nil {
		fields = append(fields, car.FieldModelID)
	}
	if m.images != nil {
		fields = append(fields, car.FieldImages)
	}
	if m.license_plate != nil {
		fields = append(fields, car.FieldLicensePlate)
	}
	if m.passengers != nil {
		fields = append(fields, car.FieldPassengers)
	}
	if m.reserved_seats != nil {
		fields = append(fields, car.FieldReservedSeats)
	}
	if m.produce_time != nil {
		fields = append(fields, car.FieldProduceTime)
	}
	if m.power_threshold != nil {
		fields = append(fields, car.FieldPowerThreshold)
	}
	if m.activate_code != nil {
		fields = append(fields, car.FieldActivateCode)
	}
	if m.state != nil {
		fields = append(fields, car.FieldState)
	}
	if m.use_state != nil {
		fields = append(fields, car.FieldUseState)
	}
	if m.driving_state != nil {
		fields = append(fields, car.FieldDrivingState)
	}
	if m.emergency_state != nil {
		fields = append(fields, car.FieldEmergencyState)
	}
	if m.use_order_id != nil {
		fields = append(fields, car.FieldUseOrderID)
	}
	if m.dispatch_task_id != nil {
		fields = append(fields, car.FieldDispatchTaskID)
	}
	if m.use_flight_id != nil {
		fields = append(fields, car.FieldUseFlightID)
	}
	if m.bind_order_count != nil {
		fields = append(fields, car.FieldBindOrderCount)
	}
	if m.total_order_mileage != nil {
		fields = append(fields, car.FieldTotalOrderMileage)
	}
	if m.total_order_time != nil {
		fields = append(fields, car.FieldTotalOrderTime)
	}
	if m.total_order_count != nil {
		fields = append(fields, car.FieldTotalOrderCount)
	}
	if m.total_order_amount != nil {
		fields = append(fields, car.FieldTotalOrderAmount)
	}
	if m.power_remaining != nil {
		fields = append(fields, car.FieldPowerRemaining)
	}
	if m.error_count != nil {
		fields = append(fields, car.FieldErrorCount)
	}
	if m.error_message != nil {
		fields = append(fields, car.FieldErrorMessage)
	}
	if m.is_deleted != nil {
		fields = append(fields, car.FieldIsDeleted)
	}
	if m.is_commercial_car != nil {
		fields = append(fields, car.FieldIsCommercialCar)
	}
	if m.is_driving_state_valid != nil {
		fields = append(fields, car.FieldIsDrivingStateValid)
	}
	if m.map_version != nil {
		fields = append(fields, car.FieldMapVersion)
	}
	if m.next_map_version != nil {
		fields = append(fields, car.FieldNextMapVersion)
	}
	if m.next_map_version_state != nil {
		fields = append(fields, car.FieldNextMapVersionState)
	}
	if m.next_map_version_process != nil {
		fields = append(fields, car.FieldNextMapVersionProcess)
	}
	if m.gr_auto_version != nil {
		fields = append(fields, car.FieldGrAutoVersion)
	}
	if m.gr_ui_version != nil {
		fields = append(fields, car.FieldGrUIVersion)
	}
	if m.carproxy_id != nil {
		fields = append(fields, car.FieldCarproxyID)
	}
	if m.extend_yokee_id != nil {
		fields = append(fields, car.FieldExtendYokeeID)
	}
	if m.alive_time != nil {
		fields = append(fields, car.FieldAliveTime)
	}
	if m.register_time != nil {
		fields = append(fields, car.FieldRegisterTime)
	}
	if m.driving_state_time != nil {
		fields = append(fields, car.FieldDrivingStateTime)
	}
	if m.create_time != nil {
		fields = append(fields, car.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, car.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case car.FieldDeleteTime:
		return m.DeleteTime()
	case car.FieldOperationMode:
		return m.OperationMode()
	case car.FieldCarName:
		return m.CarName()
	case car.FieldScenicAreaID:
		return m.ScenicAreaID()
	case car.FieldDeviceID:
		return m.DeviceID()
	case car.FieldModelID:
		return m.ModelID()
	case car.FieldImages:
		return m.Images()
	case car.FieldLicensePlate:
		return m.LicensePlate()
	case car.FieldPassengers:
		return m.Passengers()
	case car.FieldReservedSeats:
		return m.ReservedSeats()
	case car.FieldProduceTime:
		return m.ProduceTime()
	case car.FieldPowerThreshold:
		return m.PowerThreshold()
	case car.FieldActivateCode:
		return m.ActivateCode()
	case car.FieldState:
		return m.State()
	case car.FieldUseState:
		return m.UseState()
	case car.FieldDrivingState:
		return m.DrivingState()
	case car.FieldEmergencyState:
		return m.EmergencyState()
	case car.FieldUseOrderID:
		return m.UseOrderID()
	case car.FieldDispatchTaskID:
		return m.DispatchTaskID()
	case car.FieldUseFlightID:
		return m.UseFlightID()
	case car.FieldBindOrderCount:
		return m.BindOrderCount()
	case car.FieldTotalOrderMileage:
		return m.TotalOrderMileage()
	case car.FieldTotalOrderTime:
		return m.TotalOrderTime()
	case car.FieldTotalOrderCount:
		return m.TotalOrderCount()
	case car.FieldTotalOrderAmount:
		return m.TotalOrderAmount()
	case car.FieldPowerRemaining:
		return m.PowerRemaining()
	case car.FieldErrorCount:
		return m.ErrorCount()
	case car.FieldErrorMessage:
		return m.ErrorMessage()
	case car.FieldIsDeleted:
		return m.IsDeleted()
	case car.FieldIsCommercialCar:
		return m.IsCommercialCar()
	case car.FieldIsDrivingStateValid:
		return m.IsDrivingStateValid()
	case car.FieldMapVersion:
		return m.MapVersion()
	case car.FieldNextMapVersion:
		return m.NextMapVersion()
	case car.FieldNextMapVersionState:
		return m.NextMapVersionState()
	case car.FieldNextMapVersionProcess:
		return m.NextMapVersionProcess()
	case car.FieldGrAutoVersion:
		return m.GrAutoVersion()
	case car.FieldGrUIVersion:
		return m.GrUIVersion()
	case car.FieldCarproxyID:
		return m.CarproxyID()
	case car.FieldExtendYokeeID:
		return m.ExtendYokeeID()
	case car.FieldAliveTime:
		return m.AliveTime()
	case car.FieldRegisterTime:
		return m.RegisterTime()
	case car.FieldDrivingStateTime:
		return m.DrivingStateTime()
	case car.FieldCreateTime:
		return m.CreateTime()
	case car.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case car.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case car.FieldOperationMode:
		return m.OldOperationMode(ctx)
	case car.FieldCarName:
		return m.OldCarName(ctx)
	case car.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case car.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case car.FieldModelID:
		return m.OldModelID(ctx)
	case car.FieldImages:
		return m.OldImages(ctx)
	case car.FieldLicensePlate:
		return m.OldLicensePlate(ctx)
	case car.FieldPassengers:
		return m.OldPassengers(ctx)
	case car.FieldReservedSeats:
		return m.OldReservedSeats(ctx)
	case car.FieldProduceTime:
		return m.OldProduceTime(ctx)
	case car.FieldPowerThreshold:
		return m.OldPowerThreshold(ctx)
	case car.FieldActivateCode:
		return m.OldActivateCode(ctx)
	case car.FieldState:
		return m.OldState(ctx)
	case car.FieldUseState:
		return m.OldUseState(ctx)
	case car.FieldDrivingState:
		return m.OldDrivingState(ctx)
	case car.FieldEmergencyState:
		return m.OldEmergencyState(ctx)
	case car.FieldUseOrderID:
		return m.OldUseOrderID(ctx)
	case car.FieldDispatchTaskID:
		return m.OldDispatchTaskID(ctx)
	case car.FieldUseFlightID:
		return m.OldUseFlightID(ctx)
	case car.FieldBindOrderCount:
		return m.OldBindOrderCount(ctx)
	case car.FieldTotalOrderMileage:
		return m.OldTotalOrderMileage(ctx)
	case car.FieldTotalOrderTime:
		return m.OldTotalOrderTime(ctx)
	case car.FieldTotalOrderCount:
		return m.OldTotalOrderCount(ctx)
	case car.FieldTotalOrderAmount:
		return m.OldTotalOrderAmount(ctx)
	case car.FieldPowerRemaining:
		return m.OldPowerRemaining(ctx)
	case car.FieldErrorCount:
		return m.OldErrorCount(ctx)
	case car.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case car.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case car.FieldIsCommercialCar:
		return m.OldIsCommercialCar(ctx)
	case car.FieldIsDrivingStateValid:
		return m.OldIsDrivingStateValid(ctx)
	case car.FieldMapVersion:
		return m.OldMapVersion(ctx)
	case car.FieldNextMapVersion:
		return m.OldNextMapVersion(ctx)
	case car.FieldNextMapVersionState:
		return m.OldNextMapVersionState(ctx)
	case car.FieldNextMapVersionProcess:
		return m.OldNextMapVersionProcess(ctx)
	case car.FieldGrAutoVersion:
		return m.OldGrAutoVersion(ctx)
	case car.FieldGrUIVersion:
		return m.OldGrUIVersion(ctx)
	case car.FieldCarproxyID:
		return m.OldCarproxyID(ctx)
	case car.FieldExtendYokeeID:
		return m.OldExtendYokeeID(ctx)
	case car.FieldAliveTime:
		return m.OldAliveTime(ctx)
	case car.FieldRegisterTime:
		return m.OldRegisterTime(ctx)
	case car.FieldDrivingStateTime:
		return m.OldDrivingStateTime(ctx)
	case car.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case car.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case car.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case car.FieldOperationMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationMode(v)
		return nil
	case car.FieldCarName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarName(v)
		return nil
	case car.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case car.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case car.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case car.FieldImages:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case car.FieldLicensePlate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensePlate(v)
		return nil
	case car.FieldPassengers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassengers(v)
		return nil
	case car.FieldReservedSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservedSeats(v)
		return nil
	case car.FieldProduceTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProduceTime(v)
		return nil
	case car.FieldPowerThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerThreshold(v)
		return nil
	case car.FieldActivateCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivateCode(v)
		return nil
	case car.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case car.FieldUseState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseState(v)
		return nil
	case car.FieldDrivingState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingState(v)
		return nil
	case car.FieldEmergencyState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyState(v)
		return nil
	case car.FieldUseOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseOrderID(v)
		return nil
	case car.FieldDispatchTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDispatchTaskID(v)
		return nil
	case car.FieldUseFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseFlightID(v)
		return nil
	case car.FieldBindOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindOrderCount(v)
		return nil
	case car.FieldTotalOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOrderMileage(v)
		return nil
	case car.FieldTotalOrderTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOrderTime(v)
		return nil
	case car.FieldTotalOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOrderCount(v)
		return nil
	case car.FieldTotalOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalOrderAmount(v)
		return nil
	case car.FieldPowerRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerRemaining(v)
		return nil
	case car.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCount(v)
		return nil
	case car.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case car.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case car.FieldIsCommercialCar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCommercialCar(v)
		return nil
	case car.FieldIsDrivingStateValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDrivingStateValid(v)
		return nil
	case car.FieldMapVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapVersion(v)
		return nil
	case car.FieldNextMapVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextMapVersion(v)
		return nil
	case car.FieldNextMapVersionState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextMapVersionState(v)
		return nil
	case car.FieldNextMapVersionProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextMapVersionProcess(v)
		return nil
	case car.FieldGrAutoVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrAutoVersion(v)
		return nil
	case car.FieldGrUIVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrUIVersion(v)
		return nil
	case car.FieldCarproxyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarproxyID(v)
		return nil
	case car.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendYokeeID(v)
		return nil
	case car.FieldAliveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliveTime(v)
		return nil
	case car.FieldRegisterTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterTime(v)
		return nil
	case car.FieldDrivingStateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrivingStateTime(v)
		return nil
	case car.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case car.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarMutation) AddedFields() []string {
	var fields []string
	if m.addoperation_mode != nil {
		fields = append(fields, car.FieldOperationMode)
	}
	if m.addpassengers != nil {
		fields = append(fields, car.FieldPassengers)
	}
	if m.addreserved_seats != nil {
		fields = append(fields, car.FieldReservedSeats)
	}
	if m.addpower_threshold != nil {
		fields = append(fields, car.FieldPowerThreshold)
	}
	if m.addstate != nil {
		fields = append(fields, car.FieldState)
	}
	if m.adduse_state != nil {
		fields = append(fields, car.FieldUseState)
	}
	if m.adddriving_state != nil {
		fields = append(fields, car.FieldDrivingState)
	}
	if m.addemergency_state != nil {
		fields = append(fields, car.FieldEmergencyState)
	}
	if m.adduse_order_id != nil {
		fields = append(fields, car.FieldUseOrderID)
	}
	if m.adddispatch_task_id != nil {
		fields = append(fields, car.FieldDispatchTaskID)
	}
	if m.adduse_flight_id != nil {
		fields = append(fields, car.FieldUseFlightID)
	}
	if m.addbind_order_count != nil {
		fields = append(fields, car.FieldBindOrderCount)
	}
	if m.addtotal_order_mileage != nil {
		fields = append(fields, car.FieldTotalOrderMileage)
	}
	if m.addtotal_order_time != nil {
		fields = append(fields, car.FieldTotalOrderTime)
	}
	if m.addtotal_order_count != nil {
		fields = append(fields, car.FieldTotalOrderCount)
	}
	if m.addtotal_order_amount != nil {
		fields = append(fields, car.FieldTotalOrderAmount)
	}
	if m.addpower_remaining != nil {
		fields = append(fields, car.FieldPowerRemaining)
	}
	if m.adderror_count != nil {
		fields = append(fields, car.FieldErrorCount)
	}
	if m.addis_deleted != nil {
		fields = append(fields, car.FieldIsDeleted)
	}
	if m.addis_commercial_car != nil {
		fields = append(fields, car.FieldIsCommercialCar)
	}
	if m.addis_driving_state_valid != nil {
		fields = append(fields, car.FieldIsDrivingStateValid)
	}
	if m.addnext_map_version_process != nil {
		fields = append(fields, car.FieldNextMapVersionProcess)
	}
	if m.addextend_yokee_id != nil {
		fields = append(fields, car.FieldExtendYokeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case car.FieldOperationMode:
		return m.AddedOperationMode()
	case car.FieldPassengers:
		return m.AddedPassengers()
	case car.FieldReservedSeats:
		return m.AddedReservedSeats()
	case car.FieldPowerThreshold:
		return m.AddedPowerThreshold()
	case car.FieldState:
		return m.AddedState()
	case car.FieldUseState:
		return m.AddedUseState()
	case car.FieldDrivingState:
		return m.AddedDrivingState()
	case car.FieldEmergencyState:
		return m.AddedEmergencyState()
	case car.FieldUseOrderID:
		return m.AddedUseOrderID()
	case car.FieldDispatchTaskID:
		return m.AddedDispatchTaskID()
	case car.FieldUseFlightID:
		return m.AddedUseFlightID()
	case car.FieldBindOrderCount:
		return m.AddedBindOrderCount()
	case car.FieldTotalOrderMileage:
		return m.AddedTotalOrderMileage()
	case car.FieldTotalOrderTime:
		return m.AddedTotalOrderTime()
	case car.FieldTotalOrderCount:
		return m.AddedTotalOrderCount()
	case car.FieldTotalOrderAmount:
		return m.AddedTotalOrderAmount()
	case car.FieldPowerRemaining:
		return m.AddedPowerRemaining()
	case car.FieldErrorCount:
		return m.AddedErrorCount()
	case car.FieldIsDeleted:
		return m.AddedIsDeleted()
	case car.FieldIsCommercialCar:
		return m.AddedIsCommercialCar()
	case car.FieldIsDrivingStateValid:
		return m.AddedIsDrivingStateValid()
	case car.FieldNextMapVersionProcess:
		return m.AddedNextMapVersionProcess()
	case car.FieldExtendYokeeID:
		return m.AddedExtendYokeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case car.FieldOperationMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationMode(v)
		return nil
	case car.FieldPassengers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassengers(v)
		return nil
	case car.FieldReservedSeats:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservedSeats(v)
		return nil
	case car.FieldPowerThreshold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerThreshold(v)
		return nil
	case car.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case car.FieldUseState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseState(v)
		return nil
	case car.FieldDrivingState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrivingState(v)
		return nil
	case car.FieldEmergencyState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmergencyState(v)
		return nil
	case car.FieldUseOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseOrderID(v)
		return nil
	case car.FieldDispatchTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDispatchTaskID(v)
		return nil
	case car.FieldUseFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseFlightID(v)
		return nil
	case car.FieldBindOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBindOrderCount(v)
		return nil
	case car.FieldTotalOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOrderMileage(v)
		return nil
	case car.FieldTotalOrderTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOrderTime(v)
		return nil
	case car.FieldTotalOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOrderCount(v)
		return nil
	case car.FieldTotalOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalOrderAmount(v)
		return nil
	case car.FieldPowerRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerRemaining(v)
		return nil
	case car.FieldErrorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCount(v)
		return nil
	case car.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	case car.FieldIsCommercialCar:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsCommercialCar(v)
		return nil
	case car.FieldIsDrivingStateValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDrivingStateValid(v)
		return nil
	case car.FieldNextMapVersionProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNextMapVersionProcess(v)
		return nil
	case car.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtendYokeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(car.FieldDeleteTime) {
		fields = append(fields, car.FieldDeleteTime)
	}
	if m.FieldCleared(car.FieldExtendYokeeID) {
		fields = append(fields, car.FieldExtendYokeeID)
	}
	if m.FieldCleared(car.FieldAliveTime) {
		fields = append(fields, car.FieldAliveTime)
	}
	if m.FieldCleared(car.FieldRegisterTime) {
		fields = append(fields, car.FieldRegisterTime)
	}
	if m.FieldCleared(car.FieldDrivingStateTime) {
		fields = append(fields, car.FieldDrivingStateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	switch name {
	case car.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case car.FieldExtendYokeeID:
		m.ClearExtendYokeeID()
		return nil
	case car.FieldAliveTime:
		m.ClearAliveTime()
		return nil
	case car.FieldRegisterTime:
		m.ClearRegisterTime()
		return nil
	case car.FieldDrivingStateTime:
		m.ClearDrivingStateTime()
		return nil
	}
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	switch name {
	case car.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case car.FieldOperationMode:
		m.ResetOperationMode()
		return nil
	case car.FieldCarName:
		m.ResetCarName()
		return nil
	case car.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case car.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case car.FieldModelID:
		m.ResetModelID()
		return nil
	case car.FieldImages:
		m.ResetImages()
		return nil
	case car.FieldLicensePlate:
		m.ResetLicensePlate()
		return nil
	case car.FieldPassengers:
		m.ResetPassengers()
		return nil
	case car.FieldReservedSeats:
		m.ResetReservedSeats()
		return nil
	case car.FieldProduceTime:
		m.ResetProduceTime()
		return nil
	case car.FieldPowerThreshold:
		m.ResetPowerThreshold()
		return nil
	case car.FieldActivateCode:
		m.ResetActivateCode()
		return nil
	case car.FieldState:
		m.ResetState()
		return nil
	case car.FieldUseState:
		m.ResetUseState()
		return nil
	case car.FieldDrivingState:
		m.ResetDrivingState()
		return nil
	case car.FieldEmergencyState:
		m.ResetEmergencyState()
		return nil
	case car.FieldUseOrderID:
		m.ResetUseOrderID()
		return nil
	case car.FieldDispatchTaskID:
		m.ResetDispatchTaskID()
		return nil
	case car.FieldUseFlightID:
		m.ResetUseFlightID()
		return nil
	case car.FieldBindOrderCount:
		m.ResetBindOrderCount()
		return nil
	case car.FieldTotalOrderMileage:
		m.ResetTotalOrderMileage()
		return nil
	case car.FieldTotalOrderTime:
		m.ResetTotalOrderTime()
		return nil
	case car.FieldTotalOrderCount:
		m.ResetTotalOrderCount()
		return nil
	case car.FieldTotalOrderAmount:
		m.ResetTotalOrderAmount()
		return nil
	case car.FieldPowerRemaining:
		m.ResetPowerRemaining()
		return nil
	case car.FieldErrorCount:
		m.ResetErrorCount()
		return nil
	case car.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case car.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case car.FieldIsCommercialCar:
		m.ResetIsCommercialCar()
		return nil
	case car.FieldIsDrivingStateValid:
		m.ResetIsDrivingStateValid()
		return nil
	case car.FieldMapVersion:
		m.ResetMapVersion()
		return nil
	case car.FieldNextMapVersion:
		m.ResetNextMapVersion()
		return nil
	case car.FieldNextMapVersionState:
		m.ResetNextMapVersionState()
		return nil
	case car.FieldNextMapVersionProcess:
		m.ResetNextMapVersionProcess()
		return nil
	case car.FieldGrAutoVersion:
		m.ResetGrAutoVersion()
		return nil
	case car.FieldGrUIVersion:
		m.ResetGrUIVersion()
		return nil
	case car.FieldCarproxyID:
		m.ResetCarproxyID()
		return nil
	case car.FieldExtendYokeeID:
		m.ResetExtendYokeeID()
		return nil
	case car.FieldAliveTime:
		m.ResetAliveTime()
		return nil
	case car.FieldRegisterTime:
		m.ResetRegisterTime()
		return nil
	case car.FieldDrivingStateTime:
		m.ResetDrivingStateTime()
		return nil
	case car.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case car.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.background_scenic_area != nil {
		edges = append(edges, car.EdgeBackgroundScenicArea)
	}
	if m.cars_models != nil {
		edges = append(edges, car.EdgeCarsModels)
	}
	if m.car_operate_logs != nil {
		edges = append(edges, car.EdgeCarOperateLogs)
	}
	if m.orders != nil {
		edges = append(edges, car.EdgeOrders)
	}
	if m.stats_hourly_car != nil {
		edges = append(edges, car.EdgeStatsHourlyCar)
	}
	if m.sche_task != nil {
		edges = append(edges, car.EdgeScheTask)
	}
	if m.config_files != nil {
		edges = append(edges, car.EdgeConfigFiles)
	}
	if m.car_configs != nil {
		edges = append(edges, car.EdgeCarConfigs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeCarsModels:
		if id := m.cars_models; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeCarOperateLogs:
		ids := make([]ent.Value, 0, len(m.car_operate_logs))
		for id := range m.car_operate_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeStatsHourlyCar:
		ids := make([]ent.Value, 0, len(m.stats_hourly_car))
		for id := range m.stats_hourly_car {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeScheTask:
		ids := make([]ent.Value, 0, len(m.sche_task))
		for id := range m.sche_task {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.config_files))
		for id := range m.config_files {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeCarConfigs:
		ids := make([]ent.Value, 0, len(m.car_configs))
		for id := range m.car_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcar_operate_logs != nil {
		edges = append(edges, car.EdgeCarOperateLogs)
	}
	if m.removedorders != nil {
		edges = append(edges, car.EdgeOrders)
	}
	if m.removedstats_hourly_car != nil {
		edges = append(edges, car.EdgeStatsHourlyCar)
	}
	if m.removedsche_task != nil {
		edges = append(edges, car.EdgeScheTask)
	}
	if m.removedconfig_files != nil {
		edges = append(edges, car.EdgeConfigFiles)
	}
	if m.removedcar_configs != nil {
		edges = append(edges, car.EdgeCarConfigs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeCarOperateLogs:
		ids := make([]ent.Value, 0, len(m.removedcar_operate_logs))
		for id := range m.removedcar_operate_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeStatsHourlyCar:
		ids := make([]ent.Value, 0, len(m.removedstats_hourly_car))
		for id := range m.removedstats_hourly_car {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeScheTask:
		ids := make([]ent.Value, 0, len(m.removedsche_task))
		for id := range m.removedsche_task {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.removedconfig_files))
		for id := range m.removedconfig_files {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeCarConfigs:
		ids := make([]ent.Value, 0, len(m.removedcar_configs))
		for id := range m.removedcar_configs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbackground_scenic_area {
		edges = append(edges, car.EdgeBackgroundScenicArea)
	}
	if m.clearedcars_models {
		edges = append(edges, car.EdgeCarsModels)
	}
	if m.clearedcar_operate_logs {
		edges = append(edges, car.EdgeCarOperateLogs)
	}
	if m.clearedorders {
		edges = append(edges, car.EdgeOrders)
	}
	if m.clearedstats_hourly_car {
		edges = append(edges, car.EdgeStatsHourlyCar)
	}
	if m.clearedsche_task {
		edges = append(edges, car.EdgeScheTask)
	}
	if m.clearedconfig_files {
		edges = append(edges, car.EdgeConfigFiles)
	}
	if m.clearedcar_configs {
		edges = append(edges, car.EdgeCarConfigs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	switch name {
	case car.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	case car.EdgeCarsModels:
		return m.clearedcars_models
	case car.EdgeCarOperateLogs:
		return m.clearedcar_operate_logs
	case car.EdgeOrders:
		return m.clearedorders
	case car.EdgeStatsHourlyCar:
		return m.clearedstats_hourly_car
	case car.EdgeScheTask:
		return m.clearedsche_task
	case car.EdgeConfigFiles:
		return m.clearedconfig_files
	case car.EdgeCarConfigs:
		return m.clearedcar_configs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	switch name {
	case car.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	case car.EdgeCarsModels:
		m.ClearCarsModels()
		return nil
	}
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	switch name {
	case car.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	case car.EdgeCarsModels:
		m.ResetCarsModels()
		return nil
	case car.EdgeCarOperateLogs:
		m.ResetCarOperateLogs()
		return nil
	case car.EdgeOrders:
		m.ResetOrders()
		return nil
	case car.EdgeStatsHourlyCar:
		m.ResetStatsHourlyCar()
		return nil
	case car.EdgeScheTask:
		m.ResetScheTask()
		return nil
	case car.EdgeConfigFiles:
		m.ResetConfigFiles()
		return nil
	case car.EdgeCarConfigs:
		m.ResetCarConfigs()
		return nil
	}
	return fmt.Errorf("unknown Car edge %s", name)
}

// CarAlarmMutation represents an operation that mutates the CarAlarm nodes in the graph.
type CarAlarmMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	device_id            *string
	alarm_id             *uint32
	addalarm_id          *int32
	module_name          *string
	_type                *uint32
	add_type             *int32
	level                *uint32
	addlevel             *int32
	can_ignore           *uint32
	addcan_ignore        *int32
	effect_state         *uint32
	addeffect_state      *int32
	desc                 *string
	uuid                 *uint64
	adduuid              *int64
	associated_ids       *[]int
	appendassociated_ids []int
	create_time          *time.Time
	update_time          *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*CarAlarm, error)
	predicates           []predicate.CarAlarm
}

var _ ent.Mutation = (*CarAlarmMutation)(nil)

// caralarmOption allows management of the mutation configuration using functional options.
type caralarmOption func(*CarAlarmMutation)

// newCarAlarmMutation creates new mutation for the CarAlarm entity.
func newCarAlarmMutation(c config, op Op, opts ...caralarmOption) *CarAlarmMutation {
	m := &CarAlarmMutation{
		config:        c,
		op:            op,
		typ:           TypeCarAlarm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarAlarmID sets the ID field of the mutation.
func withCarAlarmID(id int) caralarmOption {
	return func(m *CarAlarmMutation) {
		var (
			err   error
			once  sync.Once
			value *CarAlarm
		)
		m.oldValue = func(ctx context.Context) (*CarAlarm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarAlarm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarAlarm sets the old CarAlarm of the mutation.
func withCarAlarm(node *CarAlarm) caralarmOption {
	return func(m *CarAlarmMutation) {
		m.oldValue = func(context.Context) (*CarAlarm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarAlarmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarAlarmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarAlarm entities.
func (m *CarAlarmMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarAlarmMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarAlarmMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarAlarm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceID sets the "device_id" field.
func (m *CarAlarmMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarAlarmMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarAlarmMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetAlarmID sets the "alarm_id" field.
func (m *CarAlarmMutation) SetAlarmID(u uint32) {
	m.alarm_id = &u
	m.addalarm_id = nil
}

// AlarmID returns the value of the "alarm_id" field in the mutation.
func (m *CarAlarmMutation) AlarmID() (r uint32, exists bool) {
	v := m.alarm_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmID returns the old "alarm_id" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldAlarmID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmID: %w", err)
	}
	return oldValue.AlarmID, nil
}

// AddAlarmID adds u to the "alarm_id" field.
func (m *CarAlarmMutation) AddAlarmID(u int32) {
	if m.addalarm_id != nil {
		*m.addalarm_id += u
	} else {
		m.addalarm_id = &u
	}
}

// AddedAlarmID returns the value that was added to the "alarm_id" field in this mutation.
func (m *CarAlarmMutation) AddedAlarmID() (r int32, exists bool) {
	v := m.addalarm_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlarmID resets all changes to the "alarm_id" field.
func (m *CarAlarmMutation) ResetAlarmID() {
	m.alarm_id = nil
	m.addalarm_id = nil
}

// SetModuleName sets the "module_name" field.
func (m *CarAlarmMutation) SetModuleName(s string) {
	m.module_name = &s
}

// ModuleName returns the value of the "module_name" field in the mutation.
func (m *CarAlarmMutation) ModuleName() (r string, exists bool) {
	v := m.module_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleName returns the old "module_name" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldModuleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleName: %w", err)
	}
	return oldValue.ModuleName, nil
}

// ResetModuleName resets all changes to the "module_name" field.
func (m *CarAlarmMutation) ResetModuleName() {
	m.module_name = nil
}

// SetType sets the "type" field.
func (m *CarAlarmMutation) SetType(u uint32) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CarAlarmMutation) GetType() (r uint32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldType(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *CarAlarmMutation) AddType(u int32) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CarAlarmMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CarAlarmMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLevel sets the "level" field.
func (m *CarAlarmMutation) SetLevel(u uint32) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CarAlarmMutation) Level() (r uint32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldLevel(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *CarAlarmMutation) AddLevel(u int32) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CarAlarmMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CarAlarmMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetCanIgnore sets the "can_ignore" field.
func (m *CarAlarmMutation) SetCanIgnore(u uint32) {
	m.can_ignore = &u
	m.addcan_ignore = nil
}

// CanIgnore returns the value of the "can_ignore" field in the mutation.
func (m *CarAlarmMutation) CanIgnore() (r uint32, exists bool) {
	v := m.can_ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldCanIgnore returns the old "can_ignore" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldCanIgnore(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanIgnore: %w", err)
	}
	return oldValue.CanIgnore, nil
}

// AddCanIgnore adds u to the "can_ignore" field.
func (m *CarAlarmMutation) AddCanIgnore(u int32) {
	if m.addcan_ignore != nil {
		*m.addcan_ignore += u
	} else {
		m.addcan_ignore = &u
	}
}

// AddedCanIgnore returns the value that was added to the "can_ignore" field in this mutation.
func (m *CarAlarmMutation) AddedCanIgnore() (r int32, exists bool) {
	v := m.addcan_ignore
	if v == nil {
		return
	}
	return *v, true
}

// ResetCanIgnore resets all changes to the "can_ignore" field.
func (m *CarAlarmMutation) ResetCanIgnore() {
	m.can_ignore = nil
	m.addcan_ignore = nil
}

// SetEffectState sets the "effect_state" field.
func (m *CarAlarmMutation) SetEffectState(u uint32) {
	m.effect_state = &u
	m.addeffect_state = nil
}

// EffectState returns the value of the "effect_state" field in the mutation.
func (m *CarAlarmMutation) EffectState() (r uint32, exists bool) {
	v := m.effect_state
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectState returns the old "effect_state" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldEffectState(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectState: %w", err)
	}
	return oldValue.EffectState, nil
}

// AddEffectState adds u to the "effect_state" field.
func (m *CarAlarmMutation) AddEffectState(u int32) {
	if m.addeffect_state != nil {
		*m.addeffect_state += u
	} else {
		m.addeffect_state = &u
	}
}

// AddedEffectState returns the value that was added to the "effect_state" field in this mutation.
func (m *CarAlarmMutation) AddedEffectState() (r int32, exists bool) {
	v := m.addeffect_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetEffectState resets all changes to the "effect_state" field.
func (m *CarAlarmMutation) ResetEffectState() {
	m.effect_state = nil
	m.addeffect_state = nil
}

// SetDesc sets the "desc" field.
func (m *CarAlarmMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *CarAlarmMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *CarAlarmMutation) ResetDesc() {
	m.desc = nil
}

// SetUUID sets the "uuid" field.
func (m *CarAlarmMutation) SetUUID(u uint64) {
	m.uuid = &u
	m.adduuid = nil
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *CarAlarmMutation) UUID() (r uint64, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldUUID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// AddUUID adds u to the "uuid" field.
func (m *CarAlarmMutation) AddUUID(u int64) {
	if m.adduuid != nil {
		*m.adduuid += u
	} else {
		m.adduuid = &u
	}
}

// AddedUUID returns the value that was added to the "uuid" field in this mutation.
func (m *CarAlarmMutation) AddedUUID() (r int64, exists bool) {
	v := m.adduuid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUUID resets all changes to the "uuid" field.
func (m *CarAlarmMutation) ResetUUID() {
	m.uuid = nil
	m.adduuid = nil
}

// SetAssociatedIds sets the "associated_ids" field.
func (m *CarAlarmMutation) SetAssociatedIds(i []int) {
	m.associated_ids = &i
	m.appendassociated_ids = nil
}

// AssociatedIds returns the value of the "associated_ids" field in the mutation.
func (m *CarAlarmMutation) AssociatedIds() (r []int, exists bool) {
	v := m.associated_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAssociatedIds returns the old "associated_ids" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldAssociatedIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssociatedIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssociatedIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssociatedIds: %w", err)
	}
	return oldValue.AssociatedIds, nil
}

// AppendAssociatedIds adds i to the "associated_ids" field.
func (m *CarAlarmMutation) AppendAssociatedIds(i []int) {
	m.appendassociated_ids = append(m.appendassociated_ids, i...)
}

// AppendedAssociatedIds returns the list of values that were appended to the "associated_ids" field in this mutation.
func (m *CarAlarmMutation) AppendedAssociatedIds() ([]int, bool) {
	if len(m.appendassociated_ids) == 0 {
		return nil, false
	}
	return m.appendassociated_ids, true
}

// ResetAssociatedIds resets all changes to the "associated_ids" field.
func (m *CarAlarmMutation) ResetAssociatedIds() {
	m.associated_ids = nil
	m.appendassociated_ids = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarAlarmMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarAlarmMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarAlarmMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarAlarmMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarAlarmMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarAlarm entity.
// If the CarAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarAlarmMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarAlarmMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarAlarmMutation builder.
func (m *CarAlarmMutation) Where(ps ...predicate.CarAlarm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarAlarmMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarAlarmMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarAlarm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarAlarmMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarAlarmMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarAlarm).
func (m *CarAlarmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarAlarmMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.device_id != nil {
		fields = append(fields, caralarm.FieldDeviceID)
	}
	if m.alarm_id != nil {
		fields = append(fields, caralarm.FieldAlarmID)
	}
	if m.module_name != nil {
		fields = append(fields, caralarm.FieldModuleName)
	}
	if m._type != nil {
		fields = append(fields, caralarm.FieldType)
	}
	if m.level != nil {
		fields = append(fields, caralarm.FieldLevel)
	}
	if m.can_ignore != nil {
		fields = append(fields, caralarm.FieldCanIgnore)
	}
	if m.effect_state != nil {
		fields = append(fields, caralarm.FieldEffectState)
	}
	if m.desc != nil {
		fields = append(fields, caralarm.FieldDesc)
	}
	if m.uuid != nil {
		fields = append(fields, caralarm.FieldUUID)
	}
	if m.associated_ids != nil {
		fields = append(fields, caralarm.FieldAssociatedIds)
	}
	if m.create_time != nil {
		fields = append(fields, caralarm.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, caralarm.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarAlarmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case caralarm.FieldDeviceID:
		return m.DeviceID()
	case caralarm.FieldAlarmID:
		return m.AlarmID()
	case caralarm.FieldModuleName:
		return m.ModuleName()
	case caralarm.FieldType:
		return m.GetType()
	case caralarm.FieldLevel:
		return m.Level()
	case caralarm.FieldCanIgnore:
		return m.CanIgnore()
	case caralarm.FieldEffectState:
		return m.EffectState()
	case caralarm.FieldDesc:
		return m.Desc()
	case caralarm.FieldUUID:
		return m.UUID()
	case caralarm.FieldAssociatedIds:
		return m.AssociatedIds()
	case caralarm.FieldCreateTime:
		return m.CreateTime()
	case caralarm.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarAlarmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case caralarm.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case caralarm.FieldAlarmID:
		return m.OldAlarmID(ctx)
	case caralarm.FieldModuleName:
		return m.OldModuleName(ctx)
	case caralarm.FieldType:
		return m.OldType(ctx)
	case caralarm.FieldLevel:
		return m.OldLevel(ctx)
	case caralarm.FieldCanIgnore:
		return m.OldCanIgnore(ctx)
	case caralarm.FieldEffectState:
		return m.OldEffectState(ctx)
	case caralarm.FieldDesc:
		return m.OldDesc(ctx)
	case caralarm.FieldUUID:
		return m.OldUUID(ctx)
	case caralarm.FieldAssociatedIds:
		return m.OldAssociatedIds(ctx)
	case caralarm.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case caralarm.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarAlarm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarAlarmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case caralarm.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case caralarm.FieldAlarmID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmID(v)
		return nil
	case caralarm.FieldModuleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleName(v)
		return nil
	case caralarm.FieldType:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case caralarm.FieldLevel:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case caralarm.FieldCanIgnore:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanIgnore(v)
		return nil
	case caralarm.FieldEffectState:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectState(v)
		return nil
	case caralarm.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case caralarm.FieldUUID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case caralarm.FieldAssociatedIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssociatedIds(v)
		return nil
	case caralarm.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case caralarm.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarAlarm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarAlarmMutation) AddedFields() []string {
	var fields []string
	if m.addalarm_id != nil {
		fields = append(fields, caralarm.FieldAlarmID)
	}
	if m.add_type != nil {
		fields = append(fields, caralarm.FieldType)
	}
	if m.addlevel != nil {
		fields = append(fields, caralarm.FieldLevel)
	}
	if m.addcan_ignore != nil {
		fields = append(fields, caralarm.FieldCanIgnore)
	}
	if m.addeffect_state != nil {
		fields = append(fields, caralarm.FieldEffectState)
	}
	if m.adduuid != nil {
		fields = append(fields, caralarm.FieldUUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarAlarmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case caralarm.FieldAlarmID:
		return m.AddedAlarmID()
	case caralarm.FieldType:
		return m.AddedType()
	case caralarm.FieldLevel:
		return m.AddedLevel()
	case caralarm.FieldCanIgnore:
		return m.AddedCanIgnore()
	case caralarm.FieldEffectState:
		return m.AddedEffectState()
	case caralarm.FieldUUID:
		return m.AddedUUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarAlarmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case caralarm.FieldAlarmID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlarmID(v)
		return nil
	case caralarm.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case caralarm.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case caralarm.FieldCanIgnore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCanIgnore(v)
		return nil
	case caralarm.FieldEffectState:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEffectState(v)
		return nil
	case caralarm.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUUID(v)
		return nil
	}
	return fmt.Errorf("unknown CarAlarm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarAlarmMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarAlarmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarAlarmMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarAlarm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarAlarmMutation) ResetField(name string) error {
	switch name {
	case caralarm.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case caralarm.FieldAlarmID:
		m.ResetAlarmID()
		return nil
	case caralarm.FieldModuleName:
		m.ResetModuleName()
		return nil
	case caralarm.FieldType:
		m.ResetType()
		return nil
	case caralarm.FieldLevel:
		m.ResetLevel()
		return nil
	case caralarm.FieldCanIgnore:
		m.ResetCanIgnore()
		return nil
	case caralarm.FieldEffectState:
		m.ResetEffectState()
		return nil
	case caralarm.FieldDesc:
		m.ResetDesc()
		return nil
	case caralarm.FieldUUID:
		m.ResetUUID()
		return nil
	case caralarm.FieldAssociatedIds:
		m.ResetAssociatedIds()
		return nil
	case caralarm.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case caralarm.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarAlarm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarAlarmMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarAlarmMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarAlarmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarAlarmMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarAlarmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarAlarmMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarAlarmMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarAlarm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarAlarmMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarAlarm edge %s", name)
}

// CarConfigMutation represents an operation that mutates the CarConfig nodes in the graph.
type CarConfigMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	car_version                   *string
	name                          *string
	remark                        *string
	version                       *string
	save_path                     *string
	content_type                  *int
	addcontent_type               *int
	content_field                 *int
	addcontent_field              *int
	content_file_id               *int
	addcontent_file_id            *int
	content_pbtext                *string
	content_sha1                  *string
	resource_file_ids             *[]int
	appendresource_file_ids       []int
	create_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	cars_models                   *int
	clearedcars_models            bool
	car                           *int
	clearedcar                    bool
	done                          bool
	oldValue                      func(context.Context) (*CarConfig, error)
	predicates                    []predicate.CarConfig
}

var _ ent.Mutation = (*CarConfigMutation)(nil)

// carconfigOption allows management of the mutation configuration using functional options.
type carconfigOption func(*CarConfigMutation)

// newCarConfigMutation creates new mutation for the CarConfig entity.
func newCarConfigMutation(c config, op Op, opts ...carconfigOption) *CarConfigMutation {
	m := &CarConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeCarConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarConfigID sets the ID field of the mutation.
func withCarConfigID(id int) carconfigOption {
	return func(m *CarConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *CarConfig
		)
		m.oldValue = func(ctx context.Context) (*CarConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarConfig sets the old CarConfig of the mutation.
func withCarConfig(node *CarConfig) carconfigOption {
	return func(m *CarConfigMutation) {
		m.oldValue = func(context.Context) (*CarConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarConfig entities.
func (m *CarConfigMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CarConfigMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CarConfigMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *CarConfigMutation) ClearScenicAreaID() {
	m.background_scenic_area = nil
	m.clearedFields[carconfig.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *CarConfigMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[carconfig.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CarConfigMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
	delete(m.clearedFields, carconfig.FieldScenicAreaID)
}

// SetModelID sets the "model_id" field.
func (m *CarConfigMutation) SetModelID(i int) {
	m.cars_models = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CarConfigMutation) ModelID() (r int, exists bool) {
	v := m.cars_models
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldModelID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ClearModelID clears the value of the "model_id" field.
func (m *CarConfigMutation) ClearModelID() {
	m.cars_models = nil
	m.clearedFields[carconfig.FieldModelID] = struct{}{}
}

// ModelIDCleared returns if the "model_id" field was cleared in this mutation.
func (m *CarConfigMutation) ModelIDCleared() bool {
	_, ok := m.clearedFields[carconfig.FieldModelID]
	return ok
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CarConfigMutation) ResetModelID() {
	m.cars_models = nil
	delete(m.clearedFields, carconfig.FieldModelID)
}

// SetCarID sets the "car_id" field.
func (m *CarConfigMutation) SetCarID(i int) {
	m.car = &i
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarConfigMutation) CarID() (r int, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldCarID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ClearCarID clears the value of the "car_id" field.
func (m *CarConfigMutation) ClearCarID() {
	m.car = nil
	m.clearedFields[carconfig.FieldCarID] = struct{}{}
}

// CarIDCleared returns if the "car_id" field was cleared in this mutation.
func (m *CarConfigMutation) CarIDCleared() bool {
	_, ok := m.clearedFields[carconfig.FieldCarID]
	return ok
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarConfigMutation) ResetCarID() {
	m.car = nil
	delete(m.clearedFields, carconfig.FieldCarID)
}

// SetCarVersion sets the "car_version" field.
func (m *CarConfigMutation) SetCarVersion(s string) {
	m.car_version = &s
}

// CarVersion returns the value of the "car_version" field in the mutation.
func (m *CarConfigMutation) CarVersion() (r string, exists bool) {
	v := m.car_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCarVersion returns the old "car_version" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldCarVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarVersion: %w", err)
	}
	return oldValue.CarVersion, nil
}

// ResetCarVersion resets all changes to the "car_version" field.
func (m *CarConfigMutation) ResetCarVersion() {
	m.car_version = nil
}

// SetName sets the "name" field.
func (m *CarConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarConfigMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *CarConfigMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CarConfigMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CarConfigMutation) ResetRemark() {
	m.remark = nil
}

// SetVersion sets the "version" field.
func (m *CarConfigMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *CarConfigMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *CarConfigMutation) ResetVersion() {
	m.version = nil
}

// SetSavePath sets the "save_path" field.
func (m *CarConfigMutation) SetSavePath(s string) {
	m.save_path = &s
}

// SavePath returns the value of the "save_path" field in the mutation.
func (m *CarConfigMutation) SavePath() (r string, exists bool) {
	v := m.save_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSavePath returns the old "save_path" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldSavePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSavePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSavePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSavePath: %w", err)
	}
	return oldValue.SavePath, nil
}

// ResetSavePath resets all changes to the "save_path" field.
func (m *CarConfigMutation) ResetSavePath() {
	m.save_path = nil
}

// SetContentType sets the "content_type" field.
func (m *CarConfigMutation) SetContentType(i int) {
	m.content_type = &i
	m.addcontent_type = nil
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *CarConfigMutation) ContentType() (r int, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldContentType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// AddContentType adds i to the "content_type" field.
func (m *CarConfigMutation) AddContentType(i int) {
	if m.addcontent_type != nil {
		*m.addcontent_type += i
	} else {
		m.addcontent_type = &i
	}
}

// AddedContentType returns the value that was added to the "content_type" field in this mutation.
func (m *CarConfigMutation) AddedContentType() (r int, exists bool) {
	v := m.addcontent_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetContentType resets all changes to the "content_type" field.
func (m *CarConfigMutation) ResetContentType() {
	m.content_type = nil
	m.addcontent_type = nil
}

// SetContentField sets the "content_field" field.
func (m *CarConfigMutation) SetContentField(i int) {
	m.content_field = &i
	m.addcontent_field = nil
}

// ContentField returns the value of the "content_field" field in the mutation.
func (m *CarConfigMutation) ContentField() (r int, exists bool) {
	v := m.content_field
	if v == nil {
		return
	}
	return *v, true
}

// OldContentField returns the old "content_field" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldContentField(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentField: %w", err)
	}
	return oldValue.ContentField, nil
}

// AddContentField adds i to the "content_field" field.
func (m *CarConfigMutation) AddContentField(i int) {
	if m.addcontent_field != nil {
		*m.addcontent_field += i
	} else {
		m.addcontent_field = &i
	}
}

// AddedContentField returns the value that was added to the "content_field" field in this mutation.
func (m *CarConfigMutation) AddedContentField() (r int, exists bool) {
	v := m.addcontent_field
	if v == nil {
		return
	}
	return *v, true
}

// ResetContentField resets all changes to the "content_field" field.
func (m *CarConfigMutation) ResetContentField() {
	m.content_field = nil
	m.addcontent_field = nil
}

// SetContentFileID sets the "content_file_id" field.
func (m *CarConfigMutation) SetContentFileID(i int) {
	m.content_file_id = &i
	m.addcontent_file_id = nil
}

// ContentFileID returns the value of the "content_file_id" field in the mutation.
func (m *CarConfigMutation) ContentFileID() (r int, exists bool) {
	v := m.content_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContentFileID returns the old "content_file_id" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldContentFileID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentFileID: %w", err)
	}
	return oldValue.ContentFileID, nil
}

// AddContentFileID adds i to the "content_file_id" field.
func (m *CarConfigMutation) AddContentFileID(i int) {
	if m.addcontent_file_id != nil {
		*m.addcontent_file_id += i
	} else {
		m.addcontent_file_id = &i
	}
}

// AddedContentFileID returns the value that was added to the "content_file_id" field in this mutation.
func (m *CarConfigMutation) AddedContentFileID() (r int, exists bool) {
	v := m.addcontent_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContentFileID clears the value of the "content_file_id" field.
func (m *CarConfigMutation) ClearContentFileID() {
	m.content_file_id = nil
	m.addcontent_file_id = nil
	m.clearedFields[carconfig.FieldContentFileID] = struct{}{}
}

// ContentFileIDCleared returns if the "content_file_id" field was cleared in this mutation.
func (m *CarConfigMutation) ContentFileIDCleared() bool {
	_, ok := m.clearedFields[carconfig.FieldContentFileID]
	return ok
}

// ResetContentFileID resets all changes to the "content_file_id" field.
func (m *CarConfigMutation) ResetContentFileID() {
	m.content_file_id = nil
	m.addcontent_file_id = nil
	delete(m.clearedFields, carconfig.FieldContentFileID)
}

// SetContentPbtext sets the "content_pbtext" field.
func (m *CarConfigMutation) SetContentPbtext(s string) {
	m.content_pbtext = &s
}

// ContentPbtext returns the value of the "content_pbtext" field in the mutation.
func (m *CarConfigMutation) ContentPbtext() (r string, exists bool) {
	v := m.content_pbtext
	if v == nil {
		return
	}
	return *v, true
}

// OldContentPbtext returns the old "content_pbtext" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldContentPbtext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentPbtext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentPbtext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentPbtext: %w", err)
	}
	return oldValue.ContentPbtext, nil
}

// ResetContentPbtext resets all changes to the "content_pbtext" field.
func (m *CarConfigMutation) ResetContentPbtext() {
	m.content_pbtext = nil
}

// SetContentSha1 sets the "content_sha1" field.
func (m *CarConfigMutation) SetContentSha1(s string) {
	m.content_sha1 = &s
}

// ContentSha1 returns the value of the "content_sha1" field in the mutation.
func (m *CarConfigMutation) ContentSha1() (r string, exists bool) {
	v := m.content_sha1
	if v == nil {
		return
	}
	return *v, true
}

// OldContentSha1 returns the old "content_sha1" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldContentSha1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentSha1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentSha1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentSha1: %w", err)
	}
	return oldValue.ContentSha1, nil
}

// ResetContentSha1 resets all changes to the "content_sha1" field.
func (m *CarConfigMutation) ResetContentSha1() {
	m.content_sha1 = nil
}

// SetResourceFileIds sets the "resource_file_ids" field.
func (m *CarConfigMutation) SetResourceFileIds(i []int) {
	m.resource_file_ids = &i
	m.appendresource_file_ids = nil
}

// ResourceFileIds returns the value of the "resource_file_ids" field in the mutation.
func (m *CarConfigMutation) ResourceFileIds() (r []int, exists bool) {
	v := m.resource_file_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceFileIds returns the old "resource_file_ids" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldResourceFileIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceFileIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceFileIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceFileIds: %w", err)
	}
	return oldValue.ResourceFileIds, nil
}

// AppendResourceFileIds adds i to the "resource_file_ids" field.
func (m *CarConfigMutation) AppendResourceFileIds(i []int) {
	m.appendresource_file_ids = append(m.appendresource_file_ids, i...)
}

// AppendedResourceFileIds returns the list of values that were appended to the "resource_file_ids" field in this mutation.
func (m *CarConfigMutation) AppendedResourceFileIds() ([]int, bool) {
	if len(m.appendresource_file_ids) == 0 {
		return nil, false
	}
	return m.appendresource_file_ids, true
}

// ClearResourceFileIds clears the value of the "resource_file_ids" field.
func (m *CarConfigMutation) ClearResourceFileIds() {
	m.resource_file_ids = nil
	m.appendresource_file_ids = nil
	m.clearedFields[carconfig.FieldResourceFileIds] = struct{}{}
}

// ResourceFileIdsCleared returns if the "resource_file_ids" field was cleared in this mutation.
func (m *CarConfigMutation) ResourceFileIdsCleared() bool {
	_, ok := m.clearedFields[carconfig.FieldResourceFileIds]
	return ok
}

// ResetResourceFileIds resets all changes to the "resource_file_ids" field.
func (m *CarConfigMutation) ResetResourceFileIds() {
	m.resource_file_ids = nil
	m.appendresource_file_ids = nil
	delete(m.clearedFields, carconfig.FieldResourceFileIds)
}

// SetCreateTime sets the "create_time" field.
func (m *CarConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarConfig entity.
// If the CarConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *CarConfigMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *CarConfigMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[carconfig.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *CarConfigMutation) BackgroundScenicAreaCleared() bool {
	return m.ScenicAreaIDCleared() || m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *CarConfigMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *CarConfigMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *CarConfigMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// SetCarsModelsID sets the "cars_models" edge to the CarsModels entity by id.
func (m *CarConfigMutation) SetCarsModelsID(id int) {
	m.cars_models = &id
}

// ClearCarsModels clears the "cars_models" edge to the CarsModels entity.
func (m *CarConfigMutation) ClearCarsModels() {
	m.clearedcars_models = true
	m.clearedFields[carconfig.FieldModelID] = struct{}{}
}

// CarsModelsCleared reports if the "cars_models" edge to the CarsModels entity was cleared.
func (m *CarConfigMutation) CarsModelsCleared() bool {
	return m.ModelIDCleared() || m.clearedcars_models
}

// CarsModelsID returns the "cars_models" edge ID in the mutation.
func (m *CarConfigMutation) CarsModelsID() (id int, exists bool) {
	if m.cars_models != nil {
		return *m.cars_models, true
	}
	return
}

// CarsModelsIDs returns the "cars_models" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarsModelsID instead. It exists only for internal usage by the builders.
func (m *CarConfigMutation) CarsModelsIDs() (ids []int) {
	if id := m.cars_models; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarsModels resets all changes to the "cars_models" edge.
func (m *CarConfigMutation) ResetCarsModels() {
	m.cars_models = nil
	m.clearedcars_models = false
}

// ClearCar clears the "car" edge to the Car entity.
func (m *CarConfigMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[carconfig.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *CarConfigMutation) CarCleared() bool {
	return m.CarIDCleared() || m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *CarConfigMutation) CarIDs() (ids []int) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *CarConfigMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// Where appends a list predicates to the CarConfigMutation builder.
func (m *CarConfigMutation) Where(ps ...predicate.CarConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarConfig).
func (m *CarConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarConfigMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.background_scenic_area != nil {
		fields = append(fields, carconfig.FieldScenicAreaID)
	}
	if m.cars_models != nil {
		fields = append(fields, carconfig.FieldModelID)
	}
	if m.car != nil {
		fields = append(fields, carconfig.FieldCarID)
	}
	if m.car_version != nil {
		fields = append(fields, carconfig.FieldCarVersion)
	}
	if m.name != nil {
		fields = append(fields, carconfig.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, carconfig.FieldRemark)
	}
	if m.version != nil {
		fields = append(fields, carconfig.FieldVersion)
	}
	if m.save_path != nil {
		fields = append(fields, carconfig.FieldSavePath)
	}
	if m.content_type != nil {
		fields = append(fields, carconfig.FieldContentType)
	}
	if m.content_field != nil {
		fields = append(fields, carconfig.FieldContentField)
	}
	if m.content_file_id != nil {
		fields = append(fields, carconfig.FieldContentFileID)
	}
	if m.content_pbtext != nil {
		fields = append(fields, carconfig.FieldContentPbtext)
	}
	if m.content_sha1 != nil {
		fields = append(fields, carconfig.FieldContentSha1)
	}
	if m.resource_file_ids != nil {
		fields = append(fields, carconfig.FieldResourceFileIds)
	}
	if m.create_time != nil {
		fields = append(fields, carconfig.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carconfig.FieldScenicAreaID:
		return m.ScenicAreaID()
	case carconfig.FieldModelID:
		return m.ModelID()
	case carconfig.FieldCarID:
		return m.CarID()
	case carconfig.FieldCarVersion:
		return m.CarVersion()
	case carconfig.FieldName:
		return m.Name()
	case carconfig.FieldRemark:
		return m.Remark()
	case carconfig.FieldVersion:
		return m.Version()
	case carconfig.FieldSavePath:
		return m.SavePath()
	case carconfig.FieldContentType:
		return m.ContentType()
	case carconfig.FieldContentField:
		return m.ContentField()
	case carconfig.FieldContentFileID:
		return m.ContentFileID()
	case carconfig.FieldContentPbtext:
		return m.ContentPbtext()
	case carconfig.FieldContentSha1:
		return m.ContentSha1()
	case carconfig.FieldResourceFileIds:
		return m.ResourceFileIds()
	case carconfig.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carconfig.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case carconfig.FieldModelID:
		return m.OldModelID(ctx)
	case carconfig.FieldCarID:
		return m.OldCarID(ctx)
	case carconfig.FieldCarVersion:
		return m.OldCarVersion(ctx)
	case carconfig.FieldName:
		return m.OldName(ctx)
	case carconfig.FieldRemark:
		return m.OldRemark(ctx)
	case carconfig.FieldVersion:
		return m.OldVersion(ctx)
	case carconfig.FieldSavePath:
		return m.OldSavePath(ctx)
	case carconfig.FieldContentType:
		return m.OldContentType(ctx)
	case carconfig.FieldContentField:
		return m.OldContentField(ctx)
	case carconfig.FieldContentFileID:
		return m.OldContentFileID(ctx)
	case carconfig.FieldContentPbtext:
		return m.OldContentPbtext(ctx)
	case carconfig.FieldContentSha1:
		return m.OldContentSha1(ctx)
	case carconfig.FieldResourceFileIds:
		return m.OldResourceFileIds(ctx)
	case carconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carconfig.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case carconfig.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case carconfig.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carconfig.FieldCarVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarVersion(v)
		return nil
	case carconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case carconfig.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case carconfig.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case carconfig.FieldSavePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSavePath(v)
		return nil
	case carconfig.FieldContentType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case carconfig.FieldContentField:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentField(v)
		return nil
	case carconfig.FieldContentFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentFileID(v)
		return nil
	case carconfig.FieldContentPbtext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentPbtext(v)
		return nil
	case carconfig.FieldContentSha1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentSha1(v)
		return nil
	case carconfig.FieldResourceFileIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceFileIds(v)
		return nil
	case carconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarConfigMutation) AddedFields() []string {
	var fields []string
	if m.addcontent_type != nil {
		fields = append(fields, carconfig.FieldContentType)
	}
	if m.addcontent_field != nil {
		fields = append(fields, carconfig.FieldContentField)
	}
	if m.addcontent_file_id != nil {
		fields = append(fields, carconfig.FieldContentFileID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carconfig.FieldContentType:
		return m.AddedContentType()
	case carconfig.FieldContentField:
		return m.AddedContentField()
	case carconfig.FieldContentFileID:
		return m.AddedContentFileID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carconfig.FieldContentType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentType(v)
		return nil
	case carconfig.FieldContentField:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentField(v)
		return nil
	case carconfig.FieldContentFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentFileID(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carconfig.FieldScenicAreaID) {
		fields = append(fields, carconfig.FieldScenicAreaID)
	}
	if m.FieldCleared(carconfig.FieldModelID) {
		fields = append(fields, carconfig.FieldModelID)
	}
	if m.FieldCleared(carconfig.FieldCarID) {
		fields = append(fields, carconfig.FieldCarID)
	}
	if m.FieldCleared(carconfig.FieldContentFileID) {
		fields = append(fields, carconfig.FieldContentFileID)
	}
	if m.FieldCleared(carconfig.FieldResourceFileIds) {
		fields = append(fields, carconfig.FieldResourceFileIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarConfigMutation) ClearField(name string) error {
	switch name {
	case carconfig.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case carconfig.FieldModelID:
		m.ClearModelID()
		return nil
	case carconfig.FieldCarID:
		m.ClearCarID()
		return nil
	case carconfig.FieldContentFileID:
		m.ClearContentFileID()
		return nil
	case carconfig.FieldResourceFileIds:
		m.ClearResourceFileIds()
		return nil
	}
	return fmt.Errorf("unknown CarConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarConfigMutation) ResetField(name string) error {
	switch name {
	case carconfig.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case carconfig.FieldModelID:
		m.ResetModelID()
		return nil
	case carconfig.FieldCarID:
		m.ResetCarID()
		return nil
	case carconfig.FieldCarVersion:
		m.ResetCarVersion()
		return nil
	case carconfig.FieldName:
		m.ResetName()
		return nil
	case carconfig.FieldRemark:
		m.ResetRemark()
		return nil
	case carconfig.FieldVersion:
		m.ResetVersion()
		return nil
	case carconfig.FieldSavePath:
		m.ResetSavePath()
		return nil
	case carconfig.FieldContentType:
		m.ResetContentType()
		return nil
	case carconfig.FieldContentField:
		m.ResetContentField()
		return nil
	case carconfig.FieldContentFileID:
		m.ResetContentFileID()
		return nil
	case carconfig.FieldContentPbtext:
		m.ResetContentPbtext()
		return nil
	case carconfig.FieldContentSha1:
		m.ResetContentSha1()
		return nil
	case carconfig.FieldResourceFileIds:
		m.ResetResourceFileIds()
		return nil
	case carconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown CarConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.background_scenic_area != nil {
		edges = append(edges, carconfig.EdgeBackgroundScenicArea)
	}
	if m.cars_models != nil {
		edges = append(edges, carconfig.EdgeCarsModels)
	}
	if m.car != nil {
		edges = append(edges, carconfig.EdgeCar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carconfig.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	case carconfig.EdgeCarsModels:
		if id := m.cars_models; id != nil {
			return []ent.Value{*id}
		}
	case carconfig.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbackground_scenic_area {
		edges = append(edges, carconfig.EdgeBackgroundScenicArea)
	}
	if m.clearedcars_models {
		edges = append(edges, carconfig.EdgeCarsModels)
	}
	if m.clearedcar {
		edges = append(edges, carconfig.EdgeCar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case carconfig.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	case carconfig.EdgeCarsModels:
		return m.clearedcars_models
	case carconfig.EdgeCar:
		return m.clearedcar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarConfigMutation) ClearEdge(name string) error {
	switch name {
	case carconfig.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	case carconfig.EdgeCarsModels:
		m.ClearCarsModels()
		return nil
	case carconfig.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown CarConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarConfigMutation) ResetEdge(name string) error {
	switch name {
	case carconfig.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	case carconfig.EdgeCarsModels:
		m.ResetCarsModels()
		return nil
	case carconfig.EdgeCar:
		m.ResetCar()
		return nil
	}
	return fmt.Errorf("unknown CarConfig edge %s", name)
}

// CarConfigDownloadMutation represents an operation that mutates the CarConfigDownload nodes in the graph.
type CarConfigDownloadMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	uuid                *int64
	adduuid             *int64
	car_id              *int
	addcar_id           *int
	device_id           *string
	download_state      *string
	download_process    *int
	adddownload_process *int
	config_ids          *[]int
	appendconfig_ids    []int
	remark              *string
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CarConfigDownload, error)
	predicates          []predicate.CarConfigDownload
}

var _ ent.Mutation = (*CarConfigDownloadMutation)(nil)

// carconfigdownloadOption allows management of the mutation configuration using functional options.
type carconfigdownloadOption func(*CarConfigDownloadMutation)

// newCarConfigDownloadMutation creates new mutation for the CarConfigDownload entity.
func newCarConfigDownloadMutation(c config, op Op, opts ...carconfigdownloadOption) *CarConfigDownloadMutation {
	m := &CarConfigDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeCarConfigDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarConfigDownloadID sets the ID field of the mutation.
func withCarConfigDownloadID(id int) carconfigdownloadOption {
	return func(m *CarConfigDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *CarConfigDownload
		)
		m.oldValue = func(ctx context.Context) (*CarConfigDownload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarConfigDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarConfigDownload sets the old CarConfigDownload of the mutation.
func withCarConfigDownload(node *CarConfigDownload) carconfigdownloadOption {
	return func(m *CarConfigDownloadMutation) {
		m.oldValue = func(context.Context) (*CarConfigDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarConfigDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarConfigDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarConfigDownload entities.
func (m *CarConfigDownloadMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarConfigDownloadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarConfigDownloadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarConfigDownload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *CarConfigDownloadMutation) SetUUID(i int64) {
	m.uuid = &i
	m.adduuid = nil
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *CarConfigDownloadMutation) UUID() (r int64, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldUUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// AddUUID adds i to the "uuid" field.
func (m *CarConfigDownloadMutation) AddUUID(i int64) {
	if m.adduuid != nil {
		*m.adduuid += i
	} else {
		m.adduuid = &i
	}
}

// AddedUUID returns the value that was added to the "uuid" field in this mutation.
func (m *CarConfigDownloadMutation) AddedUUID() (r int64, exists bool) {
	v := m.adduuid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUUID resets all changes to the "uuid" field.
func (m *CarConfigDownloadMutation) ResetUUID() {
	m.uuid = nil
	m.adduuid = nil
}

// SetCarID sets the "car_id" field.
func (m *CarConfigDownloadMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarConfigDownloadMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarConfigDownloadMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarConfigDownloadMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarConfigDownloadMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarConfigDownloadMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarConfigDownloadMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarConfigDownloadMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetDownloadState sets the "download_state" field.
func (m *CarConfigDownloadMutation) SetDownloadState(s string) {
	m.download_state = &s
}

// DownloadState returns the value of the "download_state" field in the mutation.
func (m *CarConfigDownloadMutation) DownloadState() (r string, exists bool) {
	v := m.download_state
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadState returns the old "download_state" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldDownloadState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadState: %w", err)
	}
	return oldValue.DownloadState, nil
}

// ResetDownloadState resets all changes to the "download_state" field.
func (m *CarConfigDownloadMutation) ResetDownloadState() {
	m.download_state = nil
}

// SetDownloadProcess sets the "download_process" field.
func (m *CarConfigDownloadMutation) SetDownloadProcess(i int) {
	m.download_process = &i
	m.adddownload_process = nil
}

// DownloadProcess returns the value of the "download_process" field in the mutation.
func (m *CarConfigDownloadMutation) DownloadProcess() (r int, exists bool) {
	v := m.download_process
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadProcess returns the old "download_process" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldDownloadProcess(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadProcess: %w", err)
	}
	return oldValue.DownloadProcess, nil
}

// AddDownloadProcess adds i to the "download_process" field.
func (m *CarConfigDownloadMutation) AddDownloadProcess(i int) {
	if m.adddownload_process != nil {
		*m.adddownload_process += i
	} else {
		m.adddownload_process = &i
	}
}

// AddedDownloadProcess returns the value that was added to the "download_process" field in this mutation.
func (m *CarConfigDownloadMutation) AddedDownloadProcess() (r int, exists bool) {
	v := m.adddownload_process
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadProcess resets all changes to the "download_process" field.
func (m *CarConfigDownloadMutation) ResetDownloadProcess() {
	m.download_process = nil
	m.adddownload_process = nil
}

// SetConfigIds sets the "config_ids" field.
func (m *CarConfigDownloadMutation) SetConfigIds(i []int) {
	m.config_ids = &i
	m.appendconfig_ids = nil
}

// ConfigIds returns the value of the "config_ids" field in the mutation.
func (m *CarConfigDownloadMutation) ConfigIds() (r []int, exists bool) {
	v := m.config_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigIds returns the old "config_ids" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldConfigIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigIds: %w", err)
	}
	return oldValue.ConfigIds, nil
}

// AppendConfigIds adds i to the "config_ids" field.
func (m *CarConfigDownloadMutation) AppendConfigIds(i []int) {
	m.appendconfig_ids = append(m.appendconfig_ids, i...)
}

// AppendedConfigIds returns the list of values that were appended to the "config_ids" field in this mutation.
func (m *CarConfigDownloadMutation) AppendedConfigIds() ([]int, bool) {
	if len(m.appendconfig_ids) == 0 {
		return nil, false
	}
	return m.appendconfig_ids, true
}

// ResetConfigIds resets all changes to the "config_ids" field.
func (m *CarConfigDownloadMutation) ResetConfigIds() {
	m.config_ids = nil
	m.appendconfig_ids = nil
}

// SetRemark sets the "remark" field.
func (m *CarConfigDownloadMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CarConfigDownloadMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CarConfigDownloadMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarConfigDownloadMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarConfigDownloadMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarConfigDownloadMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarConfigDownloadMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarConfigDownloadMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarConfigDownload entity.
// If the CarConfigDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigDownloadMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarConfigDownloadMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarConfigDownloadMutation builder.
func (m *CarConfigDownloadMutation) Where(ps ...predicate.CarConfigDownload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarConfigDownloadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarConfigDownloadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarConfigDownload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarConfigDownloadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarConfigDownloadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarConfigDownload).
func (m *CarConfigDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarConfigDownloadMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uuid != nil {
		fields = append(fields, carconfigdownload.FieldUUID)
	}
	if m.car_id != nil {
		fields = append(fields, carconfigdownload.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carconfigdownload.FieldDeviceID)
	}
	if m.download_state != nil {
		fields = append(fields, carconfigdownload.FieldDownloadState)
	}
	if m.download_process != nil {
		fields = append(fields, carconfigdownload.FieldDownloadProcess)
	}
	if m.config_ids != nil {
		fields = append(fields, carconfigdownload.FieldConfigIds)
	}
	if m.remark != nil {
		fields = append(fields, carconfigdownload.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, carconfigdownload.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carconfigdownload.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarConfigDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carconfigdownload.FieldUUID:
		return m.UUID()
	case carconfigdownload.FieldCarID:
		return m.CarID()
	case carconfigdownload.FieldDeviceID:
		return m.DeviceID()
	case carconfigdownload.FieldDownloadState:
		return m.DownloadState()
	case carconfigdownload.FieldDownloadProcess:
		return m.DownloadProcess()
	case carconfigdownload.FieldConfigIds:
		return m.ConfigIds()
	case carconfigdownload.FieldRemark:
		return m.Remark()
	case carconfigdownload.FieldCreateTime:
		return m.CreateTime()
	case carconfigdownload.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarConfigDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carconfigdownload.FieldUUID:
		return m.OldUUID(ctx)
	case carconfigdownload.FieldCarID:
		return m.OldCarID(ctx)
	case carconfigdownload.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carconfigdownload.FieldDownloadState:
		return m.OldDownloadState(ctx)
	case carconfigdownload.FieldDownloadProcess:
		return m.OldDownloadProcess(ctx)
	case carconfigdownload.FieldConfigIds:
		return m.OldConfigIds(ctx)
	case carconfigdownload.FieldRemark:
		return m.OldRemark(ctx)
	case carconfigdownload.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carconfigdownload.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarConfigDownload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carconfigdownload.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case carconfigdownload.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carconfigdownload.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carconfigdownload.FieldDownloadState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadState(v)
		return nil
	case carconfigdownload.FieldDownloadProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadProcess(v)
		return nil
	case carconfigdownload.FieldConfigIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigIds(v)
		return nil
	case carconfigdownload.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case carconfigdownload.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carconfigdownload.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarConfigDownloadMutation) AddedFields() []string {
	var fields []string
	if m.adduuid != nil {
		fields = append(fields, carconfigdownload.FieldUUID)
	}
	if m.addcar_id != nil {
		fields = append(fields, carconfigdownload.FieldCarID)
	}
	if m.adddownload_process != nil {
		fields = append(fields, carconfigdownload.FieldDownloadProcess)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarConfigDownloadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carconfigdownload.FieldUUID:
		return m.AddedUUID()
	case carconfigdownload.FieldCarID:
		return m.AddedCarID()
	case carconfigdownload.FieldDownloadProcess:
		return m.AddedDownloadProcess()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carconfigdownload.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUUID(v)
		return nil
	case carconfigdownload.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case carconfigdownload.FieldDownloadProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadProcess(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarConfigDownloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarConfigDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarConfigDownloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarConfigDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarConfigDownloadMutation) ResetField(name string) error {
	switch name {
	case carconfigdownload.FieldUUID:
		m.ResetUUID()
		return nil
	case carconfigdownload.FieldCarID:
		m.ResetCarID()
		return nil
	case carconfigdownload.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carconfigdownload.FieldDownloadState:
		m.ResetDownloadState()
		return nil
	case carconfigdownload.FieldDownloadProcess:
		m.ResetDownloadProcess()
		return nil
	case carconfigdownload.FieldConfigIds:
		m.ResetConfigIds()
		return nil
	case carconfigdownload.FieldRemark:
		m.ResetRemark()
		return nil
	case carconfigdownload.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carconfigdownload.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarConfigDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarConfigDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarConfigDownloadMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarConfigDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarConfigDownloadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarConfigDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarConfigDownloadMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarConfigDownloadMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarConfigDownload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarConfigDownloadMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarConfigDownload edge %s", name)
}

// CarConfigPackMutation represents an operation that mutates the CarConfigPack nodes in the graph.
type CarConfigPackMutation struct {
	config
	op                Op
	typ               string
	id                *int
	scenic_area_id    *int
	addscenic_area_id *int
	model_id          *int
	addmodel_id       *int
	car_id            *int
	addcar_id         *int
	car_version       *string
	name              *string
	remark            *string
	version           *string
	config_ids        *[]int
	appendconfig_ids  []int
	create_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*CarConfigPack, error)
	predicates        []predicate.CarConfigPack
}

var _ ent.Mutation = (*CarConfigPackMutation)(nil)

// carconfigpackOption allows management of the mutation configuration using functional options.
type carconfigpackOption func(*CarConfigPackMutation)

// newCarConfigPackMutation creates new mutation for the CarConfigPack entity.
func newCarConfigPackMutation(c config, op Op, opts ...carconfigpackOption) *CarConfigPackMutation {
	m := &CarConfigPackMutation{
		config:        c,
		op:            op,
		typ:           TypeCarConfigPack,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarConfigPackID sets the ID field of the mutation.
func withCarConfigPackID(id int) carconfigpackOption {
	return func(m *CarConfigPackMutation) {
		var (
			err   error
			once  sync.Once
			value *CarConfigPack
		)
		m.oldValue = func(ctx context.Context) (*CarConfigPack, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarConfigPack.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarConfigPack sets the old CarConfigPack of the mutation.
func withCarConfigPack(node *CarConfigPack) carconfigpackOption {
	return func(m *CarConfigPackMutation) {
		m.oldValue = func(context.Context) (*CarConfigPack, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarConfigPackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarConfigPackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarConfigPack entities.
func (m *CarConfigPackMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarConfigPackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarConfigPackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarConfigPack.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CarConfigPackMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CarConfigPackMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *CarConfigPackMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *CarConfigPackMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *CarConfigPackMutation) ClearScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	m.clearedFields[carconfigpack.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *CarConfigPackMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[carconfigpack.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CarConfigPackMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	delete(m.clearedFields, carconfigpack.FieldScenicAreaID)
}

// SetModelID sets the "model_id" field.
func (m *CarConfigPackMutation) SetModelID(i int) {
	m.model_id = &i
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CarConfigPackMutation) ModelID() (r int, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldModelID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds i to the "model_id" field.
func (m *CarConfigPackMutation) AddModelID(i int) {
	if m.addmodel_id != nil {
		*m.addmodel_id += i
	} else {
		m.addmodel_id = &i
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *CarConfigPackMutation) AddedModelID() (r int, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearModelID clears the value of the "model_id" field.
func (m *CarConfigPackMutation) ClearModelID() {
	m.model_id = nil
	m.addmodel_id = nil
	m.clearedFields[carconfigpack.FieldModelID] = struct{}{}
}

// ModelIDCleared returns if the "model_id" field was cleared in this mutation.
func (m *CarConfigPackMutation) ModelIDCleared() bool {
	_, ok := m.clearedFields[carconfigpack.FieldModelID]
	return ok
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CarConfigPackMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
	delete(m.clearedFields, carconfigpack.FieldModelID)
}

// SetCarID sets the "car_id" field.
func (m *CarConfigPackMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarConfigPackMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldCarID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarConfigPackMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarConfigPackMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarID clears the value of the "car_id" field.
func (m *CarConfigPackMutation) ClearCarID() {
	m.car_id = nil
	m.addcar_id = nil
	m.clearedFields[carconfigpack.FieldCarID] = struct{}{}
}

// CarIDCleared returns if the "car_id" field was cleared in this mutation.
func (m *CarConfigPackMutation) CarIDCleared() bool {
	_, ok := m.clearedFields[carconfigpack.FieldCarID]
	return ok
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarConfigPackMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
	delete(m.clearedFields, carconfigpack.FieldCarID)
}

// SetCarVersion sets the "car_version" field.
func (m *CarConfigPackMutation) SetCarVersion(s string) {
	m.car_version = &s
}

// CarVersion returns the value of the "car_version" field in the mutation.
func (m *CarConfigPackMutation) CarVersion() (r string, exists bool) {
	v := m.car_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCarVersion returns the old "car_version" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldCarVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarVersion: %w", err)
	}
	return oldValue.CarVersion, nil
}

// ResetCarVersion resets all changes to the "car_version" field.
func (m *CarConfigPackMutation) ResetCarVersion() {
	m.car_version = nil
}

// SetName sets the "name" field.
func (m *CarConfigPackMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarConfigPackMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarConfigPackMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *CarConfigPackMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CarConfigPackMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CarConfigPackMutation) ResetRemark() {
	m.remark = nil
}

// SetVersion sets the "version" field.
func (m *CarConfigPackMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *CarConfigPackMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *CarConfigPackMutation) ResetVersion() {
	m.version = nil
}

// SetConfigIds sets the "config_ids" field.
func (m *CarConfigPackMutation) SetConfigIds(i []int) {
	m.config_ids = &i
	m.appendconfig_ids = nil
}

// ConfigIds returns the value of the "config_ids" field in the mutation.
func (m *CarConfigPackMutation) ConfigIds() (r []int, exists bool) {
	v := m.config_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigIds returns the old "config_ids" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldConfigIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigIds: %w", err)
	}
	return oldValue.ConfigIds, nil
}

// AppendConfigIds adds i to the "config_ids" field.
func (m *CarConfigPackMutation) AppendConfigIds(i []int) {
	m.appendconfig_ids = append(m.appendconfig_ids, i...)
}

// AppendedConfigIds returns the list of values that were appended to the "config_ids" field in this mutation.
func (m *CarConfigPackMutation) AppendedConfigIds() ([]int, bool) {
	if len(m.appendconfig_ids) == 0 {
		return nil, false
	}
	return m.appendconfig_ids, true
}

// ClearConfigIds clears the value of the "config_ids" field.
func (m *CarConfigPackMutation) ClearConfigIds() {
	m.config_ids = nil
	m.appendconfig_ids = nil
	m.clearedFields[carconfigpack.FieldConfigIds] = struct{}{}
}

// ConfigIdsCleared returns if the "config_ids" field was cleared in this mutation.
func (m *CarConfigPackMutation) ConfigIdsCleared() bool {
	_, ok := m.clearedFields[carconfigpack.FieldConfigIds]
	return ok
}

// ResetConfigIds resets all changes to the "config_ids" field.
func (m *CarConfigPackMutation) ResetConfigIds() {
	m.config_ids = nil
	m.appendconfig_ids = nil
	delete(m.clearedFields, carconfigpack.FieldConfigIds)
}

// SetCreateTime sets the "create_time" field.
func (m *CarConfigPackMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarConfigPackMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarConfigPack entity.
// If the CarConfigPack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigPackMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarConfigPackMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the CarConfigPackMutation builder.
func (m *CarConfigPackMutation) Where(ps ...predicate.CarConfigPack) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarConfigPackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarConfigPackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarConfigPack, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarConfigPackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarConfigPackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarConfigPack).
func (m *CarConfigPackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarConfigPackMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.scenic_area_id != nil {
		fields = append(fields, carconfigpack.FieldScenicAreaID)
	}
	if m.model_id != nil {
		fields = append(fields, carconfigpack.FieldModelID)
	}
	if m.car_id != nil {
		fields = append(fields, carconfigpack.FieldCarID)
	}
	if m.car_version != nil {
		fields = append(fields, carconfigpack.FieldCarVersion)
	}
	if m.name != nil {
		fields = append(fields, carconfigpack.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, carconfigpack.FieldRemark)
	}
	if m.version != nil {
		fields = append(fields, carconfigpack.FieldVersion)
	}
	if m.config_ids != nil {
		fields = append(fields, carconfigpack.FieldConfigIds)
	}
	if m.create_time != nil {
		fields = append(fields, carconfigpack.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarConfigPackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		return m.ScenicAreaID()
	case carconfigpack.FieldModelID:
		return m.ModelID()
	case carconfigpack.FieldCarID:
		return m.CarID()
	case carconfigpack.FieldCarVersion:
		return m.CarVersion()
	case carconfigpack.FieldName:
		return m.Name()
	case carconfigpack.FieldRemark:
		return m.Remark()
	case carconfigpack.FieldVersion:
		return m.Version()
	case carconfigpack.FieldConfigIds:
		return m.ConfigIds()
	case carconfigpack.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarConfigPackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case carconfigpack.FieldModelID:
		return m.OldModelID(ctx)
	case carconfigpack.FieldCarID:
		return m.OldCarID(ctx)
	case carconfigpack.FieldCarVersion:
		return m.OldCarVersion(ctx)
	case carconfigpack.FieldName:
		return m.OldName(ctx)
	case carconfigpack.FieldRemark:
		return m.OldRemark(ctx)
	case carconfigpack.FieldVersion:
		return m.OldVersion(ctx)
	case carconfigpack.FieldConfigIds:
		return m.OldConfigIds(ctx)
	case carconfigpack.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarConfigPack field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigPackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case carconfigpack.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case carconfigpack.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carconfigpack.FieldCarVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarVersion(v)
		return nil
	case carconfigpack.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case carconfigpack.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case carconfigpack.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case carconfigpack.FieldConfigIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigIds(v)
		return nil
	case carconfigpack.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigPack field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarConfigPackMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, carconfigpack.FieldScenicAreaID)
	}
	if m.addmodel_id != nil {
		fields = append(fields, carconfigpack.FieldModelID)
	}
	if m.addcar_id != nil {
		fields = append(fields, carconfigpack.FieldCarID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarConfigPackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case carconfigpack.FieldModelID:
		return m.AddedModelID()
	case carconfigpack.FieldCarID:
		return m.AddedCarID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigPackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case carconfigpack.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case carconfigpack.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigPack numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarConfigPackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carconfigpack.FieldScenicAreaID) {
		fields = append(fields, carconfigpack.FieldScenicAreaID)
	}
	if m.FieldCleared(carconfigpack.FieldModelID) {
		fields = append(fields, carconfigpack.FieldModelID)
	}
	if m.FieldCleared(carconfigpack.FieldCarID) {
		fields = append(fields, carconfigpack.FieldCarID)
	}
	if m.FieldCleared(carconfigpack.FieldConfigIds) {
		fields = append(fields, carconfigpack.FieldConfigIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarConfigPackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarConfigPackMutation) ClearField(name string) error {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case carconfigpack.FieldModelID:
		m.ClearModelID()
		return nil
	case carconfigpack.FieldCarID:
		m.ClearCarID()
		return nil
	case carconfigpack.FieldConfigIds:
		m.ClearConfigIds()
		return nil
	}
	return fmt.Errorf("unknown CarConfigPack nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarConfigPackMutation) ResetField(name string) error {
	switch name {
	case carconfigpack.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case carconfigpack.FieldModelID:
		m.ResetModelID()
		return nil
	case carconfigpack.FieldCarID:
		m.ResetCarID()
		return nil
	case carconfigpack.FieldCarVersion:
		m.ResetCarVersion()
		return nil
	case carconfigpack.FieldName:
		m.ResetName()
		return nil
	case carconfigpack.FieldRemark:
		m.ResetRemark()
		return nil
	case carconfigpack.FieldVersion:
		m.ResetVersion()
		return nil
	case carconfigpack.FieldConfigIds:
		m.ResetConfigIds()
		return nil
	case carconfigpack.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown CarConfigPack field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarConfigPackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarConfigPackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarConfigPackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarConfigPackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarConfigPackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarConfigPackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarConfigPackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarConfigPack unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarConfigPackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarConfigPack edge %s", name)
}

// CarConfigStatusMutation represents an operation that mutates the CarConfigStatus nodes in the graph.
type CarConfigStatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	car_id        *int
	addcar_id     *int
	device_id     *string
	config_path   *string
	version       *string
	remark        *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CarConfigStatus, error)
	predicates    []predicate.CarConfigStatus
}

var _ ent.Mutation = (*CarConfigStatusMutation)(nil)

// carconfigstatusOption allows management of the mutation configuration using functional options.
type carconfigstatusOption func(*CarConfigStatusMutation)

// newCarConfigStatusMutation creates new mutation for the CarConfigStatus entity.
func newCarConfigStatusMutation(c config, op Op, opts ...carconfigstatusOption) *CarConfigStatusMutation {
	m := &CarConfigStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeCarConfigStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarConfigStatusID sets the ID field of the mutation.
func withCarConfigStatusID(id int) carconfigstatusOption {
	return func(m *CarConfigStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *CarConfigStatus
		)
		m.oldValue = func(ctx context.Context) (*CarConfigStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarConfigStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarConfigStatus sets the old CarConfigStatus of the mutation.
func withCarConfigStatus(node *CarConfigStatus) carconfigstatusOption {
	return func(m *CarConfigStatusMutation) {
		m.oldValue = func(context.Context) (*CarConfigStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarConfigStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarConfigStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarConfigStatus entities.
func (m *CarConfigStatusMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarConfigStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarConfigStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarConfigStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCarID sets the "car_id" field.
func (m *CarConfigStatusMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarConfigStatusMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarConfigStatusMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarConfigStatusMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarConfigStatusMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarConfigStatusMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarConfigStatusMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarConfigStatusMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetConfigPath sets the "config_path" field.
func (m *CarConfigStatusMutation) SetConfigPath(s string) {
	m.config_path = &s
}

// ConfigPath returns the value of the "config_path" field in the mutation.
func (m *CarConfigStatusMutation) ConfigPath() (r string, exists bool) {
	v := m.config_path
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigPath returns the old "config_path" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldConfigPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigPath: %w", err)
	}
	return oldValue.ConfigPath, nil
}

// ResetConfigPath resets all changes to the "config_path" field.
func (m *CarConfigStatusMutation) ResetConfigPath() {
	m.config_path = nil
}

// SetVersion sets the "version" field.
func (m *CarConfigStatusMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *CarConfigStatusMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *CarConfigStatusMutation) ResetVersion() {
	m.version = nil
}

// SetRemark sets the "remark" field.
func (m *CarConfigStatusMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CarConfigStatusMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CarConfigStatusMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarConfigStatusMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarConfigStatusMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarConfigStatusMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarConfigStatusMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarConfigStatusMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarConfigStatus entity.
// If the CarConfigStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarConfigStatusMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarConfigStatusMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarConfigStatusMutation builder.
func (m *CarConfigStatusMutation) Where(ps ...predicate.CarConfigStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarConfigStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarConfigStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarConfigStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarConfigStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarConfigStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarConfigStatus).
func (m *CarConfigStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarConfigStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.car_id != nil {
		fields = append(fields, carconfigstatus.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carconfigstatus.FieldDeviceID)
	}
	if m.config_path != nil {
		fields = append(fields, carconfigstatus.FieldConfigPath)
	}
	if m.version != nil {
		fields = append(fields, carconfigstatus.FieldVersion)
	}
	if m.remark != nil {
		fields = append(fields, carconfigstatus.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, carconfigstatus.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carconfigstatus.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarConfigStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carconfigstatus.FieldCarID:
		return m.CarID()
	case carconfigstatus.FieldDeviceID:
		return m.DeviceID()
	case carconfigstatus.FieldConfigPath:
		return m.ConfigPath()
	case carconfigstatus.FieldVersion:
		return m.Version()
	case carconfigstatus.FieldRemark:
		return m.Remark()
	case carconfigstatus.FieldCreateTime:
		return m.CreateTime()
	case carconfigstatus.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarConfigStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carconfigstatus.FieldCarID:
		return m.OldCarID(ctx)
	case carconfigstatus.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carconfigstatus.FieldConfigPath:
		return m.OldConfigPath(ctx)
	case carconfigstatus.FieldVersion:
		return m.OldVersion(ctx)
	case carconfigstatus.FieldRemark:
		return m.OldRemark(ctx)
	case carconfigstatus.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carconfigstatus.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarConfigStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carconfigstatus.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carconfigstatus.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carconfigstatus.FieldConfigPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigPath(v)
		return nil
	case carconfigstatus.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case carconfigstatus.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case carconfigstatus.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carconfigstatus.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarConfigStatusMutation) AddedFields() []string {
	var fields []string
	if m.addcar_id != nil {
		fields = append(fields, carconfigstatus.FieldCarID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarConfigStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carconfigstatus.FieldCarID:
		return m.AddedCarID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarConfigStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carconfigstatus.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	}
	return fmt.Errorf("unknown CarConfigStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarConfigStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarConfigStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarConfigStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarConfigStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarConfigStatusMutation) ResetField(name string) error {
	switch name {
	case carconfigstatus.FieldCarID:
		m.ResetCarID()
		return nil
	case carconfigstatus.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carconfigstatus.FieldConfigPath:
		m.ResetConfigPath()
		return nil
	case carconfigstatus.FieldVersion:
		m.ResetVersion()
		return nil
	case carconfigstatus.FieldRemark:
		m.ResetRemark()
		return nil
	case carconfigstatus.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carconfigstatus.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarConfigStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarConfigStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarConfigStatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarConfigStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarConfigStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarConfigStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarConfigStatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarConfigStatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarConfigStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarConfigStatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarConfigStatus edge %s", name)
}

// CarCumulativeMutation represents an operation that mutates the CarCumulative nodes in the graph.
type CarCumulativeMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	car_id                       *int
	addcar_id                    *int
	device_id                    *string
	operation_lock_duration      *float32
	addoperation_lock_duration   *float32
	operation_manual_duration    *float32
	addoperation_manual_duration *float32
	operation_auto_duration      *float32
	addoperation_auto_duration   *float32
	operation_fault_duration     *float32
	addoperation_fault_duration  *float32
	operation_lock_times         *uint32
	addoperation_lock_times      *int32
	operation_manual_times       *uint32
	addoperation_manual_times    *int32
	operation_auto_times         *uint32
	addoperation_auto_times      *int32
	operation_fault_times        *uint32
	addoperation_fault_times     *int32
	operation_manual_mileage     *float32
	addoperation_manual_mileage  *float32
	operation_auto_mileage       *float32
	addoperation_auto_mileage    *float32
	maintain_lock_duration       *float32
	addmaintain_lock_duration    *float32
	maintain_manual_duration     *float32
	addmaintain_manual_duration  *float32
	maintain_auto_duration       *float32
	addmaintain_auto_duration    *float32
	maintain_remote_duration     *float32
	addmaintain_remote_duration  *float32
	maintain_fault_duration      *float32
	addmaintain_fault_duration   *float32
	maintain_lock_times          *uint32
	addmaintain_lock_times       *int32
	maintain_manual_times        *uint32
	addmaintain_manual_times     *int32
	maintain_auto_times          *uint32
	addmaintain_auto_times       *int32
	maintain_remote_times        *uint32
	addmaintain_remote_times     *int32
	maintain_fault_times         *uint32
	addmaintain_fault_times      *int32
	maintain_manual_mileage      *float32
	addmaintain_manual_mileage   *float32
	maintain_auto_mileage        *float32
	addmaintain_auto_mileage     *float32
	maintain_remote_mileage      *float32
	addmaintain_remote_mileage   *float32
	alarm_times                  *uint32
	addalarm_times               *int32
	create_time                  *time.Time
	update_time                  *time.Time
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*CarCumulative, error)
	predicates                   []predicate.CarCumulative
}

var _ ent.Mutation = (*CarCumulativeMutation)(nil)

// carcumulativeOption allows management of the mutation configuration using functional options.
type carcumulativeOption func(*CarCumulativeMutation)

// newCarCumulativeMutation creates new mutation for the CarCumulative entity.
func newCarCumulativeMutation(c config, op Op, opts ...carcumulativeOption) *CarCumulativeMutation {
	m := &CarCumulativeMutation{
		config:        c,
		op:            op,
		typ:           TypeCarCumulative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarCumulativeID sets the ID field of the mutation.
func withCarCumulativeID(id int) carcumulativeOption {
	return func(m *CarCumulativeMutation) {
		var (
			err   error
			once  sync.Once
			value *CarCumulative
		)
		m.oldValue = func(ctx context.Context) (*CarCumulative, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarCumulative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarCumulative sets the old CarCumulative of the mutation.
func withCarCumulative(node *CarCumulative) carcumulativeOption {
	return func(m *CarCumulativeMutation) {
		m.oldValue = func(context.Context) (*CarCumulative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarCumulativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarCumulativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarCumulative entities.
func (m *CarCumulativeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarCumulativeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarCumulativeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarCumulative.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCarID sets the "car_id" field.
func (m *CarCumulativeMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarCumulativeMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarCumulativeMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarCumulativeMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarCumulativeMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarCumulativeMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarCumulativeMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarCumulativeMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetOperationLockDuration sets the "operation_lock_duration" field.
func (m *CarCumulativeMutation) SetOperationLockDuration(f float32) {
	m.operation_lock_duration = &f
	m.addoperation_lock_duration = nil
}

// OperationLockDuration returns the value of the "operation_lock_duration" field in the mutation.
func (m *CarCumulativeMutation) OperationLockDuration() (r float32, exists bool) {
	v := m.operation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockDuration returns the old "operation_lock_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockDuration: %w", err)
	}
	return oldValue.OperationLockDuration, nil
}

// AddOperationLockDuration adds f to the "operation_lock_duration" field.
func (m *CarCumulativeMutation) AddOperationLockDuration(f float32) {
	if m.addoperation_lock_duration != nil {
		*m.addoperation_lock_duration += f
	} else {
		m.addoperation_lock_duration = &f
	}
}

// AddedOperationLockDuration returns the value that was added to the "operation_lock_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationLockDuration() (r float32, exists bool) {
	v := m.addoperation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockDuration resets all changes to the "operation_lock_duration" field.
func (m *CarCumulativeMutation) ResetOperationLockDuration() {
	m.operation_lock_duration = nil
	m.addoperation_lock_duration = nil
}

// SetOperationManualDuration sets the "operation_manual_duration" field.
func (m *CarCumulativeMutation) SetOperationManualDuration(f float32) {
	m.operation_manual_duration = &f
	m.addoperation_manual_duration = nil
}

// OperationManualDuration returns the value of the "operation_manual_duration" field in the mutation.
func (m *CarCumulativeMutation) OperationManualDuration() (r float32, exists bool) {
	v := m.operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualDuration returns the old "operation_manual_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualDuration: %w", err)
	}
	return oldValue.OperationManualDuration, nil
}

// AddOperationManualDuration adds f to the "operation_manual_duration" field.
func (m *CarCumulativeMutation) AddOperationManualDuration(f float32) {
	if m.addoperation_manual_duration != nil {
		*m.addoperation_manual_duration += f
	} else {
		m.addoperation_manual_duration = &f
	}
}

// AddedOperationManualDuration returns the value that was added to the "operation_manual_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationManualDuration() (r float32, exists bool) {
	v := m.addoperation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualDuration resets all changes to the "operation_manual_duration" field.
func (m *CarCumulativeMutation) ResetOperationManualDuration() {
	m.operation_manual_duration = nil
	m.addoperation_manual_duration = nil
}

// SetOperationAutoDuration sets the "operation_auto_duration" field.
func (m *CarCumulativeMutation) SetOperationAutoDuration(f float32) {
	m.operation_auto_duration = &f
	m.addoperation_auto_duration = nil
}

// OperationAutoDuration returns the value of the "operation_auto_duration" field in the mutation.
func (m *CarCumulativeMutation) OperationAutoDuration() (r float32, exists bool) {
	v := m.operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoDuration returns the old "operation_auto_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoDuration: %w", err)
	}
	return oldValue.OperationAutoDuration, nil
}

// AddOperationAutoDuration adds f to the "operation_auto_duration" field.
func (m *CarCumulativeMutation) AddOperationAutoDuration(f float32) {
	if m.addoperation_auto_duration != nil {
		*m.addoperation_auto_duration += f
	} else {
		m.addoperation_auto_duration = &f
	}
}

// AddedOperationAutoDuration returns the value that was added to the "operation_auto_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationAutoDuration() (r float32, exists bool) {
	v := m.addoperation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoDuration resets all changes to the "operation_auto_duration" field.
func (m *CarCumulativeMutation) ResetOperationAutoDuration() {
	m.operation_auto_duration = nil
	m.addoperation_auto_duration = nil
}

// SetOperationFaultDuration sets the "operation_fault_duration" field.
func (m *CarCumulativeMutation) SetOperationFaultDuration(f float32) {
	m.operation_fault_duration = &f
	m.addoperation_fault_duration = nil
}

// OperationFaultDuration returns the value of the "operation_fault_duration" field in the mutation.
func (m *CarCumulativeMutation) OperationFaultDuration() (r float32, exists bool) {
	v := m.operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultDuration returns the old "operation_fault_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultDuration: %w", err)
	}
	return oldValue.OperationFaultDuration, nil
}

// AddOperationFaultDuration adds f to the "operation_fault_duration" field.
func (m *CarCumulativeMutation) AddOperationFaultDuration(f float32) {
	if m.addoperation_fault_duration != nil {
		*m.addoperation_fault_duration += f
	} else {
		m.addoperation_fault_duration = &f
	}
}

// AddedOperationFaultDuration returns the value that was added to the "operation_fault_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationFaultDuration() (r float32, exists bool) {
	v := m.addoperation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultDuration resets all changes to the "operation_fault_duration" field.
func (m *CarCumulativeMutation) ResetOperationFaultDuration() {
	m.operation_fault_duration = nil
	m.addoperation_fault_duration = nil
}

// SetOperationLockTimes sets the "operation_lock_times" field.
func (m *CarCumulativeMutation) SetOperationLockTimes(u uint32) {
	m.operation_lock_times = &u
	m.addoperation_lock_times = nil
}

// OperationLockTimes returns the value of the "operation_lock_times" field in the mutation.
func (m *CarCumulativeMutation) OperationLockTimes() (r uint32, exists bool) {
	v := m.operation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockTimes returns the old "operation_lock_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockTimes: %w", err)
	}
	return oldValue.OperationLockTimes, nil
}

// AddOperationLockTimes adds u to the "operation_lock_times" field.
func (m *CarCumulativeMutation) AddOperationLockTimes(u int32) {
	if m.addoperation_lock_times != nil {
		*m.addoperation_lock_times += u
	} else {
		m.addoperation_lock_times = &u
	}
}

// AddedOperationLockTimes returns the value that was added to the "operation_lock_times" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationLockTimes() (r int32, exists bool) {
	v := m.addoperation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockTimes resets all changes to the "operation_lock_times" field.
func (m *CarCumulativeMutation) ResetOperationLockTimes() {
	m.operation_lock_times = nil
	m.addoperation_lock_times = nil
}

// SetOperationManualTimes sets the "operation_manual_times" field.
func (m *CarCumulativeMutation) SetOperationManualTimes(u uint32) {
	m.operation_manual_times = &u
	m.addoperation_manual_times = nil
}

// OperationManualTimes returns the value of the "operation_manual_times" field in the mutation.
func (m *CarCumulativeMutation) OperationManualTimes() (r uint32, exists bool) {
	v := m.operation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualTimes returns the old "operation_manual_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualTimes: %w", err)
	}
	return oldValue.OperationManualTimes, nil
}

// AddOperationManualTimes adds u to the "operation_manual_times" field.
func (m *CarCumulativeMutation) AddOperationManualTimes(u int32) {
	if m.addoperation_manual_times != nil {
		*m.addoperation_manual_times += u
	} else {
		m.addoperation_manual_times = &u
	}
}

// AddedOperationManualTimes returns the value that was added to the "operation_manual_times" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationManualTimes() (r int32, exists bool) {
	v := m.addoperation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualTimes resets all changes to the "operation_manual_times" field.
func (m *CarCumulativeMutation) ResetOperationManualTimes() {
	m.operation_manual_times = nil
	m.addoperation_manual_times = nil
}

// SetOperationAutoTimes sets the "operation_auto_times" field.
func (m *CarCumulativeMutation) SetOperationAutoTimes(u uint32) {
	m.operation_auto_times = &u
	m.addoperation_auto_times = nil
}

// OperationAutoTimes returns the value of the "operation_auto_times" field in the mutation.
func (m *CarCumulativeMutation) OperationAutoTimes() (r uint32, exists bool) {
	v := m.operation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoTimes returns the old "operation_auto_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoTimes: %w", err)
	}
	return oldValue.OperationAutoTimes, nil
}

// AddOperationAutoTimes adds u to the "operation_auto_times" field.
func (m *CarCumulativeMutation) AddOperationAutoTimes(u int32) {
	if m.addoperation_auto_times != nil {
		*m.addoperation_auto_times += u
	} else {
		m.addoperation_auto_times = &u
	}
}

// AddedOperationAutoTimes returns the value that was added to the "operation_auto_times" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationAutoTimes() (r int32, exists bool) {
	v := m.addoperation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoTimes resets all changes to the "operation_auto_times" field.
func (m *CarCumulativeMutation) ResetOperationAutoTimes() {
	m.operation_auto_times = nil
	m.addoperation_auto_times = nil
}

// SetOperationFaultTimes sets the "operation_fault_times" field.
func (m *CarCumulativeMutation) SetOperationFaultTimes(u uint32) {
	m.operation_fault_times = &u
	m.addoperation_fault_times = nil
}

// OperationFaultTimes returns the value of the "operation_fault_times" field in the mutation.
func (m *CarCumulativeMutation) OperationFaultTimes() (r uint32, exists bool) {
	v := m.operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultTimes returns the old "operation_fault_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultTimes: %w", err)
	}
	return oldValue.OperationFaultTimes, nil
}

// AddOperationFaultTimes adds u to the "operation_fault_times" field.
func (m *CarCumulativeMutation) AddOperationFaultTimes(u int32) {
	if m.addoperation_fault_times != nil {
		*m.addoperation_fault_times += u
	} else {
		m.addoperation_fault_times = &u
	}
}

// AddedOperationFaultTimes returns the value that was added to the "operation_fault_times" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationFaultTimes() (r int32, exists bool) {
	v := m.addoperation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultTimes resets all changes to the "operation_fault_times" field.
func (m *CarCumulativeMutation) ResetOperationFaultTimes() {
	m.operation_fault_times = nil
	m.addoperation_fault_times = nil
}

// SetOperationManualMileage sets the "operation_manual_mileage" field.
func (m *CarCumulativeMutation) SetOperationManualMileage(f float32) {
	m.operation_manual_mileage = &f
	m.addoperation_manual_mileage = nil
}

// OperationManualMileage returns the value of the "operation_manual_mileage" field in the mutation.
func (m *CarCumulativeMutation) OperationManualMileage() (r float32, exists bool) {
	v := m.operation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualMileage returns the old "operation_manual_mileage" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualMileage: %w", err)
	}
	return oldValue.OperationManualMileage, nil
}

// AddOperationManualMileage adds f to the "operation_manual_mileage" field.
func (m *CarCumulativeMutation) AddOperationManualMileage(f float32) {
	if m.addoperation_manual_mileage != nil {
		*m.addoperation_manual_mileage += f
	} else {
		m.addoperation_manual_mileage = &f
	}
}

// AddedOperationManualMileage returns the value that was added to the "operation_manual_mileage" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationManualMileage() (r float32, exists bool) {
	v := m.addoperation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualMileage resets all changes to the "operation_manual_mileage" field.
func (m *CarCumulativeMutation) ResetOperationManualMileage() {
	m.operation_manual_mileage = nil
	m.addoperation_manual_mileage = nil
}

// SetOperationAutoMileage sets the "operation_auto_mileage" field.
func (m *CarCumulativeMutation) SetOperationAutoMileage(f float32) {
	m.operation_auto_mileage = &f
	m.addoperation_auto_mileage = nil
}

// OperationAutoMileage returns the value of the "operation_auto_mileage" field in the mutation.
func (m *CarCumulativeMutation) OperationAutoMileage() (r float32, exists bool) {
	v := m.operation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoMileage returns the old "operation_auto_mileage" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldOperationAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoMileage: %w", err)
	}
	return oldValue.OperationAutoMileage, nil
}

// AddOperationAutoMileage adds f to the "operation_auto_mileage" field.
func (m *CarCumulativeMutation) AddOperationAutoMileage(f float32) {
	if m.addoperation_auto_mileage != nil {
		*m.addoperation_auto_mileage += f
	} else {
		m.addoperation_auto_mileage = &f
	}
}

// AddedOperationAutoMileage returns the value that was added to the "operation_auto_mileage" field in this mutation.
func (m *CarCumulativeMutation) AddedOperationAutoMileage() (r float32, exists bool) {
	v := m.addoperation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoMileage resets all changes to the "operation_auto_mileage" field.
func (m *CarCumulativeMutation) ResetOperationAutoMileage() {
	m.operation_auto_mileage = nil
	m.addoperation_auto_mileage = nil
}

// SetMaintainLockDuration sets the "maintain_lock_duration" field.
func (m *CarCumulativeMutation) SetMaintainLockDuration(f float32) {
	m.maintain_lock_duration = &f
	m.addmaintain_lock_duration = nil
}

// MaintainLockDuration returns the value of the "maintain_lock_duration" field in the mutation.
func (m *CarCumulativeMutation) MaintainLockDuration() (r float32, exists bool) {
	v := m.maintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockDuration returns the old "maintain_lock_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockDuration: %w", err)
	}
	return oldValue.MaintainLockDuration, nil
}

// AddMaintainLockDuration adds f to the "maintain_lock_duration" field.
func (m *CarCumulativeMutation) AddMaintainLockDuration(f float32) {
	if m.addmaintain_lock_duration != nil {
		*m.addmaintain_lock_duration += f
	} else {
		m.addmaintain_lock_duration = &f
	}
}

// AddedMaintainLockDuration returns the value that was added to the "maintain_lock_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainLockDuration() (r float32, exists bool) {
	v := m.addmaintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockDuration resets all changes to the "maintain_lock_duration" field.
func (m *CarCumulativeMutation) ResetMaintainLockDuration() {
	m.maintain_lock_duration = nil
	m.addmaintain_lock_duration = nil
}

// SetMaintainManualDuration sets the "maintain_manual_duration" field.
func (m *CarCumulativeMutation) SetMaintainManualDuration(f float32) {
	m.maintain_manual_duration = &f
	m.addmaintain_manual_duration = nil
}

// MaintainManualDuration returns the value of the "maintain_manual_duration" field in the mutation.
func (m *CarCumulativeMutation) MaintainManualDuration() (r float32, exists bool) {
	v := m.maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualDuration returns the old "maintain_manual_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualDuration: %w", err)
	}
	return oldValue.MaintainManualDuration, nil
}

// AddMaintainManualDuration adds f to the "maintain_manual_duration" field.
func (m *CarCumulativeMutation) AddMaintainManualDuration(f float32) {
	if m.addmaintain_manual_duration != nil {
		*m.addmaintain_manual_duration += f
	} else {
		m.addmaintain_manual_duration = &f
	}
}

// AddedMaintainManualDuration returns the value that was added to the "maintain_manual_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainManualDuration() (r float32, exists bool) {
	v := m.addmaintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualDuration resets all changes to the "maintain_manual_duration" field.
func (m *CarCumulativeMutation) ResetMaintainManualDuration() {
	m.maintain_manual_duration = nil
	m.addmaintain_manual_duration = nil
}

// SetMaintainAutoDuration sets the "maintain_auto_duration" field.
func (m *CarCumulativeMutation) SetMaintainAutoDuration(f float32) {
	m.maintain_auto_duration = &f
	m.addmaintain_auto_duration = nil
}

// MaintainAutoDuration returns the value of the "maintain_auto_duration" field in the mutation.
func (m *CarCumulativeMutation) MaintainAutoDuration() (r float32, exists bool) {
	v := m.maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoDuration returns the old "maintain_auto_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoDuration: %w", err)
	}
	return oldValue.MaintainAutoDuration, nil
}

// AddMaintainAutoDuration adds f to the "maintain_auto_duration" field.
func (m *CarCumulativeMutation) AddMaintainAutoDuration(f float32) {
	if m.addmaintain_auto_duration != nil {
		*m.addmaintain_auto_duration += f
	} else {
		m.addmaintain_auto_duration = &f
	}
}

// AddedMaintainAutoDuration returns the value that was added to the "maintain_auto_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainAutoDuration() (r float32, exists bool) {
	v := m.addmaintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoDuration resets all changes to the "maintain_auto_duration" field.
func (m *CarCumulativeMutation) ResetMaintainAutoDuration() {
	m.maintain_auto_duration = nil
	m.addmaintain_auto_duration = nil
}

// SetMaintainRemoteDuration sets the "maintain_remote_duration" field.
func (m *CarCumulativeMutation) SetMaintainRemoteDuration(f float32) {
	m.maintain_remote_duration = &f
	m.addmaintain_remote_duration = nil
}

// MaintainRemoteDuration returns the value of the "maintain_remote_duration" field in the mutation.
func (m *CarCumulativeMutation) MaintainRemoteDuration() (r float32, exists bool) {
	v := m.maintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteDuration returns the old "maintain_remote_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainRemoteDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteDuration: %w", err)
	}
	return oldValue.MaintainRemoteDuration, nil
}

// AddMaintainRemoteDuration adds f to the "maintain_remote_duration" field.
func (m *CarCumulativeMutation) AddMaintainRemoteDuration(f float32) {
	if m.addmaintain_remote_duration != nil {
		*m.addmaintain_remote_duration += f
	} else {
		m.addmaintain_remote_duration = &f
	}
}

// AddedMaintainRemoteDuration returns the value that was added to the "maintain_remote_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainRemoteDuration() (r float32, exists bool) {
	v := m.addmaintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteDuration resets all changes to the "maintain_remote_duration" field.
func (m *CarCumulativeMutation) ResetMaintainRemoteDuration() {
	m.maintain_remote_duration = nil
	m.addmaintain_remote_duration = nil
}

// SetMaintainFaultDuration sets the "maintain_fault_duration" field.
func (m *CarCumulativeMutation) SetMaintainFaultDuration(f float32) {
	m.maintain_fault_duration = &f
	m.addmaintain_fault_duration = nil
}

// MaintainFaultDuration returns the value of the "maintain_fault_duration" field in the mutation.
func (m *CarCumulativeMutation) MaintainFaultDuration() (r float32, exists bool) {
	v := m.maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultDuration returns the old "maintain_fault_duration" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultDuration: %w", err)
	}
	return oldValue.MaintainFaultDuration, nil
}

// AddMaintainFaultDuration adds f to the "maintain_fault_duration" field.
func (m *CarCumulativeMutation) AddMaintainFaultDuration(f float32) {
	if m.addmaintain_fault_duration != nil {
		*m.addmaintain_fault_duration += f
	} else {
		m.addmaintain_fault_duration = &f
	}
}

// AddedMaintainFaultDuration returns the value that was added to the "maintain_fault_duration" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainFaultDuration() (r float32, exists bool) {
	v := m.addmaintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultDuration resets all changes to the "maintain_fault_duration" field.
func (m *CarCumulativeMutation) ResetMaintainFaultDuration() {
	m.maintain_fault_duration = nil
	m.addmaintain_fault_duration = nil
}

// SetMaintainLockTimes sets the "maintain_lock_times" field.
func (m *CarCumulativeMutation) SetMaintainLockTimes(u uint32) {
	m.maintain_lock_times = &u
	m.addmaintain_lock_times = nil
}

// MaintainLockTimes returns the value of the "maintain_lock_times" field in the mutation.
func (m *CarCumulativeMutation) MaintainLockTimes() (r uint32, exists bool) {
	v := m.maintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockTimes returns the old "maintain_lock_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockTimes: %w", err)
	}
	return oldValue.MaintainLockTimes, nil
}

// AddMaintainLockTimes adds u to the "maintain_lock_times" field.
func (m *CarCumulativeMutation) AddMaintainLockTimes(u int32) {
	if m.addmaintain_lock_times != nil {
		*m.addmaintain_lock_times += u
	} else {
		m.addmaintain_lock_times = &u
	}
}

// AddedMaintainLockTimes returns the value that was added to the "maintain_lock_times" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainLockTimes() (r int32, exists bool) {
	v := m.addmaintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockTimes resets all changes to the "maintain_lock_times" field.
func (m *CarCumulativeMutation) ResetMaintainLockTimes() {
	m.maintain_lock_times = nil
	m.addmaintain_lock_times = nil
}

// SetMaintainManualTimes sets the "maintain_manual_times" field.
func (m *CarCumulativeMutation) SetMaintainManualTimes(u uint32) {
	m.maintain_manual_times = &u
	m.addmaintain_manual_times = nil
}

// MaintainManualTimes returns the value of the "maintain_manual_times" field in the mutation.
func (m *CarCumulativeMutation) MaintainManualTimes() (r uint32, exists bool) {
	v := m.maintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualTimes returns the old "maintain_manual_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualTimes: %w", err)
	}
	return oldValue.MaintainManualTimes, nil
}

// AddMaintainManualTimes adds u to the "maintain_manual_times" field.
func (m *CarCumulativeMutation) AddMaintainManualTimes(u int32) {
	if m.addmaintain_manual_times != nil {
		*m.addmaintain_manual_times += u
	} else {
		m.addmaintain_manual_times = &u
	}
}

// AddedMaintainManualTimes returns the value that was added to the "maintain_manual_times" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainManualTimes() (r int32, exists bool) {
	v := m.addmaintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualTimes resets all changes to the "maintain_manual_times" field.
func (m *CarCumulativeMutation) ResetMaintainManualTimes() {
	m.maintain_manual_times = nil
	m.addmaintain_manual_times = nil
}

// SetMaintainAutoTimes sets the "maintain_auto_times" field.
func (m *CarCumulativeMutation) SetMaintainAutoTimes(u uint32) {
	m.maintain_auto_times = &u
	m.addmaintain_auto_times = nil
}

// MaintainAutoTimes returns the value of the "maintain_auto_times" field in the mutation.
func (m *CarCumulativeMutation) MaintainAutoTimes() (r uint32, exists bool) {
	v := m.maintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoTimes returns the old "maintain_auto_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoTimes: %w", err)
	}
	return oldValue.MaintainAutoTimes, nil
}

// AddMaintainAutoTimes adds u to the "maintain_auto_times" field.
func (m *CarCumulativeMutation) AddMaintainAutoTimes(u int32) {
	if m.addmaintain_auto_times != nil {
		*m.addmaintain_auto_times += u
	} else {
		m.addmaintain_auto_times = &u
	}
}

// AddedMaintainAutoTimes returns the value that was added to the "maintain_auto_times" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainAutoTimes() (r int32, exists bool) {
	v := m.addmaintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoTimes resets all changes to the "maintain_auto_times" field.
func (m *CarCumulativeMutation) ResetMaintainAutoTimes() {
	m.maintain_auto_times = nil
	m.addmaintain_auto_times = nil
}

// SetMaintainRemoteTimes sets the "maintain_remote_times" field.
func (m *CarCumulativeMutation) SetMaintainRemoteTimes(u uint32) {
	m.maintain_remote_times = &u
	m.addmaintain_remote_times = nil
}

// MaintainRemoteTimes returns the value of the "maintain_remote_times" field in the mutation.
func (m *CarCumulativeMutation) MaintainRemoteTimes() (r uint32, exists bool) {
	v := m.maintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteTimes returns the old "maintain_remote_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainRemoteTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteTimes: %w", err)
	}
	return oldValue.MaintainRemoteTimes, nil
}

// AddMaintainRemoteTimes adds u to the "maintain_remote_times" field.
func (m *CarCumulativeMutation) AddMaintainRemoteTimes(u int32) {
	if m.addmaintain_remote_times != nil {
		*m.addmaintain_remote_times += u
	} else {
		m.addmaintain_remote_times = &u
	}
}

// AddedMaintainRemoteTimes returns the value that was added to the "maintain_remote_times" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainRemoteTimes() (r int32, exists bool) {
	v := m.addmaintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteTimes resets all changes to the "maintain_remote_times" field.
func (m *CarCumulativeMutation) ResetMaintainRemoteTimes() {
	m.maintain_remote_times = nil
	m.addmaintain_remote_times = nil
}

// SetMaintainFaultTimes sets the "maintain_fault_times" field.
func (m *CarCumulativeMutation) SetMaintainFaultTimes(u uint32) {
	m.maintain_fault_times = &u
	m.addmaintain_fault_times = nil
}

// MaintainFaultTimes returns the value of the "maintain_fault_times" field in the mutation.
func (m *CarCumulativeMutation) MaintainFaultTimes() (r uint32, exists bool) {
	v := m.maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultTimes returns the old "maintain_fault_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultTimes: %w", err)
	}
	return oldValue.MaintainFaultTimes, nil
}

// AddMaintainFaultTimes adds u to the "maintain_fault_times" field.
func (m *CarCumulativeMutation) AddMaintainFaultTimes(u int32) {
	if m.addmaintain_fault_times != nil {
		*m.addmaintain_fault_times += u
	} else {
		m.addmaintain_fault_times = &u
	}
}

// AddedMaintainFaultTimes returns the value that was added to the "maintain_fault_times" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainFaultTimes() (r int32, exists bool) {
	v := m.addmaintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultTimes resets all changes to the "maintain_fault_times" field.
func (m *CarCumulativeMutation) ResetMaintainFaultTimes() {
	m.maintain_fault_times = nil
	m.addmaintain_fault_times = nil
}

// SetMaintainManualMileage sets the "maintain_manual_mileage" field.
func (m *CarCumulativeMutation) SetMaintainManualMileage(f float32) {
	m.maintain_manual_mileage = &f
	m.addmaintain_manual_mileage = nil
}

// MaintainManualMileage returns the value of the "maintain_manual_mileage" field in the mutation.
func (m *CarCumulativeMutation) MaintainManualMileage() (r float32, exists bool) {
	v := m.maintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualMileage returns the old "maintain_manual_mileage" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualMileage: %w", err)
	}
	return oldValue.MaintainManualMileage, nil
}

// AddMaintainManualMileage adds f to the "maintain_manual_mileage" field.
func (m *CarCumulativeMutation) AddMaintainManualMileage(f float32) {
	if m.addmaintain_manual_mileage != nil {
		*m.addmaintain_manual_mileage += f
	} else {
		m.addmaintain_manual_mileage = &f
	}
}

// AddedMaintainManualMileage returns the value that was added to the "maintain_manual_mileage" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainManualMileage() (r float32, exists bool) {
	v := m.addmaintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualMileage resets all changes to the "maintain_manual_mileage" field.
func (m *CarCumulativeMutation) ResetMaintainManualMileage() {
	m.maintain_manual_mileage = nil
	m.addmaintain_manual_mileage = nil
}

// SetMaintainAutoMileage sets the "maintain_auto_mileage" field.
func (m *CarCumulativeMutation) SetMaintainAutoMileage(f float32) {
	m.maintain_auto_mileage = &f
	m.addmaintain_auto_mileage = nil
}

// MaintainAutoMileage returns the value of the "maintain_auto_mileage" field in the mutation.
func (m *CarCumulativeMutation) MaintainAutoMileage() (r float32, exists bool) {
	v := m.maintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoMileage returns the old "maintain_auto_mileage" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoMileage: %w", err)
	}
	return oldValue.MaintainAutoMileage, nil
}

// AddMaintainAutoMileage adds f to the "maintain_auto_mileage" field.
func (m *CarCumulativeMutation) AddMaintainAutoMileage(f float32) {
	if m.addmaintain_auto_mileage != nil {
		*m.addmaintain_auto_mileage += f
	} else {
		m.addmaintain_auto_mileage = &f
	}
}

// AddedMaintainAutoMileage returns the value that was added to the "maintain_auto_mileage" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainAutoMileage() (r float32, exists bool) {
	v := m.addmaintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoMileage resets all changes to the "maintain_auto_mileage" field.
func (m *CarCumulativeMutation) ResetMaintainAutoMileage() {
	m.maintain_auto_mileage = nil
	m.addmaintain_auto_mileage = nil
}

// SetMaintainRemoteMileage sets the "maintain_remote_mileage" field.
func (m *CarCumulativeMutation) SetMaintainRemoteMileage(f float32) {
	m.maintain_remote_mileage = &f
	m.addmaintain_remote_mileage = nil
}

// MaintainRemoteMileage returns the value of the "maintain_remote_mileage" field in the mutation.
func (m *CarCumulativeMutation) MaintainRemoteMileage() (r float32, exists bool) {
	v := m.maintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteMileage returns the old "maintain_remote_mileage" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldMaintainRemoteMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteMileage: %w", err)
	}
	return oldValue.MaintainRemoteMileage, nil
}

// AddMaintainRemoteMileage adds f to the "maintain_remote_mileage" field.
func (m *CarCumulativeMutation) AddMaintainRemoteMileage(f float32) {
	if m.addmaintain_remote_mileage != nil {
		*m.addmaintain_remote_mileage += f
	} else {
		m.addmaintain_remote_mileage = &f
	}
}

// AddedMaintainRemoteMileage returns the value that was added to the "maintain_remote_mileage" field in this mutation.
func (m *CarCumulativeMutation) AddedMaintainRemoteMileage() (r float32, exists bool) {
	v := m.addmaintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteMileage resets all changes to the "maintain_remote_mileage" field.
func (m *CarCumulativeMutation) ResetMaintainRemoteMileage() {
	m.maintain_remote_mileage = nil
	m.addmaintain_remote_mileage = nil
}

// SetAlarmTimes sets the "alarm_times" field.
func (m *CarCumulativeMutation) SetAlarmTimes(u uint32) {
	m.alarm_times = &u
	m.addalarm_times = nil
}

// AlarmTimes returns the value of the "alarm_times" field in the mutation.
func (m *CarCumulativeMutation) AlarmTimes() (r uint32, exists bool) {
	v := m.alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmTimes returns the old "alarm_times" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldAlarmTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmTimes: %w", err)
	}
	return oldValue.AlarmTimes, nil
}

// AddAlarmTimes adds u to the "alarm_times" field.
func (m *CarCumulativeMutation) AddAlarmTimes(u int32) {
	if m.addalarm_times != nil {
		*m.addalarm_times += u
	} else {
		m.addalarm_times = &u
	}
}

// AddedAlarmTimes returns the value that was added to the "alarm_times" field in this mutation.
func (m *CarCumulativeMutation) AddedAlarmTimes() (r int32, exists bool) {
	v := m.addalarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlarmTimes resets all changes to the "alarm_times" field.
func (m *CarCumulativeMutation) ResetAlarmTimes() {
	m.alarm_times = nil
	m.addalarm_times = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarCumulativeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarCumulativeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarCumulativeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarCumulativeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarCumulativeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarCumulative entity.
// If the CarCumulative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarCumulativeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarCumulativeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarCumulativeMutation builder.
func (m *CarCumulativeMutation) Where(ps ...predicate.CarCumulative) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarCumulativeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarCumulativeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarCumulative, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarCumulativeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarCumulativeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarCumulative).
func (m *CarCumulativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarCumulativeMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.car_id != nil {
		fields = append(fields, carcumulative.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carcumulative.FieldDeviceID)
	}
	if m.operation_lock_duration != nil {
		fields = append(fields, carcumulative.FieldOperationLockDuration)
	}
	if m.operation_manual_duration != nil {
		fields = append(fields, carcumulative.FieldOperationManualDuration)
	}
	if m.operation_auto_duration != nil {
		fields = append(fields, carcumulative.FieldOperationAutoDuration)
	}
	if m.operation_fault_duration != nil {
		fields = append(fields, carcumulative.FieldOperationFaultDuration)
	}
	if m.operation_lock_times != nil {
		fields = append(fields, carcumulative.FieldOperationLockTimes)
	}
	if m.operation_manual_times != nil {
		fields = append(fields, carcumulative.FieldOperationManualTimes)
	}
	if m.operation_auto_times != nil {
		fields = append(fields, carcumulative.FieldOperationAutoTimes)
	}
	if m.operation_fault_times != nil {
		fields = append(fields, carcumulative.FieldOperationFaultTimes)
	}
	if m.operation_manual_mileage != nil {
		fields = append(fields, carcumulative.FieldOperationManualMileage)
	}
	if m.operation_auto_mileage != nil {
		fields = append(fields, carcumulative.FieldOperationAutoMileage)
	}
	if m.maintain_lock_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainLockDuration)
	}
	if m.maintain_manual_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainManualDuration)
	}
	if m.maintain_auto_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoDuration)
	}
	if m.maintain_remote_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteDuration)
	}
	if m.maintain_fault_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainFaultDuration)
	}
	if m.maintain_lock_times != nil {
		fields = append(fields, carcumulative.FieldMaintainLockTimes)
	}
	if m.maintain_manual_times != nil {
		fields = append(fields, carcumulative.FieldMaintainManualTimes)
	}
	if m.maintain_auto_times != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoTimes)
	}
	if m.maintain_remote_times != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteTimes)
	}
	if m.maintain_fault_times != nil {
		fields = append(fields, carcumulative.FieldMaintainFaultTimes)
	}
	if m.maintain_manual_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainManualMileage)
	}
	if m.maintain_auto_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoMileage)
	}
	if m.maintain_remote_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteMileage)
	}
	if m.alarm_times != nil {
		fields = append(fields, carcumulative.FieldAlarmTimes)
	}
	if m.create_time != nil {
		fields = append(fields, carcumulative.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carcumulative.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarCumulativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carcumulative.FieldCarID:
		return m.CarID()
	case carcumulative.FieldDeviceID:
		return m.DeviceID()
	case carcumulative.FieldOperationLockDuration:
		return m.OperationLockDuration()
	case carcumulative.FieldOperationManualDuration:
		return m.OperationManualDuration()
	case carcumulative.FieldOperationAutoDuration:
		return m.OperationAutoDuration()
	case carcumulative.FieldOperationFaultDuration:
		return m.OperationFaultDuration()
	case carcumulative.FieldOperationLockTimes:
		return m.OperationLockTimes()
	case carcumulative.FieldOperationManualTimes:
		return m.OperationManualTimes()
	case carcumulative.FieldOperationAutoTimes:
		return m.OperationAutoTimes()
	case carcumulative.FieldOperationFaultTimes:
		return m.OperationFaultTimes()
	case carcumulative.FieldOperationManualMileage:
		return m.OperationManualMileage()
	case carcumulative.FieldOperationAutoMileage:
		return m.OperationAutoMileage()
	case carcumulative.FieldMaintainLockDuration:
		return m.MaintainLockDuration()
	case carcumulative.FieldMaintainManualDuration:
		return m.MaintainManualDuration()
	case carcumulative.FieldMaintainAutoDuration:
		return m.MaintainAutoDuration()
	case carcumulative.FieldMaintainRemoteDuration:
		return m.MaintainRemoteDuration()
	case carcumulative.FieldMaintainFaultDuration:
		return m.MaintainFaultDuration()
	case carcumulative.FieldMaintainLockTimes:
		return m.MaintainLockTimes()
	case carcumulative.FieldMaintainManualTimes:
		return m.MaintainManualTimes()
	case carcumulative.FieldMaintainAutoTimes:
		return m.MaintainAutoTimes()
	case carcumulative.FieldMaintainRemoteTimes:
		return m.MaintainRemoteTimes()
	case carcumulative.FieldMaintainFaultTimes:
		return m.MaintainFaultTimes()
	case carcumulative.FieldMaintainManualMileage:
		return m.MaintainManualMileage()
	case carcumulative.FieldMaintainAutoMileage:
		return m.MaintainAutoMileage()
	case carcumulative.FieldMaintainRemoteMileage:
		return m.MaintainRemoteMileage()
	case carcumulative.FieldAlarmTimes:
		return m.AlarmTimes()
	case carcumulative.FieldCreateTime:
		return m.CreateTime()
	case carcumulative.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarCumulativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carcumulative.FieldCarID:
		return m.OldCarID(ctx)
	case carcumulative.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carcumulative.FieldOperationLockDuration:
		return m.OldOperationLockDuration(ctx)
	case carcumulative.FieldOperationManualDuration:
		return m.OldOperationManualDuration(ctx)
	case carcumulative.FieldOperationAutoDuration:
		return m.OldOperationAutoDuration(ctx)
	case carcumulative.FieldOperationFaultDuration:
		return m.OldOperationFaultDuration(ctx)
	case carcumulative.FieldOperationLockTimes:
		return m.OldOperationLockTimes(ctx)
	case carcumulative.FieldOperationManualTimes:
		return m.OldOperationManualTimes(ctx)
	case carcumulative.FieldOperationAutoTimes:
		return m.OldOperationAutoTimes(ctx)
	case carcumulative.FieldOperationFaultTimes:
		return m.OldOperationFaultTimes(ctx)
	case carcumulative.FieldOperationManualMileage:
		return m.OldOperationManualMileage(ctx)
	case carcumulative.FieldOperationAutoMileage:
		return m.OldOperationAutoMileage(ctx)
	case carcumulative.FieldMaintainLockDuration:
		return m.OldMaintainLockDuration(ctx)
	case carcumulative.FieldMaintainManualDuration:
		return m.OldMaintainManualDuration(ctx)
	case carcumulative.FieldMaintainAutoDuration:
		return m.OldMaintainAutoDuration(ctx)
	case carcumulative.FieldMaintainRemoteDuration:
		return m.OldMaintainRemoteDuration(ctx)
	case carcumulative.FieldMaintainFaultDuration:
		return m.OldMaintainFaultDuration(ctx)
	case carcumulative.FieldMaintainLockTimes:
		return m.OldMaintainLockTimes(ctx)
	case carcumulative.FieldMaintainManualTimes:
		return m.OldMaintainManualTimes(ctx)
	case carcumulative.FieldMaintainAutoTimes:
		return m.OldMaintainAutoTimes(ctx)
	case carcumulative.FieldMaintainRemoteTimes:
		return m.OldMaintainRemoteTimes(ctx)
	case carcumulative.FieldMaintainFaultTimes:
		return m.OldMaintainFaultTimes(ctx)
	case carcumulative.FieldMaintainManualMileage:
		return m.OldMaintainManualMileage(ctx)
	case carcumulative.FieldMaintainAutoMileage:
		return m.OldMaintainAutoMileage(ctx)
	case carcumulative.FieldMaintainRemoteMileage:
		return m.OldMaintainRemoteMileage(ctx)
	case carcumulative.FieldAlarmTimes:
		return m.OldAlarmTimes(ctx)
	case carcumulative.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carcumulative.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarCumulative field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarCumulativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carcumulative.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carcumulative.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carcumulative.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockDuration(v)
		return nil
	case carcumulative.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualDuration(v)
		return nil
	case carcumulative.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoDuration(v)
		return nil
	case carcumulative.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultDuration(v)
		return nil
	case carcumulative.FieldOperationLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockTimes(v)
		return nil
	case carcumulative.FieldOperationManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualTimes(v)
		return nil
	case carcumulative.FieldOperationAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoTimes(v)
		return nil
	case carcumulative.FieldOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultTimes(v)
		return nil
	case carcumulative.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualMileage(v)
		return nil
	case carcumulative.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoMileage(v)
		return nil
	case carcumulative.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockDuration(v)
		return nil
	case carcumulative.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualDuration(v)
		return nil
	case carcumulative.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoDuration(v)
		return nil
	case carcumulative.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteDuration(v)
		return nil
	case carcumulative.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultDuration(v)
		return nil
	case carcumulative.FieldMaintainLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockTimes(v)
		return nil
	case carcumulative.FieldMaintainManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualTimes(v)
		return nil
	case carcumulative.FieldMaintainAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoTimes(v)
		return nil
	case carcumulative.FieldMaintainRemoteTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteTimes(v)
		return nil
	case carcumulative.FieldMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultTimes(v)
		return nil
	case carcumulative.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualMileage(v)
		return nil
	case carcumulative.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoMileage(v)
		return nil
	case carcumulative.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteMileage(v)
		return nil
	case carcumulative.FieldAlarmTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmTimes(v)
		return nil
	case carcumulative.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carcumulative.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarCumulative field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarCumulativeMutation) AddedFields() []string {
	var fields []string
	if m.addcar_id != nil {
		fields = append(fields, carcumulative.FieldCarID)
	}
	if m.addoperation_lock_duration != nil {
		fields = append(fields, carcumulative.FieldOperationLockDuration)
	}
	if m.addoperation_manual_duration != nil {
		fields = append(fields, carcumulative.FieldOperationManualDuration)
	}
	if m.addoperation_auto_duration != nil {
		fields = append(fields, carcumulative.FieldOperationAutoDuration)
	}
	if m.addoperation_fault_duration != nil {
		fields = append(fields, carcumulative.FieldOperationFaultDuration)
	}
	if m.addoperation_lock_times != nil {
		fields = append(fields, carcumulative.FieldOperationLockTimes)
	}
	if m.addoperation_manual_times != nil {
		fields = append(fields, carcumulative.FieldOperationManualTimes)
	}
	if m.addoperation_auto_times != nil {
		fields = append(fields, carcumulative.FieldOperationAutoTimes)
	}
	if m.addoperation_fault_times != nil {
		fields = append(fields, carcumulative.FieldOperationFaultTimes)
	}
	if m.addoperation_manual_mileage != nil {
		fields = append(fields, carcumulative.FieldOperationManualMileage)
	}
	if m.addoperation_auto_mileage != nil {
		fields = append(fields, carcumulative.FieldOperationAutoMileage)
	}
	if m.addmaintain_lock_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainLockDuration)
	}
	if m.addmaintain_manual_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainManualDuration)
	}
	if m.addmaintain_auto_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoDuration)
	}
	if m.addmaintain_remote_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteDuration)
	}
	if m.addmaintain_fault_duration != nil {
		fields = append(fields, carcumulative.FieldMaintainFaultDuration)
	}
	if m.addmaintain_lock_times != nil {
		fields = append(fields, carcumulative.FieldMaintainLockTimes)
	}
	if m.addmaintain_manual_times != nil {
		fields = append(fields, carcumulative.FieldMaintainManualTimes)
	}
	if m.addmaintain_auto_times != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoTimes)
	}
	if m.addmaintain_remote_times != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteTimes)
	}
	if m.addmaintain_fault_times != nil {
		fields = append(fields, carcumulative.FieldMaintainFaultTimes)
	}
	if m.addmaintain_manual_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainManualMileage)
	}
	if m.addmaintain_auto_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainAutoMileage)
	}
	if m.addmaintain_remote_mileage != nil {
		fields = append(fields, carcumulative.FieldMaintainRemoteMileage)
	}
	if m.addalarm_times != nil {
		fields = append(fields, carcumulative.FieldAlarmTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarCumulativeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carcumulative.FieldCarID:
		return m.AddedCarID()
	case carcumulative.FieldOperationLockDuration:
		return m.AddedOperationLockDuration()
	case carcumulative.FieldOperationManualDuration:
		return m.AddedOperationManualDuration()
	case carcumulative.FieldOperationAutoDuration:
		return m.AddedOperationAutoDuration()
	case carcumulative.FieldOperationFaultDuration:
		return m.AddedOperationFaultDuration()
	case carcumulative.FieldOperationLockTimes:
		return m.AddedOperationLockTimes()
	case carcumulative.FieldOperationManualTimes:
		return m.AddedOperationManualTimes()
	case carcumulative.FieldOperationAutoTimes:
		return m.AddedOperationAutoTimes()
	case carcumulative.FieldOperationFaultTimes:
		return m.AddedOperationFaultTimes()
	case carcumulative.FieldOperationManualMileage:
		return m.AddedOperationManualMileage()
	case carcumulative.FieldOperationAutoMileage:
		return m.AddedOperationAutoMileage()
	case carcumulative.FieldMaintainLockDuration:
		return m.AddedMaintainLockDuration()
	case carcumulative.FieldMaintainManualDuration:
		return m.AddedMaintainManualDuration()
	case carcumulative.FieldMaintainAutoDuration:
		return m.AddedMaintainAutoDuration()
	case carcumulative.FieldMaintainRemoteDuration:
		return m.AddedMaintainRemoteDuration()
	case carcumulative.FieldMaintainFaultDuration:
		return m.AddedMaintainFaultDuration()
	case carcumulative.FieldMaintainLockTimes:
		return m.AddedMaintainLockTimes()
	case carcumulative.FieldMaintainManualTimes:
		return m.AddedMaintainManualTimes()
	case carcumulative.FieldMaintainAutoTimes:
		return m.AddedMaintainAutoTimes()
	case carcumulative.FieldMaintainRemoteTimes:
		return m.AddedMaintainRemoteTimes()
	case carcumulative.FieldMaintainFaultTimes:
		return m.AddedMaintainFaultTimes()
	case carcumulative.FieldMaintainManualMileage:
		return m.AddedMaintainManualMileage()
	case carcumulative.FieldMaintainAutoMileage:
		return m.AddedMaintainAutoMileage()
	case carcumulative.FieldMaintainRemoteMileage:
		return m.AddedMaintainRemoteMileage()
	case carcumulative.FieldAlarmTimes:
		return m.AddedAlarmTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarCumulativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carcumulative.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case carcumulative.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockDuration(v)
		return nil
	case carcumulative.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualDuration(v)
		return nil
	case carcumulative.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoDuration(v)
		return nil
	case carcumulative.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultDuration(v)
		return nil
	case carcumulative.FieldOperationLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockTimes(v)
		return nil
	case carcumulative.FieldOperationManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualTimes(v)
		return nil
	case carcumulative.FieldOperationAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoTimes(v)
		return nil
	case carcumulative.FieldOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultTimes(v)
		return nil
	case carcumulative.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualMileage(v)
		return nil
	case carcumulative.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoMileage(v)
		return nil
	case carcumulative.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockDuration(v)
		return nil
	case carcumulative.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualDuration(v)
		return nil
	case carcumulative.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoDuration(v)
		return nil
	case carcumulative.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteDuration(v)
		return nil
	case carcumulative.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultDuration(v)
		return nil
	case carcumulative.FieldMaintainLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockTimes(v)
		return nil
	case carcumulative.FieldMaintainManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualTimes(v)
		return nil
	case carcumulative.FieldMaintainAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoTimes(v)
		return nil
	case carcumulative.FieldMaintainRemoteTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteTimes(v)
		return nil
	case carcumulative.FieldMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultTimes(v)
		return nil
	case carcumulative.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualMileage(v)
		return nil
	case carcumulative.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoMileage(v)
		return nil
	case carcumulative.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteMileage(v)
		return nil
	case carcumulative.FieldAlarmTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlarmTimes(v)
		return nil
	}
	return fmt.Errorf("unknown CarCumulative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarCumulativeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarCumulativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarCumulativeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarCumulative nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarCumulativeMutation) ResetField(name string) error {
	switch name {
	case carcumulative.FieldCarID:
		m.ResetCarID()
		return nil
	case carcumulative.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carcumulative.FieldOperationLockDuration:
		m.ResetOperationLockDuration()
		return nil
	case carcumulative.FieldOperationManualDuration:
		m.ResetOperationManualDuration()
		return nil
	case carcumulative.FieldOperationAutoDuration:
		m.ResetOperationAutoDuration()
		return nil
	case carcumulative.FieldOperationFaultDuration:
		m.ResetOperationFaultDuration()
		return nil
	case carcumulative.FieldOperationLockTimes:
		m.ResetOperationLockTimes()
		return nil
	case carcumulative.FieldOperationManualTimes:
		m.ResetOperationManualTimes()
		return nil
	case carcumulative.FieldOperationAutoTimes:
		m.ResetOperationAutoTimes()
		return nil
	case carcumulative.FieldOperationFaultTimes:
		m.ResetOperationFaultTimes()
		return nil
	case carcumulative.FieldOperationManualMileage:
		m.ResetOperationManualMileage()
		return nil
	case carcumulative.FieldOperationAutoMileage:
		m.ResetOperationAutoMileage()
		return nil
	case carcumulative.FieldMaintainLockDuration:
		m.ResetMaintainLockDuration()
		return nil
	case carcumulative.FieldMaintainManualDuration:
		m.ResetMaintainManualDuration()
		return nil
	case carcumulative.FieldMaintainAutoDuration:
		m.ResetMaintainAutoDuration()
		return nil
	case carcumulative.FieldMaintainRemoteDuration:
		m.ResetMaintainRemoteDuration()
		return nil
	case carcumulative.FieldMaintainFaultDuration:
		m.ResetMaintainFaultDuration()
		return nil
	case carcumulative.FieldMaintainLockTimes:
		m.ResetMaintainLockTimes()
		return nil
	case carcumulative.FieldMaintainManualTimes:
		m.ResetMaintainManualTimes()
		return nil
	case carcumulative.FieldMaintainAutoTimes:
		m.ResetMaintainAutoTimes()
		return nil
	case carcumulative.FieldMaintainRemoteTimes:
		m.ResetMaintainRemoteTimes()
		return nil
	case carcumulative.FieldMaintainFaultTimes:
		m.ResetMaintainFaultTimes()
		return nil
	case carcumulative.FieldMaintainManualMileage:
		m.ResetMaintainManualMileage()
		return nil
	case carcumulative.FieldMaintainAutoMileage:
		m.ResetMaintainAutoMileage()
		return nil
	case carcumulative.FieldMaintainRemoteMileage:
		m.ResetMaintainRemoteMileage()
		return nil
	case carcumulative.FieldAlarmTimes:
		m.ResetAlarmTimes()
		return nil
	case carcumulative.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carcumulative.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarCumulative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarCumulativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarCumulativeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarCumulativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarCumulativeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarCumulativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarCumulativeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarCumulativeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarCumulative unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarCumulativeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarCumulative edge %s", name)
}

// CarExtendYokeeMutation represents an operation that mutates the CarExtendYokee nodes in the graph.
type CarExtendYokeeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	delete_time         *time.Time
	car_id              *int
	addcar_id           *int
	yokee_vehicle_id    *int
	addyokee_vehicle_id *int
	yokee_vehicle_name  *string
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CarExtendYokee, error)
	predicates          []predicate.CarExtendYokee
}

var _ ent.Mutation = (*CarExtendYokeeMutation)(nil)

// carextendyokeeOption allows management of the mutation configuration using functional options.
type carextendyokeeOption func(*CarExtendYokeeMutation)

// newCarExtendYokeeMutation creates new mutation for the CarExtendYokee entity.
func newCarExtendYokeeMutation(c config, op Op, opts ...carextendyokeeOption) *CarExtendYokeeMutation {
	m := &CarExtendYokeeMutation{
		config:        c,
		op:            op,
		typ:           TypeCarExtendYokee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarExtendYokeeID sets the ID field of the mutation.
func withCarExtendYokeeID(id int) carextendyokeeOption {
	return func(m *CarExtendYokeeMutation) {
		var (
			err   error
			once  sync.Once
			value *CarExtendYokee
		)
		m.oldValue = func(ctx context.Context) (*CarExtendYokee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarExtendYokee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarExtendYokee sets the old CarExtendYokee of the mutation.
func withCarExtendYokee(node *CarExtendYokee) carextendyokeeOption {
	return func(m *CarExtendYokeeMutation) {
		m.oldValue = func(context.Context) (*CarExtendYokee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarExtendYokeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarExtendYokeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarExtendYokee entities.
func (m *CarExtendYokeeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarExtendYokeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarExtendYokeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarExtendYokee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *CarExtendYokeeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CarExtendYokeeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CarExtendYokeeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[carextendyokee.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CarExtendYokeeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[carextendyokee.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CarExtendYokeeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, carextendyokee.FieldDeleteTime)
}

// SetCarID sets the "car_id" field.
func (m *CarExtendYokeeMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarExtendYokeeMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarExtendYokeeMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarExtendYokeeMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarExtendYokeeMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetYokeeVehicleID sets the "yokee_vehicle_id" field.
func (m *CarExtendYokeeMutation) SetYokeeVehicleID(i int) {
	m.yokee_vehicle_id = &i
	m.addyokee_vehicle_id = nil
}

// YokeeVehicleID returns the value of the "yokee_vehicle_id" field in the mutation.
func (m *CarExtendYokeeMutation) YokeeVehicleID() (r int, exists bool) {
	v := m.yokee_vehicle_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeVehicleID returns the old "yokee_vehicle_id" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldYokeeVehicleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeVehicleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeVehicleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeVehicleID: %w", err)
	}
	return oldValue.YokeeVehicleID, nil
}

// AddYokeeVehicleID adds i to the "yokee_vehicle_id" field.
func (m *CarExtendYokeeMutation) AddYokeeVehicleID(i int) {
	if m.addyokee_vehicle_id != nil {
		*m.addyokee_vehicle_id += i
	} else {
		m.addyokee_vehicle_id = &i
	}
}

// AddedYokeeVehicleID returns the value that was added to the "yokee_vehicle_id" field in this mutation.
func (m *CarExtendYokeeMutation) AddedYokeeVehicleID() (r int, exists bool) {
	v := m.addyokee_vehicle_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeVehicleID resets all changes to the "yokee_vehicle_id" field.
func (m *CarExtendYokeeMutation) ResetYokeeVehicleID() {
	m.yokee_vehicle_id = nil
	m.addyokee_vehicle_id = nil
}

// SetYokeeVehicleName sets the "yokee_vehicle_name" field.
func (m *CarExtendYokeeMutation) SetYokeeVehicleName(s string) {
	m.yokee_vehicle_name = &s
}

// YokeeVehicleName returns the value of the "yokee_vehicle_name" field in the mutation.
func (m *CarExtendYokeeMutation) YokeeVehicleName() (r string, exists bool) {
	v := m.yokee_vehicle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeVehicleName returns the old "yokee_vehicle_name" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldYokeeVehicleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeVehicleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeVehicleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeVehicleName: %w", err)
	}
	return oldValue.YokeeVehicleName, nil
}

// ResetYokeeVehicleName resets all changes to the "yokee_vehicle_name" field.
func (m *CarExtendYokeeMutation) ResetYokeeVehicleName() {
	m.yokee_vehicle_name = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarExtendYokeeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarExtendYokeeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarExtendYokeeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarExtendYokeeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarExtendYokeeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarExtendYokee entity.
// If the CarExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarExtendYokeeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarExtendYokeeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarExtendYokeeMutation builder.
func (m *CarExtendYokeeMutation) Where(ps ...predicate.CarExtendYokee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarExtendYokeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarExtendYokeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarExtendYokee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarExtendYokeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarExtendYokeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarExtendYokee).
func (m *CarExtendYokeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarExtendYokeeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.delete_time != nil {
		fields = append(fields, carextendyokee.FieldDeleteTime)
	}
	if m.car_id != nil {
		fields = append(fields, carextendyokee.FieldCarID)
	}
	if m.yokee_vehicle_id != nil {
		fields = append(fields, carextendyokee.FieldYokeeVehicleID)
	}
	if m.yokee_vehicle_name != nil {
		fields = append(fields, carextendyokee.FieldYokeeVehicleName)
	}
	if m.create_time != nil {
		fields = append(fields, carextendyokee.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carextendyokee.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarExtendYokeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carextendyokee.FieldDeleteTime:
		return m.DeleteTime()
	case carextendyokee.FieldCarID:
		return m.CarID()
	case carextendyokee.FieldYokeeVehicleID:
		return m.YokeeVehicleID()
	case carextendyokee.FieldYokeeVehicleName:
		return m.YokeeVehicleName()
	case carextendyokee.FieldCreateTime:
		return m.CreateTime()
	case carextendyokee.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarExtendYokeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carextendyokee.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case carextendyokee.FieldCarID:
		return m.OldCarID(ctx)
	case carextendyokee.FieldYokeeVehicleID:
		return m.OldYokeeVehicleID(ctx)
	case carextendyokee.FieldYokeeVehicleName:
		return m.OldYokeeVehicleName(ctx)
	case carextendyokee.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carextendyokee.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarExtendYokee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarExtendYokeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carextendyokee.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case carextendyokee.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carextendyokee.FieldYokeeVehicleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeVehicleID(v)
		return nil
	case carextendyokee.FieldYokeeVehicleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeVehicleName(v)
		return nil
	case carextendyokee.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carextendyokee.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarExtendYokee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarExtendYokeeMutation) AddedFields() []string {
	var fields []string
	if m.addcar_id != nil {
		fields = append(fields, carextendyokee.FieldCarID)
	}
	if m.addyokee_vehicle_id != nil {
		fields = append(fields, carextendyokee.FieldYokeeVehicleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarExtendYokeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carextendyokee.FieldCarID:
		return m.AddedCarID()
	case carextendyokee.FieldYokeeVehicleID:
		return m.AddedYokeeVehicleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarExtendYokeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carextendyokee.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case carextendyokee.FieldYokeeVehicleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeVehicleID(v)
		return nil
	}
	return fmt.Errorf("unknown CarExtendYokee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarExtendYokeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carextendyokee.FieldDeleteTime) {
		fields = append(fields, carextendyokee.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarExtendYokeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarExtendYokeeMutation) ClearField(name string) error {
	switch name {
	case carextendyokee.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown CarExtendYokee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarExtendYokeeMutation) ResetField(name string) error {
	switch name {
	case carextendyokee.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case carextendyokee.FieldCarID:
		m.ResetCarID()
		return nil
	case carextendyokee.FieldYokeeVehicleID:
		m.ResetYokeeVehicleID()
		return nil
	case carextendyokee.FieldYokeeVehicleName:
		m.ResetYokeeVehicleName()
		return nil
	case carextendyokee.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carextendyokee.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarExtendYokee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarExtendYokeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarExtendYokeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarExtendYokeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarExtendYokeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarExtendYokeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarExtendYokeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarExtendYokeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarExtendYokee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarExtendYokeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarExtendYokee edge %s", name)
}

// CarLogUploadMutation represents an operation that mutates the CarLogUpload nodes in the graph.
type CarLogUploadMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *int64
	adduuid           *int64
	car_id            *int
	addcar_id         *int
	device_id         *string
	upload_state      *string
	upload_process    *int
	addupload_process *int
	download_url      *string
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*CarLogUpload, error)
	predicates        []predicate.CarLogUpload
}

var _ ent.Mutation = (*CarLogUploadMutation)(nil)

// carloguploadOption allows management of the mutation configuration using functional options.
type carloguploadOption func(*CarLogUploadMutation)

// newCarLogUploadMutation creates new mutation for the CarLogUpload entity.
func newCarLogUploadMutation(c config, op Op, opts ...carloguploadOption) *CarLogUploadMutation {
	m := &CarLogUploadMutation{
		config:        c,
		op:            op,
		typ:           TypeCarLogUpload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarLogUploadID sets the ID field of the mutation.
func withCarLogUploadID(id int) carloguploadOption {
	return func(m *CarLogUploadMutation) {
		var (
			err   error
			once  sync.Once
			value *CarLogUpload
		)
		m.oldValue = func(ctx context.Context) (*CarLogUpload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarLogUpload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarLogUpload sets the old CarLogUpload of the mutation.
func withCarLogUpload(node *CarLogUpload) carloguploadOption {
	return func(m *CarLogUploadMutation) {
		m.oldValue = func(context.Context) (*CarLogUpload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarLogUploadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarLogUploadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarLogUpload entities.
func (m *CarLogUploadMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarLogUploadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarLogUploadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarLogUpload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *CarLogUploadMutation) SetUUID(i int64) {
	m.uuid = &i
	m.adduuid = nil
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *CarLogUploadMutation) UUID() (r int64, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldUUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// AddUUID adds i to the "uuid" field.
func (m *CarLogUploadMutation) AddUUID(i int64) {
	if m.adduuid != nil {
		*m.adduuid += i
	} else {
		m.adduuid = &i
	}
}

// AddedUUID returns the value that was added to the "uuid" field in this mutation.
func (m *CarLogUploadMutation) AddedUUID() (r int64, exists bool) {
	v := m.adduuid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUUID resets all changes to the "uuid" field.
func (m *CarLogUploadMutation) ResetUUID() {
	m.uuid = nil
	m.adduuid = nil
}

// SetCarID sets the "car_id" field.
func (m *CarLogUploadMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarLogUploadMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarLogUploadMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarLogUploadMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarLogUploadMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarLogUploadMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarLogUploadMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarLogUploadMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetUploadState sets the "upload_state" field.
func (m *CarLogUploadMutation) SetUploadState(s string) {
	m.upload_state = &s
}

// UploadState returns the value of the "upload_state" field in the mutation.
func (m *CarLogUploadMutation) UploadState() (r string, exists bool) {
	v := m.upload_state
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadState returns the old "upload_state" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldUploadState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadState: %w", err)
	}
	return oldValue.UploadState, nil
}

// ResetUploadState resets all changes to the "upload_state" field.
func (m *CarLogUploadMutation) ResetUploadState() {
	m.upload_state = nil
}

// SetUploadProcess sets the "upload_process" field.
func (m *CarLogUploadMutation) SetUploadProcess(i int) {
	m.upload_process = &i
	m.addupload_process = nil
}

// UploadProcess returns the value of the "upload_process" field in the mutation.
func (m *CarLogUploadMutation) UploadProcess() (r int, exists bool) {
	v := m.upload_process
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadProcess returns the old "upload_process" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldUploadProcess(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadProcess: %w", err)
	}
	return oldValue.UploadProcess, nil
}

// AddUploadProcess adds i to the "upload_process" field.
func (m *CarLogUploadMutation) AddUploadProcess(i int) {
	if m.addupload_process != nil {
		*m.addupload_process += i
	} else {
		m.addupload_process = &i
	}
}

// AddedUploadProcess returns the value that was added to the "upload_process" field in this mutation.
func (m *CarLogUploadMutation) AddedUploadProcess() (r int, exists bool) {
	v := m.addupload_process
	if v == nil {
		return
	}
	return *v, true
}

// ResetUploadProcess resets all changes to the "upload_process" field.
func (m *CarLogUploadMutation) ResetUploadProcess() {
	m.upload_process = nil
	m.addupload_process = nil
}

// SetDownloadURL sets the "download_url" field.
func (m *CarLogUploadMutation) SetDownloadURL(s string) {
	m.download_url = &s
}

// DownloadURL returns the value of the "download_url" field in the mutation.
func (m *CarLogUploadMutation) DownloadURL() (r string, exists bool) {
	v := m.download_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadURL returns the old "download_url" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldDownloadURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadURL: %w", err)
	}
	return oldValue.DownloadURL, nil
}

// ResetDownloadURL resets all changes to the "download_url" field.
func (m *CarLogUploadMutation) ResetDownloadURL() {
	m.download_url = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarLogUploadMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarLogUploadMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarLogUploadMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarLogUploadMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarLogUploadMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarLogUpload entity.
// If the CarLogUpload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarLogUploadMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarLogUploadMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarLogUploadMutation builder.
func (m *CarLogUploadMutation) Where(ps ...predicate.CarLogUpload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarLogUploadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarLogUploadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarLogUpload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarLogUploadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarLogUploadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarLogUpload).
func (m *CarLogUploadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarLogUploadMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.uuid != nil {
		fields = append(fields, carlogupload.FieldUUID)
	}
	if m.car_id != nil {
		fields = append(fields, carlogupload.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carlogupload.FieldDeviceID)
	}
	if m.upload_state != nil {
		fields = append(fields, carlogupload.FieldUploadState)
	}
	if m.upload_process != nil {
		fields = append(fields, carlogupload.FieldUploadProcess)
	}
	if m.download_url != nil {
		fields = append(fields, carlogupload.FieldDownloadURL)
	}
	if m.create_time != nil {
		fields = append(fields, carlogupload.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carlogupload.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarLogUploadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carlogupload.FieldUUID:
		return m.UUID()
	case carlogupload.FieldCarID:
		return m.CarID()
	case carlogupload.FieldDeviceID:
		return m.DeviceID()
	case carlogupload.FieldUploadState:
		return m.UploadState()
	case carlogupload.FieldUploadProcess:
		return m.UploadProcess()
	case carlogupload.FieldDownloadURL:
		return m.DownloadURL()
	case carlogupload.FieldCreateTime:
		return m.CreateTime()
	case carlogupload.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarLogUploadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carlogupload.FieldUUID:
		return m.OldUUID(ctx)
	case carlogupload.FieldCarID:
		return m.OldCarID(ctx)
	case carlogupload.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carlogupload.FieldUploadState:
		return m.OldUploadState(ctx)
	case carlogupload.FieldUploadProcess:
		return m.OldUploadProcess(ctx)
	case carlogupload.FieldDownloadURL:
		return m.OldDownloadURL(ctx)
	case carlogupload.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carlogupload.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarLogUpload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarLogUploadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carlogupload.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case carlogupload.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carlogupload.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carlogupload.FieldUploadState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadState(v)
		return nil
	case carlogupload.FieldUploadProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadProcess(v)
		return nil
	case carlogupload.FieldDownloadURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadURL(v)
		return nil
	case carlogupload.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carlogupload.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarLogUpload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarLogUploadMutation) AddedFields() []string {
	var fields []string
	if m.adduuid != nil {
		fields = append(fields, carlogupload.FieldUUID)
	}
	if m.addcar_id != nil {
		fields = append(fields, carlogupload.FieldCarID)
	}
	if m.addupload_process != nil {
		fields = append(fields, carlogupload.FieldUploadProcess)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarLogUploadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carlogupload.FieldUUID:
		return m.AddedUUID()
	case carlogupload.FieldCarID:
		return m.AddedCarID()
	case carlogupload.FieldUploadProcess:
		return m.AddedUploadProcess()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarLogUploadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carlogupload.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUUID(v)
		return nil
	case carlogupload.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case carlogupload.FieldUploadProcess:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadProcess(v)
		return nil
	}
	return fmt.Errorf("unknown CarLogUpload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarLogUploadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarLogUploadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarLogUploadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarLogUpload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarLogUploadMutation) ResetField(name string) error {
	switch name {
	case carlogupload.FieldUUID:
		m.ResetUUID()
		return nil
	case carlogupload.FieldCarID:
		m.ResetCarID()
		return nil
	case carlogupload.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carlogupload.FieldUploadState:
		m.ResetUploadState()
		return nil
	case carlogupload.FieldUploadProcess:
		m.ResetUploadProcess()
		return nil
	case carlogupload.FieldDownloadURL:
		m.ResetDownloadURL()
		return nil
	case carlogupload.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carlogupload.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarLogUpload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarLogUploadMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarLogUploadMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarLogUploadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarLogUploadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarLogUploadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarLogUploadMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarLogUploadMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarLogUpload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarLogUploadMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarLogUpload edge %s", name)
}

// CarsFlightMutation represents an operation that mutates the CarsFlight nodes in the graph.
type CarsFlightMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	scenic_area_id     *int
	addscenic_area_id  *int
	flight_no          *string
	car_id             *int
	addcar_id          *int
	device_id          *string
	car_name           *string
	route_id           *int
	addroute_id        *int
	route_name         *string
	seats_num          *int
	addseats_num       *int
	state              *int
	addstate           *int
	curr_stop_id       *int
	addcurr_stop_id    *int
	stop_ids           *[]int
	appendstop_ids     []int
	pass_ids           *[]int
	appendpass_ids     []int
	remark             *string
	stop_stock         *[]types.StopStock
	appendstop_stock   []types.StopStock
	extend_yokee_id    *int
	addextend_yokee_id *int
	departure_time     *time.Time
	finish_time        *time.Time
	create_time        *time.Time
	update_time        *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*CarsFlight, error)
	predicates         []predicate.CarsFlight
}

var _ ent.Mutation = (*CarsFlightMutation)(nil)

// carsflightOption allows management of the mutation configuration using functional options.
type carsflightOption func(*CarsFlightMutation)

// newCarsFlightMutation creates new mutation for the CarsFlight entity.
func newCarsFlightMutation(c config, op Op, opts ...carsflightOption) *CarsFlightMutation {
	m := &CarsFlightMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsFlightID sets the ID field of the mutation.
func withCarsFlightID(id int) carsflightOption {
	return func(m *CarsFlightMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsFlight
		)
		m.oldValue = func(ctx context.Context) (*CarsFlight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsFlight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsFlight sets the old CarsFlight of the mutation.
func withCarsFlight(node *CarsFlight) carsflightOption {
	return func(m *CarsFlightMutation) {
		m.oldValue = func(context.Context) (*CarsFlight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsFlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsFlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsFlight entities.
func (m *CarsFlightMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsFlightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsFlightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsFlight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CarsFlightMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CarsFlightMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *CarsFlightMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *CarsFlightMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CarsFlightMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetFlightNo sets the "flight_no" field.
func (m *CarsFlightMutation) SetFlightNo(s string) {
	m.flight_no = &s
}

// FlightNo returns the value of the "flight_no" field in the mutation.
func (m *CarsFlightMutation) FlightNo() (r string, exists bool) {
	v := m.flight_no
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightNo returns the old "flight_no" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldFlightNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightNo: %w", err)
	}
	return oldValue.FlightNo, nil
}

// ResetFlightNo resets all changes to the "flight_no" field.
func (m *CarsFlightMutation) ResetFlightNo() {
	m.flight_no = nil
}

// SetCarID sets the "car_id" field.
func (m *CarsFlightMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarsFlightMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *CarsFlightMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *CarsFlightMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarsFlightMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarsFlightMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarsFlightMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarsFlightMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetCarName sets the "car_name" field.
func (m *CarsFlightMutation) SetCarName(s string) {
	m.car_name = &s
}

// CarName returns the value of the "car_name" field in the mutation.
func (m *CarsFlightMutation) CarName() (r string, exists bool) {
	v := m.car_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCarName returns the old "car_name" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldCarName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarName: %w", err)
	}
	return oldValue.CarName, nil
}

// ResetCarName resets all changes to the "car_name" field.
func (m *CarsFlightMutation) ResetCarName() {
	m.car_name = nil
}

// SetRouteID sets the "route_id" field.
func (m *CarsFlightMutation) SetRouteID(i int) {
	m.route_id = &i
	m.addroute_id = nil
}

// RouteID returns the value of the "route_id" field in the mutation.
func (m *CarsFlightMutation) RouteID() (r int, exists bool) {
	v := m.route_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteID returns the old "route_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldRouteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteID: %w", err)
	}
	return oldValue.RouteID, nil
}

// AddRouteID adds i to the "route_id" field.
func (m *CarsFlightMutation) AddRouteID(i int) {
	if m.addroute_id != nil {
		*m.addroute_id += i
	} else {
		m.addroute_id = &i
	}
}

// AddedRouteID returns the value that was added to the "route_id" field in this mutation.
func (m *CarsFlightMutation) AddedRouteID() (r int, exists bool) {
	v := m.addroute_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRouteID resets all changes to the "route_id" field.
func (m *CarsFlightMutation) ResetRouteID() {
	m.route_id = nil
	m.addroute_id = nil
}

// SetRouteName sets the "route_name" field.
func (m *CarsFlightMutation) SetRouteName(s string) {
	m.route_name = &s
}

// RouteName returns the value of the "route_name" field in the mutation.
func (m *CarsFlightMutation) RouteName() (r string, exists bool) {
	v := m.route_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteName returns the old "route_name" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldRouteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteName: %w", err)
	}
	return oldValue.RouteName, nil
}

// ResetRouteName resets all changes to the "route_name" field.
func (m *CarsFlightMutation) ResetRouteName() {
	m.route_name = nil
}

// SetSeatsNum sets the "seats_num" field.
func (m *CarsFlightMutation) SetSeatsNum(i int) {
	m.seats_num = &i
	m.addseats_num = nil
}

// SeatsNum returns the value of the "seats_num" field in the mutation.
func (m *CarsFlightMutation) SeatsNum() (r int, exists bool) {
	v := m.seats_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatsNum returns the old "seats_num" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldSeatsNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatsNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatsNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatsNum: %w", err)
	}
	return oldValue.SeatsNum, nil
}

// AddSeatsNum adds i to the "seats_num" field.
func (m *CarsFlightMutation) AddSeatsNum(i int) {
	if m.addseats_num != nil {
		*m.addseats_num += i
	} else {
		m.addseats_num = &i
	}
}

// AddedSeatsNum returns the value that was added to the "seats_num" field in this mutation.
func (m *CarsFlightMutation) AddedSeatsNum() (r int, exists bool) {
	v := m.addseats_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeatsNum resets all changes to the "seats_num" field.
func (m *CarsFlightMutation) ResetSeatsNum() {
	m.seats_num = nil
	m.addseats_num = nil
}

// SetState sets the "state" field.
func (m *CarsFlightMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CarsFlightMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CarsFlightMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CarsFlightMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CarsFlightMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCurrStopID sets the "curr_stop_id" field.
func (m *CarsFlightMutation) SetCurrStopID(i int) {
	m.curr_stop_id = &i
	m.addcurr_stop_id = nil
}

// CurrStopID returns the value of the "curr_stop_id" field in the mutation.
func (m *CarsFlightMutation) CurrStopID() (r int, exists bool) {
	v := m.curr_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrStopID returns the old "curr_stop_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldCurrStopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrStopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrStopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrStopID: %w", err)
	}
	return oldValue.CurrStopID, nil
}

// AddCurrStopID adds i to the "curr_stop_id" field.
func (m *CarsFlightMutation) AddCurrStopID(i int) {
	if m.addcurr_stop_id != nil {
		*m.addcurr_stop_id += i
	} else {
		m.addcurr_stop_id = &i
	}
}

// AddedCurrStopID returns the value that was added to the "curr_stop_id" field in this mutation.
func (m *CarsFlightMutation) AddedCurrStopID() (r int, exists bool) {
	v := m.addcurr_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrStopID clears the value of the "curr_stop_id" field.
func (m *CarsFlightMutation) ClearCurrStopID() {
	m.curr_stop_id = nil
	m.addcurr_stop_id = nil
	m.clearedFields[carsflight.FieldCurrStopID] = struct{}{}
}

// CurrStopIDCleared returns if the "curr_stop_id" field was cleared in this mutation.
func (m *CarsFlightMutation) CurrStopIDCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldCurrStopID]
	return ok
}

// ResetCurrStopID resets all changes to the "curr_stop_id" field.
func (m *CarsFlightMutation) ResetCurrStopID() {
	m.curr_stop_id = nil
	m.addcurr_stop_id = nil
	delete(m.clearedFields, carsflight.FieldCurrStopID)
}

// SetStopIds sets the "stop_ids" field.
func (m *CarsFlightMutation) SetStopIds(i []int) {
	m.stop_ids = &i
	m.appendstop_ids = nil
}

// StopIds returns the value of the "stop_ids" field in the mutation.
func (m *CarsFlightMutation) StopIds() (r []int, exists bool) {
	v := m.stop_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldStopIds returns the old "stop_ids" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldStopIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopIds: %w", err)
	}
	return oldValue.StopIds, nil
}

// AppendStopIds adds i to the "stop_ids" field.
func (m *CarsFlightMutation) AppendStopIds(i []int) {
	m.appendstop_ids = append(m.appendstop_ids, i...)
}

// AppendedStopIds returns the list of values that were appended to the "stop_ids" field in this mutation.
func (m *CarsFlightMutation) AppendedStopIds() ([]int, bool) {
	if len(m.appendstop_ids) == 0 {
		return nil, false
	}
	return m.appendstop_ids, true
}

// ClearStopIds clears the value of the "stop_ids" field.
func (m *CarsFlightMutation) ClearStopIds() {
	m.stop_ids = nil
	m.appendstop_ids = nil
	m.clearedFields[carsflight.FieldStopIds] = struct{}{}
}

// StopIdsCleared returns if the "stop_ids" field was cleared in this mutation.
func (m *CarsFlightMutation) StopIdsCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldStopIds]
	return ok
}

// ResetStopIds resets all changes to the "stop_ids" field.
func (m *CarsFlightMutation) ResetStopIds() {
	m.stop_ids = nil
	m.appendstop_ids = nil
	delete(m.clearedFields, carsflight.FieldStopIds)
}

// SetPassIds sets the "pass_ids" field.
func (m *CarsFlightMutation) SetPassIds(i []int) {
	m.pass_ids = &i
	m.appendpass_ids = nil
}

// PassIds returns the value of the "pass_ids" field in the mutation.
func (m *CarsFlightMutation) PassIds() (r []int, exists bool) {
	v := m.pass_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldPassIds returns the old "pass_ids" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldPassIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassIds: %w", err)
	}
	return oldValue.PassIds, nil
}

// AppendPassIds adds i to the "pass_ids" field.
func (m *CarsFlightMutation) AppendPassIds(i []int) {
	m.appendpass_ids = append(m.appendpass_ids, i...)
}

// AppendedPassIds returns the list of values that were appended to the "pass_ids" field in this mutation.
func (m *CarsFlightMutation) AppendedPassIds() ([]int, bool) {
	if len(m.appendpass_ids) == 0 {
		return nil, false
	}
	return m.appendpass_ids, true
}

// ClearPassIds clears the value of the "pass_ids" field.
func (m *CarsFlightMutation) ClearPassIds() {
	m.pass_ids = nil
	m.appendpass_ids = nil
	m.clearedFields[carsflight.FieldPassIds] = struct{}{}
}

// PassIdsCleared returns if the "pass_ids" field was cleared in this mutation.
func (m *CarsFlightMutation) PassIdsCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldPassIds]
	return ok
}

// ResetPassIds resets all changes to the "pass_ids" field.
func (m *CarsFlightMutation) ResetPassIds() {
	m.pass_ids = nil
	m.appendpass_ids = nil
	delete(m.clearedFields, carsflight.FieldPassIds)
}

// SetRemark sets the "remark" field.
func (m *CarsFlightMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CarsFlightMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CarsFlightMutation) ResetRemark() {
	m.remark = nil
}

// SetStopStock sets the "stop_stock" field.
func (m *CarsFlightMutation) SetStopStock(ts []types.StopStock) {
	m.stop_stock = &ts
	m.appendstop_stock = nil
}

// StopStock returns the value of the "stop_stock" field in the mutation.
func (m *CarsFlightMutation) StopStock() (r []types.StopStock, exists bool) {
	v := m.stop_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStopStock returns the old "stop_stock" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldStopStock(ctx context.Context) (v []types.StopStock, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopStock: %w", err)
	}
	return oldValue.StopStock, nil
}

// AppendStopStock adds ts to the "stop_stock" field.
func (m *CarsFlightMutation) AppendStopStock(ts []types.StopStock) {
	m.appendstop_stock = append(m.appendstop_stock, ts...)
}

// AppendedStopStock returns the list of values that were appended to the "stop_stock" field in this mutation.
func (m *CarsFlightMutation) AppendedStopStock() ([]types.StopStock, bool) {
	if len(m.appendstop_stock) == 0 {
		return nil, false
	}
	return m.appendstop_stock, true
}

// ResetStopStock resets all changes to the "stop_stock" field.
func (m *CarsFlightMutation) ResetStopStock() {
	m.stop_stock = nil
	m.appendstop_stock = nil
}

// SetExtendYokeeID sets the "extend_yokee_id" field.
func (m *CarsFlightMutation) SetExtendYokeeID(i int) {
	m.extend_yokee_id = &i
	m.addextend_yokee_id = nil
}

// ExtendYokeeID returns the value of the "extend_yokee_id" field in the mutation.
func (m *CarsFlightMutation) ExtendYokeeID() (r int, exists bool) {
	v := m.extend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendYokeeID returns the old "extend_yokee_id" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldExtendYokeeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendYokeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendYokeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendYokeeID: %w", err)
	}
	return oldValue.ExtendYokeeID, nil
}

// AddExtendYokeeID adds i to the "extend_yokee_id" field.
func (m *CarsFlightMutation) AddExtendYokeeID(i int) {
	if m.addextend_yokee_id != nil {
		*m.addextend_yokee_id += i
	} else {
		m.addextend_yokee_id = &i
	}
}

// AddedExtendYokeeID returns the value that was added to the "extend_yokee_id" field in this mutation.
func (m *CarsFlightMutation) AddedExtendYokeeID() (r int, exists bool) {
	v := m.addextend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtendYokeeID clears the value of the "extend_yokee_id" field.
func (m *CarsFlightMutation) ClearExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	m.clearedFields[carsflight.FieldExtendYokeeID] = struct{}{}
}

// ExtendYokeeIDCleared returns if the "extend_yokee_id" field was cleared in this mutation.
func (m *CarsFlightMutation) ExtendYokeeIDCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldExtendYokeeID]
	return ok
}

// ResetExtendYokeeID resets all changes to the "extend_yokee_id" field.
func (m *CarsFlightMutation) ResetExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	delete(m.clearedFields, carsflight.FieldExtendYokeeID)
}

// SetDepartureTime sets the "departure_time" field.
func (m *CarsFlightMutation) SetDepartureTime(t time.Time) {
	m.departure_time = &t
}

// DepartureTime returns the value of the "departure_time" field in the mutation.
func (m *CarsFlightMutation) DepartureTime() (r time.Time, exists bool) {
	v := m.departure_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureTime returns the old "departure_time" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldDepartureTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureTime: %w", err)
	}
	return oldValue.DepartureTime, nil
}

// ClearDepartureTime clears the value of the "departure_time" field.
func (m *CarsFlightMutation) ClearDepartureTime() {
	m.departure_time = nil
	m.clearedFields[carsflight.FieldDepartureTime] = struct{}{}
}

// DepartureTimeCleared returns if the "departure_time" field was cleared in this mutation.
func (m *CarsFlightMutation) DepartureTimeCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldDepartureTime]
	return ok
}

// ResetDepartureTime resets all changes to the "departure_time" field.
func (m *CarsFlightMutation) ResetDepartureTime() {
	m.departure_time = nil
	delete(m.clearedFields, carsflight.FieldDepartureTime)
}

// SetFinishTime sets the "finish_time" field.
func (m *CarsFlightMutation) SetFinishTime(t time.Time) {
	m.finish_time = &t
}

// FinishTime returns the value of the "finish_time" field in the mutation.
func (m *CarsFlightMutation) FinishTime() (r time.Time, exists bool) {
	v := m.finish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old "finish_time" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldFinishTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ClearFinishTime clears the value of the "finish_time" field.
func (m *CarsFlightMutation) ClearFinishTime() {
	m.finish_time = nil
	m.clearedFields[carsflight.FieldFinishTime] = struct{}{}
}

// FinishTimeCleared returns if the "finish_time" field was cleared in this mutation.
func (m *CarsFlightMutation) FinishTimeCleared() bool {
	_, ok := m.clearedFields[carsflight.FieldFinishTime]
	return ok
}

// ResetFinishTime resets all changes to the "finish_time" field.
func (m *CarsFlightMutation) ResetFinishTime() {
	m.finish_time = nil
	delete(m.clearedFields, carsflight.FieldFinishTime)
}

// SetCreateTime sets the "create_time" field.
func (m *CarsFlightMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsFlightMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsFlightMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsFlightMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsFlightMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsFlight entity.
// If the CarsFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsFlightMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarsFlightMutation builder.
func (m *CarsFlightMutation) Where(ps ...predicate.CarsFlight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsFlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsFlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsFlight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsFlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsFlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsFlight).
func (m *CarsFlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsFlightMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.scenic_area_id != nil {
		fields = append(fields, carsflight.FieldScenicAreaID)
	}
	if m.flight_no != nil {
		fields = append(fields, carsflight.FieldFlightNo)
	}
	if m.car_id != nil {
		fields = append(fields, carsflight.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carsflight.FieldDeviceID)
	}
	if m.car_name != nil {
		fields = append(fields, carsflight.FieldCarName)
	}
	if m.route_id != nil {
		fields = append(fields, carsflight.FieldRouteID)
	}
	if m.route_name != nil {
		fields = append(fields, carsflight.FieldRouteName)
	}
	if m.seats_num != nil {
		fields = append(fields, carsflight.FieldSeatsNum)
	}
	if m.state != nil {
		fields = append(fields, carsflight.FieldState)
	}
	if m.curr_stop_id != nil {
		fields = append(fields, carsflight.FieldCurrStopID)
	}
	if m.stop_ids != nil {
		fields = append(fields, carsflight.FieldStopIds)
	}
	if m.pass_ids != nil {
		fields = append(fields, carsflight.FieldPassIds)
	}
	if m.remark != nil {
		fields = append(fields, carsflight.FieldRemark)
	}
	if m.stop_stock != nil {
		fields = append(fields, carsflight.FieldStopStock)
	}
	if m.extend_yokee_id != nil {
		fields = append(fields, carsflight.FieldExtendYokeeID)
	}
	if m.departure_time != nil {
		fields = append(fields, carsflight.FieldDepartureTime)
	}
	if m.finish_time != nil {
		fields = append(fields, carsflight.FieldFinishTime)
	}
	if m.create_time != nil {
		fields = append(fields, carsflight.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsflight.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsFlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsflight.FieldScenicAreaID:
		return m.ScenicAreaID()
	case carsflight.FieldFlightNo:
		return m.FlightNo()
	case carsflight.FieldCarID:
		return m.CarID()
	case carsflight.FieldDeviceID:
		return m.DeviceID()
	case carsflight.FieldCarName:
		return m.CarName()
	case carsflight.FieldRouteID:
		return m.RouteID()
	case carsflight.FieldRouteName:
		return m.RouteName()
	case carsflight.FieldSeatsNum:
		return m.SeatsNum()
	case carsflight.FieldState:
		return m.State()
	case carsflight.FieldCurrStopID:
		return m.CurrStopID()
	case carsflight.FieldStopIds:
		return m.StopIds()
	case carsflight.FieldPassIds:
		return m.PassIds()
	case carsflight.FieldRemark:
		return m.Remark()
	case carsflight.FieldStopStock:
		return m.StopStock()
	case carsflight.FieldExtendYokeeID:
		return m.ExtendYokeeID()
	case carsflight.FieldDepartureTime:
		return m.DepartureTime()
	case carsflight.FieldFinishTime:
		return m.FinishTime()
	case carsflight.FieldCreateTime:
		return m.CreateTime()
	case carsflight.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsFlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsflight.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case carsflight.FieldFlightNo:
		return m.OldFlightNo(ctx)
	case carsflight.FieldCarID:
		return m.OldCarID(ctx)
	case carsflight.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carsflight.FieldCarName:
		return m.OldCarName(ctx)
	case carsflight.FieldRouteID:
		return m.OldRouteID(ctx)
	case carsflight.FieldRouteName:
		return m.OldRouteName(ctx)
	case carsflight.FieldSeatsNum:
		return m.OldSeatsNum(ctx)
	case carsflight.FieldState:
		return m.OldState(ctx)
	case carsflight.FieldCurrStopID:
		return m.OldCurrStopID(ctx)
	case carsflight.FieldStopIds:
		return m.OldStopIds(ctx)
	case carsflight.FieldPassIds:
		return m.OldPassIds(ctx)
	case carsflight.FieldRemark:
		return m.OldRemark(ctx)
	case carsflight.FieldStopStock:
		return m.OldStopStock(ctx)
	case carsflight.FieldExtendYokeeID:
		return m.OldExtendYokeeID(ctx)
	case carsflight.FieldDepartureTime:
		return m.OldDepartureTime(ctx)
	case carsflight.FieldFinishTime:
		return m.OldFinishTime(ctx)
	case carsflight.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsflight.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsFlight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsFlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsflight.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case carsflight.FieldFlightNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightNo(v)
		return nil
	case carsflight.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carsflight.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carsflight.FieldCarName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarName(v)
		return nil
	case carsflight.FieldRouteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteID(v)
		return nil
	case carsflight.FieldRouteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteName(v)
		return nil
	case carsflight.FieldSeatsNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatsNum(v)
		return nil
	case carsflight.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case carsflight.FieldCurrStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrStopID(v)
		return nil
	case carsflight.FieldStopIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopIds(v)
		return nil
	case carsflight.FieldPassIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassIds(v)
		return nil
	case carsflight.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case carsflight.FieldStopStock:
		v, ok := value.([]types.StopStock)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopStock(v)
		return nil
	case carsflight.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendYokeeID(v)
		return nil
	case carsflight.FieldDepartureTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureTime(v)
		return nil
	case carsflight.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	case carsflight.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsflight.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsFlight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsFlightMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, carsflight.FieldScenicAreaID)
	}
	if m.addcar_id != nil {
		fields = append(fields, carsflight.FieldCarID)
	}
	if m.addroute_id != nil {
		fields = append(fields, carsflight.FieldRouteID)
	}
	if m.addseats_num != nil {
		fields = append(fields, carsflight.FieldSeatsNum)
	}
	if m.addstate != nil {
		fields = append(fields, carsflight.FieldState)
	}
	if m.addcurr_stop_id != nil {
		fields = append(fields, carsflight.FieldCurrStopID)
	}
	if m.addextend_yokee_id != nil {
		fields = append(fields, carsflight.FieldExtendYokeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsFlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsflight.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case carsflight.FieldCarID:
		return m.AddedCarID()
	case carsflight.FieldRouteID:
		return m.AddedRouteID()
	case carsflight.FieldSeatsNum:
		return m.AddedSeatsNum()
	case carsflight.FieldState:
		return m.AddedState()
	case carsflight.FieldCurrStopID:
		return m.AddedCurrStopID()
	case carsflight.FieldExtendYokeeID:
		return m.AddedExtendYokeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsFlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsflight.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case carsflight.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case carsflight.FieldRouteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRouteID(v)
		return nil
	case carsflight.FieldSeatsNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeatsNum(v)
		return nil
	case carsflight.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case carsflight.FieldCurrStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrStopID(v)
		return nil
	case carsflight.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtendYokeeID(v)
		return nil
	}
	return fmt.Errorf("unknown CarsFlight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsFlightMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carsflight.FieldCurrStopID) {
		fields = append(fields, carsflight.FieldCurrStopID)
	}
	if m.FieldCleared(carsflight.FieldStopIds) {
		fields = append(fields, carsflight.FieldStopIds)
	}
	if m.FieldCleared(carsflight.FieldPassIds) {
		fields = append(fields, carsflight.FieldPassIds)
	}
	if m.FieldCleared(carsflight.FieldExtendYokeeID) {
		fields = append(fields, carsflight.FieldExtendYokeeID)
	}
	if m.FieldCleared(carsflight.FieldDepartureTime) {
		fields = append(fields, carsflight.FieldDepartureTime)
	}
	if m.FieldCleared(carsflight.FieldFinishTime) {
		fields = append(fields, carsflight.FieldFinishTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsFlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsFlightMutation) ClearField(name string) error {
	switch name {
	case carsflight.FieldCurrStopID:
		m.ClearCurrStopID()
		return nil
	case carsflight.FieldStopIds:
		m.ClearStopIds()
		return nil
	case carsflight.FieldPassIds:
		m.ClearPassIds()
		return nil
	case carsflight.FieldExtendYokeeID:
		m.ClearExtendYokeeID()
		return nil
	case carsflight.FieldDepartureTime:
		m.ClearDepartureTime()
		return nil
	case carsflight.FieldFinishTime:
		m.ClearFinishTime()
		return nil
	}
	return fmt.Errorf("unknown CarsFlight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsFlightMutation) ResetField(name string) error {
	switch name {
	case carsflight.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case carsflight.FieldFlightNo:
		m.ResetFlightNo()
		return nil
	case carsflight.FieldCarID:
		m.ResetCarID()
		return nil
	case carsflight.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carsflight.FieldCarName:
		m.ResetCarName()
		return nil
	case carsflight.FieldRouteID:
		m.ResetRouteID()
		return nil
	case carsflight.FieldRouteName:
		m.ResetRouteName()
		return nil
	case carsflight.FieldSeatsNum:
		m.ResetSeatsNum()
		return nil
	case carsflight.FieldState:
		m.ResetState()
		return nil
	case carsflight.FieldCurrStopID:
		m.ResetCurrStopID()
		return nil
	case carsflight.FieldStopIds:
		m.ResetStopIds()
		return nil
	case carsflight.FieldPassIds:
		m.ResetPassIds()
		return nil
	case carsflight.FieldRemark:
		m.ResetRemark()
		return nil
	case carsflight.FieldStopStock:
		m.ResetStopStock()
		return nil
	case carsflight.FieldExtendYokeeID:
		m.ResetExtendYokeeID()
		return nil
	case carsflight.FieldDepartureTime:
		m.ResetDepartureTime()
		return nil
	case carsflight.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	case carsflight.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsflight.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsFlight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsFlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsFlightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsFlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsFlightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsFlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsFlightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsFlightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarsFlight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsFlightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarsFlight edge %s", name)
}

// CarsFlightExtendYokeeMutation represents an operation that mutates the CarsFlightExtendYokee nodes in the graph.
type CarsFlightExtendYokeeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	flight_id            *int
	addflight_id         *int
	yokee_dispatch_id    *int
	addyokee_dispatch_id *int
	yokee_speed_limit    *float32
	addyokee_speed_limit *float32
	create_time          *time.Time
	update_time          *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*CarsFlightExtendYokee, error)
	predicates           []predicate.CarsFlightExtendYokee
}

var _ ent.Mutation = (*CarsFlightExtendYokeeMutation)(nil)

// carsflightextendyokeeOption allows management of the mutation configuration using functional options.
type carsflightextendyokeeOption func(*CarsFlightExtendYokeeMutation)

// newCarsFlightExtendYokeeMutation creates new mutation for the CarsFlightExtendYokee entity.
func newCarsFlightExtendYokeeMutation(c config, op Op, opts ...carsflightextendyokeeOption) *CarsFlightExtendYokeeMutation {
	m := &CarsFlightExtendYokeeMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsFlightExtendYokee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsFlightExtendYokeeID sets the ID field of the mutation.
func withCarsFlightExtendYokeeID(id int) carsflightextendyokeeOption {
	return func(m *CarsFlightExtendYokeeMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsFlightExtendYokee
		)
		m.oldValue = func(ctx context.Context) (*CarsFlightExtendYokee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsFlightExtendYokee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsFlightExtendYokee sets the old CarsFlightExtendYokee of the mutation.
func withCarsFlightExtendYokee(node *CarsFlightExtendYokee) carsflightextendyokeeOption {
	return func(m *CarsFlightExtendYokeeMutation) {
		m.oldValue = func(context.Context) (*CarsFlightExtendYokee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsFlightExtendYokeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsFlightExtendYokeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsFlightExtendYokee entities.
func (m *CarsFlightExtendYokeeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsFlightExtendYokeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsFlightExtendYokeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsFlightExtendYokee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlightID sets the "flight_id" field.
func (m *CarsFlightExtendYokeeMutation) SetFlightID(i int) {
	m.flight_id = &i
	m.addflight_id = nil
}

// FlightID returns the value of the "flight_id" field in the mutation.
func (m *CarsFlightExtendYokeeMutation) FlightID() (r int, exists bool) {
	v := m.flight_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightID returns the old "flight_id" field's value of the CarsFlightExtendYokee entity.
// If the CarsFlightExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightExtendYokeeMutation) OldFlightID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightID: %w", err)
	}
	return oldValue.FlightID, nil
}

// AddFlightID adds i to the "flight_id" field.
func (m *CarsFlightExtendYokeeMutation) AddFlightID(i int) {
	if m.addflight_id != nil {
		*m.addflight_id += i
	} else {
		m.addflight_id = &i
	}
}

// AddedFlightID returns the value that was added to the "flight_id" field in this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedFlightID() (r int, exists bool) {
	v := m.addflight_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlightID resets all changes to the "flight_id" field.
func (m *CarsFlightExtendYokeeMutation) ResetFlightID() {
	m.flight_id = nil
	m.addflight_id = nil
}

// SetYokeeDispatchID sets the "yokee_dispatch_id" field.
func (m *CarsFlightExtendYokeeMutation) SetYokeeDispatchID(i int) {
	m.yokee_dispatch_id = &i
	m.addyokee_dispatch_id = nil
}

// YokeeDispatchID returns the value of the "yokee_dispatch_id" field in the mutation.
func (m *CarsFlightExtendYokeeMutation) YokeeDispatchID() (r int, exists bool) {
	v := m.yokee_dispatch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeDispatchID returns the old "yokee_dispatch_id" field's value of the CarsFlightExtendYokee entity.
// If the CarsFlightExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightExtendYokeeMutation) OldYokeeDispatchID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeDispatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeDispatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeDispatchID: %w", err)
	}
	return oldValue.YokeeDispatchID, nil
}

// AddYokeeDispatchID adds i to the "yokee_dispatch_id" field.
func (m *CarsFlightExtendYokeeMutation) AddYokeeDispatchID(i int) {
	if m.addyokee_dispatch_id != nil {
		*m.addyokee_dispatch_id += i
	} else {
		m.addyokee_dispatch_id = &i
	}
}

// AddedYokeeDispatchID returns the value that was added to the "yokee_dispatch_id" field in this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedYokeeDispatchID() (r int, exists bool) {
	v := m.addyokee_dispatch_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeDispatchID resets all changes to the "yokee_dispatch_id" field.
func (m *CarsFlightExtendYokeeMutation) ResetYokeeDispatchID() {
	m.yokee_dispatch_id = nil
	m.addyokee_dispatch_id = nil
}

// SetYokeeSpeedLimit sets the "yokee_speed_limit" field.
func (m *CarsFlightExtendYokeeMutation) SetYokeeSpeedLimit(f float32) {
	m.yokee_speed_limit = &f
	m.addyokee_speed_limit = nil
}

// YokeeSpeedLimit returns the value of the "yokee_speed_limit" field in the mutation.
func (m *CarsFlightExtendYokeeMutation) YokeeSpeedLimit() (r float32, exists bool) {
	v := m.yokee_speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeSpeedLimit returns the old "yokee_speed_limit" field's value of the CarsFlightExtendYokee entity.
// If the CarsFlightExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightExtendYokeeMutation) OldYokeeSpeedLimit(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeSpeedLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeSpeedLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeSpeedLimit: %w", err)
	}
	return oldValue.YokeeSpeedLimit, nil
}

// AddYokeeSpeedLimit adds f to the "yokee_speed_limit" field.
func (m *CarsFlightExtendYokeeMutation) AddYokeeSpeedLimit(f float32) {
	if m.addyokee_speed_limit != nil {
		*m.addyokee_speed_limit += f
	} else {
		m.addyokee_speed_limit = &f
	}
}

// AddedYokeeSpeedLimit returns the value that was added to the "yokee_speed_limit" field in this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedYokeeSpeedLimit() (r float32, exists bool) {
	v := m.addyokee_speed_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeSpeedLimit resets all changes to the "yokee_speed_limit" field.
func (m *CarsFlightExtendYokeeMutation) ResetYokeeSpeedLimit() {
	m.yokee_speed_limit = nil
	m.addyokee_speed_limit = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarsFlightExtendYokeeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsFlightExtendYokeeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsFlightExtendYokee entity.
// If the CarsFlightExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightExtendYokeeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsFlightExtendYokeeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsFlightExtendYokeeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsFlightExtendYokeeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsFlightExtendYokee entity.
// If the CarsFlightExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsFlightExtendYokeeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsFlightExtendYokeeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CarsFlightExtendYokeeMutation builder.
func (m *CarsFlightExtendYokeeMutation) Where(ps ...predicate.CarsFlightExtendYokee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsFlightExtendYokeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsFlightExtendYokeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsFlightExtendYokee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsFlightExtendYokeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsFlightExtendYokeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsFlightExtendYokee).
func (m *CarsFlightExtendYokeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsFlightExtendYokeeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.flight_id != nil {
		fields = append(fields, carsflightextendyokee.FieldFlightID)
	}
	if m.yokee_dispatch_id != nil {
		fields = append(fields, carsflightextendyokee.FieldYokeeDispatchID)
	}
	if m.yokee_speed_limit != nil {
		fields = append(fields, carsflightextendyokee.FieldYokeeSpeedLimit)
	}
	if m.create_time != nil {
		fields = append(fields, carsflightextendyokee.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsflightextendyokee.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsFlightExtendYokeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		return m.FlightID()
	case carsflightextendyokee.FieldYokeeDispatchID:
		return m.YokeeDispatchID()
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		return m.YokeeSpeedLimit()
	case carsflightextendyokee.FieldCreateTime:
		return m.CreateTime()
	case carsflightextendyokee.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsFlightExtendYokeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		return m.OldFlightID(ctx)
	case carsflightextendyokee.FieldYokeeDispatchID:
		return m.OldYokeeDispatchID(ctx)
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		return m.OldYokeeSpeedLimit(ctx)
	case carsflightextendyokee.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsflightextendyokee.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsFlightExtendYokee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsFlightExtendYokeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightID(v)
		return nil
	case carsflightextendyokee.FieldYokeeDispatchID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeDispatchID(v)
		return nil
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeSpeedLimit(v)
		return nil
	case carsflightextendyokee.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsflightextendyokee.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsFlightExtendYokee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedFields() []string {
	var fields []string
	if m.addflight_id != nil {
		fields = append(fields, carsflightextendyokee.FieldFlightID)
	}
	if m.addyokee_dispatch_id != nil {
		fields = append(fields, carsflightextendyokee.FieldYokeeDispatchID)
	}
	if m.addyokee_speed_limit != nil {
		fields = append(fields, carsflightextendyokee.FieldYokeeSpeedLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsFlightExtendYokeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		return m.AddedFlightID()
	case carsflightextendyokee.FieldYokeeDispatchID:
		return m.AddedYokeeDispatchID()
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		return m.AddedYokeeSpeedLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsFlightExtendYokeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlightID(v)
		return nil
	case carsflightextendyokee.FieldYokeeDispatchID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeDispatchID(v)
		return nil
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeSpeedLimit(v)
		return nil
	}
	return fmt.Errorf("unknown CarsFlightExtendYokee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsFlightExtendYokeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsFlightExtendYokeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsFlightExtendYokeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarsFlightExtendYokee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsFlightExtendYokeeMutation) ResetField(name string) error {
	switch name {
	case carsflightextendyokee.FieldFlightID:
		m.ResetFlightID()
		return nil
	case carsflightextendyokee.FieldYokeeDispatchID:
		m.ResetYokeeDispatchID()
		return nil
	case carsflightextendyokee.FieldYokeeSpeedLimit:
		m.ResetYokeeSpeedLimit()
		return nil
	case carsflightextendyokee.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsflightextendyokee.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsFlightExtendYokee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsFlightExtendYokeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsFlightExtendYokeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsFlightExtendYokeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsFlightExtendYokeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsFlightExtendYokeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsFlightExtendYokeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CarsFlightExtendYokee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsFlightExtendYokeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CarsFlightExtendYokee edge %s", name)
}

// CarsModelsMutation represents an operation that mutates the CarsModels nodes in the graph.
type CarsModelsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	model_name          *string
	model_remark        *string
	group_count         *int
	addgroup_count      *int
	status              *int
	addstatus           *int
	car_incr            *int
	addcar_incr         *int
	is_deleted          *int
	addis_deleted       *int
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	cars                map[int]struct{}
	removedcars         map[int]struct{}
	clearedcars         bool
	groups              map[int]struct{}
	removedgroups       map[int]struct{}
	clearedgroups       bool
	params              map[int]struct{}
	removedparams       map[int]struct{}
	clearedparams       bool
	config_files        map[int]struct{}
	removedconfig_files map[int]struct{}
	clearedconfig_files bool
	done                bool
	oldValue            func(context.Context) (*CarsModels, error)
	predicates          []predicate.CarsModels
}

var _ ent.Mutation = (*CarsModelsMutation)(nil)

// carsmodelsOption allows management of the mutation configuration using functional options.
type carsmodelsOption func(*CarsModelsMutation)

// newCarsModelsMutation creates new mutation for the CarsModels entity.
func newCarsModelsMutation(c config, op Op, opts ...carsmodelsOption) *CarsModelsMutation {
	m := &CarsModelsMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsModels,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsModelsID sets the ID field of the mutation.
func withCarsModelsID(id int) carsmodelsOption {
	return func(m *CarsModelsMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsModels
		)
		m.oldValue = func(ctx context.Context) (*CarsModels, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsModels.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsModels sets the old CarsModels of the mutation.
func withCarsModels(node *CarsModels) carsmodelsOption {
	return func(m *CarsModelsMutation) {
		m.oldValue = func(context.Context) (*CarsModels, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsModelsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsModelsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsModels entities.
func (m *CarsModelsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsModelsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsModelsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsModels.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModelName sets the "model_name" field.
func (m *CarsModelsMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *CarsModelsMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ResetModelName resets all changes to the "model_name" field.
func (m *CarsModelsMutation) ResetModelName() {
	m.model_name = nil
}

// SetModelRemark sets the "model_remark" field.
func (m *CarsModelsMutation) SetModelRemark(s string) {
	m.model_remark = &s
}

// ModelRemark returns the value of the "model_remark" field in the mutation.
func (m *CarsModelsMutation) ModelRemark() (r string, exists bool) {
	v := m.model_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldModelRemark returns the old "model_remark" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldModelRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelRemark: %w", err)
	}
	return oldValue.ModelRemark, nil
}

// ResetModelRemark resets all changes to the "model_remark" field.
func (m *CarsModelsMutation) ResetModelRemark() {
	m.model_remark = nil
}

// SetGroupCount sets the "group_count" field.
func (m *CarsModelsMutation) SetGroupCount(i int) {
	m.group_count = &i
	m.addgroup_count = nil
}

// GroupCount returns the value of the "group_count" field in the mutation.
func (m *CarsModelsMutation) GroupCount() (r int, exists bool) {
	v := m.group_count
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupCount returns the old "group_count" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldGroupCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupCount: %w", err)
	}
	return oldValue.GroupCount, nil
}

// AddGroupCount adds i to the "group_count" field.
func (m *CarsModelsMutation) AddGroupCount(i int) {
	if m.addgroup_count != nil {
		*m.addgroup_count += i
	} else {
		m.addgroup_count = &i
	}
}

// AddedGroupCount returns the value that was added to the "group_count" field in this mutation.
func (m *CarsModelsMutation) AddedGroupCount() (r int, exists bool) {
	v := m.addgroup_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupCount resets all changes to the "group_count" field.
func (m *CarsModelsMutation) ResetGroupCount() {
	m.group_count = nil
	m.addgroup_count = nil
}

// SetStatus sets the "status" field.
func (m *CarsModelsMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CarsModelsMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CarsModelsMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CarsModelsMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CarsModelsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCarIncr sets the "car_incr" field.
func (m *CarsModelsMutation) SetCarIncr(i int) {
	m.car_incr = &i
	m.addcar_incr = nil
}

// CarIncr returns the value of the "car_incr" field in the mutation.
func (m *CarsModelsMutation) CarIncr() (r int, exists bool) {
	v := m.car_incr
	if v == nil {
		return
	}
	return *v, true
}

// OldCarIncr returns the old "car_incr" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldCarIncr(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarIncr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarIncr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarIncr: %w", err)
	}
	return oldValue.CarIncr, nil
}

// AddCarIncr adds i to the "car_incr" field.
func (m *CarsModelsMutation) AddCarIncr(i int) {
	if m.addcar_incr != nil {
		*m.addcar_incr += i
	} else {
		m.addcar_incr = &i
	}
}

// AddedCarIncr returns the value that was added to the "car_incr" field in this mutation.
func (m *CarsModelsMutation) AddedCarIncr() (r int, exists bool) {
	v := m.addcar_incr
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarIncr resets all changes to the "car_incr" field.
func (m *CarsModelsMutation) ResetCarIncr() {
	m.car_incr = nil
	m.addcar_incr = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CarsModelsMutation) SetIsDeleted(i int) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CarsModelsMutation) IsDeleted() (r int, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldIsDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *CarsModelsMutation) AddIsDeleted(i int) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *CarsModelsMutation) AddedIsDeleted() (r int, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CarsModelsMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarsModelsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsModelsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsModelsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsModelsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsModelsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsModels entity.
// If the CarsModels object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsModelsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddCarIDs adds the "cars" edge to the Car entity by ids.
func (m *CarsModelsMutation) AddCarIDs(ids ...int) {
	if m.cars == nil {
		m.cars = make(map[int]struct{})
	}
	for i := range ids {
		m.cars[ids[i]] = struct{}{}
	}
}

// ClearCars clears the "cars" edge to the Car entity.
func (m *CarsModelsMutation) ClearCars() {
	m.clearedcars = true
}

// CarsCleared reports if the "cars" edge to the Car entity was cleared.
func (m *CarsModelsMutation) CarsCleared() bool {
	return m.clearedcars
}

// RemoveCarIDs removes the "cars" edge to the Car entity by IDs.
func (m *CarsModelsMutation) RemoveCarIDs(ids ...int) {
	if m.removedcars == nil {
		m.removedcars = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cars, ids[i])
		m.removedcars[ids[i]] = struct{}{}
	}
}

// RemovedCars returns the removed IDs of the "cars" edge to the Car entity.
func (m *CarsModelsMutation) RemovedCarsIDs() (ids []int) {
	for id := range m.removedcars {
		ids = append(ids, id)
	}
	return
}

// CarsIDs returns the "cars" edge IDs in the mutation.
func (m *CarsModelsMutation) CarsIDs() (ids []int) {
	for id := range m.cars {
		ids = append(ids, id)
	}
	return
}

// ResetCars resets all changes to the "cars" edge.
func (m *CarsModelsMutation) ResetCars() {
	m.cars = nil
	m.clearedcars = false
	m.removedcars = nil
}

// AddGroupIDs adds the "groups" edge to the CarsModelsGroups entity by ids.
func (m *CarsModelsMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the CarsModelsGroups entity.
func (m *CarsModelsMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the CarsModelsGroups entity was cleared.
func (m *CarsModelsMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the CarsModelsGroups entity by IDs.
func (m *CarsModelsMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the CarsModelsGroups entity.
func (m *CarsModelsMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *CarsModelsMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *CarsModelsMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddParamIDs adds the "params" edge to the CarsModelsGroupsParams entity by ids.
func (m *CarsModelsMutation) AddParamIDs(ids ...int) {
	if m.params == nil {
		m.params = make(map[int]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the CarsModelsGroupsParams entity.
func (m *CarsModelsMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the CarsModelsGroupsParams entity was cleared.
func (m *CarsModelsMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the CarsModelsGroupsParams entity by IDs.
func (m *CarsModelsMutation) RemoveParamIDs(ids ...int) {
	if m.removedparams == nil {
		m.removedparams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the CarsModelsGroupsParams entity.
func (m *CarsModelsMutation) RemovedParamsIDs() (ids []int) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *CarsModelsMutation) ParamsIDs() (ids []int) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *CarsModelsMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// AddConfigFileIDs adds the "config_files" edge to the CarConfig entity by ids.
func (m *CarsModelsMutation) AddConfigFileIDs(ids ...int) {
	if m.config_files == nil {
		m.config_files = make(map[int]struct{})
	}
	for i := range ids {
		m.config_files[ids[i]] = struct{}{}
	}
}

// ClearConfigFiles clears the "config_files" edge to the CarConfig entity.
func (m *CarsModelsMutation) ClearConfigFiles() {
	m.clearedconfig_files = true
}

// ConfigFilesCleared reports if the "config_files" edge to the CarConfig entity was cleared.
func (m *CarsModelsMutation) ConfigFilesCleared() bool {
	return m.clearedconfig_files
}

// RemoveConfigFileIDs removes the "config_files" edge to the CarConfig entity by IDs.
func (m *CarsModelsMutation) RemoveConfigFileIDs(ids ...int) {
	if m.removedconfig_files == nil {
		m.removedconfig_files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.config_files, ids[i])
		m.removedconfig_files[ids[i]] = struct{}{}
	}
}

// RemovedConfigFiles returns the removed IDs of the "config_files" edge to the CarConfig entity.
func (m *CarsModelsMutation) RemovedConfigFilesIDs() (ids []int) {
	for id := range m.removedconfig_files {
		ids = append(ids, id)
	}
	return
}

// ConfigFilesIDs returns the "config_files" edge IDs in the mutation.
func (m *CarsModelsMutation) ConfigFilesIDs() (ids []int) {
	for id := range m.config_files {
		ids = append(ids, id)
	}
	return
}

// ResetConfigFiles resets all changes to the "config_files" edge.
func (m *CarsModelsMutation) ResetConfigFiles() {
	m.config_files = nil
	m.clearedconfig_files = false
	m.removedconfig_files = nil
}

// Where appends a list predicates to the CarsModelsMutation builder.
func (m *CarsModelsMutation) Where(ps ...predicate.CarsModels) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsModelsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsModelsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsModels, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsModelsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsModelsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsModels).
func (m *CarsModelsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsModelsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.model_name != nil {
		fields = append(fields, carsmodels.FieldModelName)
	}
	if m.model_remark != nil {
		fields = append(fields, carsmodels.FieldModelRemark)
	}
	if m.group_count != nil {
		fields = append(fields, carsmodels.FieldGroupCount)
	}
	if m.status != nil {
		fields = append(fields, carsmodels.FieldStatus)
	}
	if m.car_incr != nil {
		fields = append(fields, carsmodels.FieldCarIncr)
	}
	if m.is_deleted != nil {
		fields = append(fields, carsmodels.FieldIsDeleted)
	}
	if m.create_time != nil {
		fields = append(fields, carsmodels.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsmodels.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsModelsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsmodels.FieldModelName:
		return m.ModelName()
	case carsmodels.FieldModelRemark:
		return m.ModelRemark()
	case carsmodels.FieldGroupCount:
		return m.GroupCount()
	case carsmodels.FieldStatus:
		return m.Status()
	case carsmodels.FieldCarIncr:
		return m.CarIncr()
	case carsmodels.FieldIsDeleted:
		return m.IsDeleted()
	case carsmodels.FieldCreateTime:
		return m.CreateTime()
	case carsmodels.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsModelsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsmodels.FieldModelName:
		return m.OldModelName(ctx)
	case carsmodels.FieldModelRemark:
		return m.OldModelRemark(ctx)
	case carsmodels.FieldGroupCount:
		return m.OldGroupCount(ctx)
	case carsmodels.FieldStatus:
		return m.OldStatus(ctx)
	case carsmodels.FieldCarIncr:
		return m.OldCarIncr(ctx)
	case carsmodels.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case carsmodels.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsmodels.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsModels field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsmodels.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case carsmodels.FieldModelRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelRemark(v)
		return nil
	case carsmodels.FieldGroupCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupCount(v)
		return nil
	case carsmodels.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case carsmodels.FieldCarIncr:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarIncr(v)
		return nil
	case carsmodels.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case carsmodels.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsmodels.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModels field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsModelsMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_count != nil {
		fields = append(fields, carsmodels.FieldGroupCount)
	}
	if m.addstatus != nil {
		fields = append(fields, carsmodels.FieldStatus)
	}
	if m.addcar_incr != nil {
		fields = append(fields, carsmodels.FieldCarIncr)
	}
	if m.addis_deleted != nil {
		fields = append(fields, carsmodels.FieldIsDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsModelsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsmodels.FieldGroupCount:
		return m.AddedGroupCount()
	case carsmodels.FieldStatus:
		return m.AddedStatus()
	case carsmodels.FieldCarIncr:
		return m.AddedCarIncr()
	case carsmodels.FieldIsDeleted:
		return m.AddedIsDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsmodels.FieldGroupCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupCount(v)
		return nil
	case carsmodels.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case carsmodels.FieldCarIncr:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarIncr(v)
		return nil
	case carsmodels.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModels numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsModelsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsModelsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsModelsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarsModels nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsModelsMutation) ResetField(name string) error {
	switch name {
	case carsmodels.FieldModelName:
		m.ResetModelName()
		return nil
	case carsmodels.FieldModelRemark:
		m.ResetModelRemark()
		return nil
	case carsmodels.FieldGroupCount:
		m.ResetGroupCount()
		return nil
	case carsmodels.FieldStatus:
		m.ResetStatus()
		return nil
	case carsmodels.FieldCarIncr:
		m.ResetCarIncr()
		return nil
	case carsmodels.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case carsmodels.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsmodels.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsModels field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsModelsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cars != nil {
		edges = append(edges, carsmodels.EdgeCars)
	}
	if m.groups != nil {
		edges = append(edges, carsmodels.EdgeGroups)
	}
	if m.params != nil {
		edges = append(edges, carsmodels.EdgeParams)
	}
	if m.config_files != nil {
		edges = append(edges, carsmodels.EdgeConfigFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsModelsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carsmodels.EdgeCars:
		ids := make([]ent.Value, 0, len(m.cars))
		for id := range m.cars {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.config_files))
		for id := range m.config_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsModelsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcars != nil {
		edges = append(edges, carsmodels.EdgeCars)
	}
	if m.removedgroups != nil {
		edges = append(edges, carsmodels.EdgeGroups)
	}
	if m.removedparams != nil {
		edges = append(edges, carsmodels.EdgeParams)
	}
	if m.removedconfig_files != nil {
		edges = append(edges, carsmodels.EdgeConfigFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsModelsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carsmodels.EdgeCars:
		ids := make([]ent.Value, 0, len(m.removedcars))
		for id := range m.removedcars {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	case carsmodels.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.removedconfig_files))
		for id := range m.removedconfig_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsModelsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcars {
		edges = append(edges, carsmodels.EdgeCars)
	}
	if m.clearedgroups {
		edges = append(edges, carsmodels.EdgeGroups)
	}
	if m.clearedparams {
		edges = append(edges, carsmodels.EdgeParams)
	}
	if m.clearedconfig_files {
		edges = append(edges, carsmodels.EdgeConfigFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsModelsMutation) EdgeCleared(name string) bool {
	switch name {
	case carsmodels.EdgeCars:
		return m.clearedcars
	case carsmodels.EdgeGroups:
		return m.clearedgroups
	case carsmodels.EdgeParams:
		return m.clearedparams
	case carsmodels.EdgeConfigFiles:
		return m.clearedconfig_files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsModelsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarsModels unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsModelsMutation) ResetEdge(name string) error {
	switch name {
	case carsmodels.EdgeCars:
		m.ResetCars()
		return nil
	case carsmodels.EdgeGroups:
		m.ResetGroups()
		return nil
	case carsmodels.EdgeParams:
		m.ResetParams()
		return nil
	case carsmodels.EdgeConfigFiles:
		m.ResetConfigFiles()
		return nil
	}
	return fmt.Errorf("unknown CarsModels edge %s", name)
}

// CarsModelsGroupsMutation represents an operation that mutates the CarsModelsGroups nodes in the graph.
type CarsModelsGroupsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	group_remark  *string
	group_name    *string
	status        *int
	addstatus     *int
	is_deleted    *int
	addis_deleted *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	model         *int
	clearedmodel  bool
	params        map[int]struct{}
	removedparams map[int]struct{}
	clearedparams bool
	done          bool
	oldValue      func(context.Context) (*CarsModelsGroups, error)
	predicates    []predicate.CarsModelsGroups
}

var _ ent.Mutation = (*CarsModelsGroupsMutation)(nil)

// carsmodelsgroupsOption allows management of the mutation configuration using functional options.
type carsmodelsgroupsOption func(*CarsModelsGroupsMutation)

// newCarsModelsGroupsMutation creates new mutation for the CarsModelsGroups entity.
func newCarsModelsGroupsMutation(c config, op Op, opts ...carsmodelsgroupsOption) *CarsModelsGroupsMutation {
	m := &CarsModelsGroupsMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsModelsGroups,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsModelsGroupsID sets the ID field of the mutation.
func withCarsModelsGroupsID(id int) carsmodelsgroupsOption {
	return func(m *CarsModelsGroupsMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsModelsGroups
		)
		m.oldValue = func(ctx context.Context) (*CarsModelsGroups, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsModelsGroups.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsModelsGroups sets the old CarsModelsGroups of the mutation.
func withCarsModelsGroups(node *CarsModelsGroups) carsmodelsgroupsOption {
	return func(m *CarsModelsGroupsMutation) {
		m.oldValue = func(context.Context) (*CarsModelsGroups, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsModelsGroupsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsModelsGroupsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsModelsGroups entities.
func (m *CarsModelsGroupsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsModelsGroupsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsModelsGroupsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsModelsGroups.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModelID sets the "model_id" field.
func (m *CarsModelsGroupsMutation) SetModelID(i int) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CarsModelsGroupsMutation) ModelID() (r int, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CarsModelsGroupsMutation) ResetModelID() {
	m.model = nil
}

// SetGroupRemark sets the "group_remark" field.
func (m *CarsModelsGroupsMutation) SetGroupRemark(s string) {
	m.group_remark = &s
}

// GroupRemark returns the value of the "group_remark" field in the mutation.
func (m *CarsModelsGroupsMutation) GroupRemark() (r string, exists bool) {
	v := m.group_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupRemark returns the old "group_remark" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldGroupRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupRemark: %w", err)
	}
	return oldValue.GroupRemark, nil
}

// ResetGroupRemark resets all changes to the "group_remark" field.
func (m *CarsModelsGroupsMutation) ResetGroupRemark() {
	m.group_remark = nil
}

// SetGroupName sets the "group_name" field.
func (m *CarsModelsGroupsMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *CarsModelsGroupsMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *CarsModelsGroupsMutation) ResetGroupName() {
	m.group_name = nil
}

// SetStatus sets the "status" field.
func (m *CarsModelsGroupsMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CarsModelsGroupsMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CarsModelsGroupsMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CarsModelsGroupsMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CarsModelsGroupsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CarsModelsGroupsMutation) SetIsDeleted(i int) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CarsModelsGroupsMutation) IsDeleted() (r int, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldIsDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *CarsModelsGroupsMutation) AddIsDeleted(i int) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *CarsModelsGroupsMutation) AddedIsDeleted() (r int, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CarsModelsGroupsMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarsModelsGroupsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsModelsGroupsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsModelsGroupsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsModelsGroupsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsModelsGroupsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsModelsGroups entity.
// If the CarsModelsGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsModelsGroupsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearModel clears the "model" edge to the CarsModels entity.
func (m *CarsModelsGroupsMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[carsmodelsgroups.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the CarsModels entity was cleared.
func (m *CarsModelsGroupsMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *CarsModelsGroupsMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *CarsModelsGroupsMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// AddParamIDs adds the "params" edge to the CarsModelsGroupsParams entity by ids.
func (m *CarsModelsGroupsMutation) AddParamIDs(ids ...int) {
	if m.params == nil {
		m.params = make(map[int]struct{})
	}
	for i := range ids {
		m.params[ids[i]] = struct{}{}
	}
}

// ClearParams clears the "params" edge to the CarsModelsGroupsParams entity.
func (m *CarsModelsGroupsMutation) ClearParams() {
	m.clearedparams = true
}

// ParamsCleared reports if the "params" edge to the CarsModelsGroupsParams entity was cleared.
func (m *CarsModelsGroupsMutation) ParamsCleared() bool {
	return m.clearedparams
}

// RemoveParamIDs removes the "params" edge to the CarsModelsGroupsParams entity by IDs.
func (m *CarsModelsGroupsMutation) RemoveParamIDs(ids ...int) {
	if m.removedparams == nil {
		m.removedparams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.params, ids[i])
		m.removedparams[ids[i]] = struct{}{}
	}
}

// RemovedParams returns the removed IDs of the "params" edge to the CarsModelsGroupsParams entity.
func (m *CarsModelsGroupsMutation) RemovedParamsIDs() (ids []int) {
	for id := range m.removedparams {
		ids = append(ids, id)
	}
	return
}

// ParamsIDs returns the "params" edge IDs in the mutation.
func (m *CarsModelsGroupsMutation) ParamsIDs() (ids []int) {
	for id := range m.params {
		ids = append(ids, id)
	}
	return
}

// ResetParams resets all changes to the "params" edge.
func (m *CarsModelsGroupsMutation) ResetParams() {
	m.params = nil
	m.clearedparams = false
	m.removedparams = nil
}

// Where appends a list predicates to the CarsModelsGroupsMutation builder.
func (m *CarsModelsGroupsMutation) Where(ps ...predicate.CarsModelsGroups) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsModelsGroupsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsModelsGroupsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsModelsGroups, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsModelsGroupsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsModelsGroupsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsModelsGroups).
func (m *CarsModelsGroupsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsModelsGroupsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.model != nil {
		fields = append(fields, carsmodelsgroups.FieldModelID)
	}
	if m.group_remark != nil {
		fields = append(fields, carsmodelsgroups.FieldGroupRemark)
	}
	if m.group_name != nil {
		fields = append(fields, carsmodelsgroups.FieldGroupName)
	}
	if m.status != nil {
		fields = append(fields, carsmodelsgroups.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, carsmodelsgroups.FieldIsDeleted)
	}
	if m.create_time != nil {
		fields = append(fields, carsmodelsgroups.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsmodelsgroups.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsModelsGroupsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsmodelsgroups.FieldModelID:
		return m.ModelID()
	case carsmodelsgroups.FieldGroupRemark:
		return m.GroupRemark()
	case carsmodelsgroups.FieldGroupName:
		return m.GroupName()
	case carsmodelsgroups.FieldStatus:
		return m.Status()
	case carsmodelsgroups.FieldIsDeleted:
		return m.IsDeleted()
	case carsmodelsgroups.FieldCreateTime:
		return m.CreateTime()
	case carsmodelsgroups.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsModelsGroupsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsmodelsgroups.FieldModelID:
		return m.OldModelID(ctx)
	case carsmodelsgroups.FieldGroupRemark:
		return m.OldGroupRemark(ctx)
	case carsmodelsgroups.FieldGroupName:
		return m.OldGroupName(ctx)
	case carsmodelsgroups.FieldStatus:
		return m.OldStatus(ctx)
	case carsmodelsgroups.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case carsmodelsgroups.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsmodelsgroups.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsModelsGroups field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsGroupsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsmodelsgroups.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case carsmodelsgroups.FieldGroupRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupRemark(v)
		return nil
	case carsmodelsgroups.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case carsmodelsgroups.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case carsmodelsgroups.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case carsmodelsgroups.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsmodelsgroups.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroups field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsModelsGroupsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, carsmodelsgroups.FieldStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, carsmodelsgroups.FieldIsDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsModelsGroupsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsmodelsgroups.FieldStatus:
		return m.AddedStatus()
	case carsmodelsgroups.FieldIsDeleted:
		return m.AddedIsDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsGroupsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsmodelsgroups.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case carsmodelsgroups.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroups numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsModelsGroupsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsModelsGroupsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsModelsGroupsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarsModelsGroups nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsModelsGroupsMutation) ResetField(name string) error {
	switch name {
	case carsmodelsgroups.FieldModelID:
		m.ResetModelID()
		return nil
	case carsmodelsgroups.FieldGroupRemark:
		m.ResetGroupRemark()
		return nil
	case carsmodelsgroups.FieldGroupName:
		m.ResetGroupName()
		return nil
	case carsmodelsgroups.FieldStatus:
		m.ResetStatus()
		return nil
	case carsmodelsgroups.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case carsmodelsgroups.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsmodelsgroups.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroups field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsModelsGroupsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.model != nil {
		edges = append(edges, carsmodelsgroups.EdgeModel)
	}
	if m.params != nil {
		edges = append(edges, carsmodelsgroups.EdgeParams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsModelsGroupsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carsmodelsgroups.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case carsmodelsgroups.EdgeParams:
		ids := make([]ent.Value, 0, len(m.params))
		for id := range m.params {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsModelsGroupsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedparams != nil {
		edges = append(edges, carsmodelsgroups.EdgeParams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsModelsGroupsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carsmodelsgroups.EdgeParams:
		ids := make([]ent.Value, 0, len(m.removedparams))
		for id := range m.removedparams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsModelsGroupsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmodel {
		edges = append(edges, carsmodelsgroups.EdgeModel)
	}
	if m.clearedparams {
		edges = append(edges, carsmodelsgroups.EdgeParams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsModelsGroupsMutation) EdgeCleared(name string) bool {
	switch name {
	case carsmodelsgroups.EdgeModel:
		return m.clearedmodel
	case carsmodelsgroups.EdgeParams:
		return m.clearedparams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsModelsGroupsMutation) ClearEdge(name string) error {
	switch name {
	case carsmodelsgroups.EdgeModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroups unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsModelsGroupsMutation) ResetEdge(name string) error {
	switch name {
	case carsmodelsgroups.EdgeModel:
		m.ResetModel()
		return nil
	case carsmodelsgroups.EdgeParams:
		m.ResetParams()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroups edge %s", name)
}

// CarsModelsGroupsParamsMutation represents an operation that mutates the CarsModelsGroupsParams nodes in the graph.
type CarsModelsGroupsParamsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	param_remark  *string
	param_name    *string
	param_type    *carsmodelsgroupsparams.ParamType
	value_range   *string
	status        *int
	addstatus     *int
	is_deleted    *int
	addis_deleted *int
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	model         *int
	clearedmodel  bool
	group         *int
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*CarsModelsGroupsParams, error)
	predicates    []predicate.CarsModelsGroupsParams
}

var _ ent.Mutation = (*CarsModelsGroupsParamsMutation)(nil)

// carsmodelsgroupsparamsOption allows management of the mutation configuration using functional options.
type carsmodelsgroupsparamsOption func(*CarsModelsGroupsParamsMutation)

// newCarsModelsGroupsParamsMutation creates new mutation for the CarsModelsGroupsParams entity.
func newCarsModelsGroupsParamsMutation(c config, op Op, opts ...carsmodelsgroupsparamsOption) *CarsModelsGroupsParamsMutation {
	m := &CarsModelsGroupsParamsMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsModelsGroupsParams,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsModelsGroupsParamsID sets the ID field of the mutation.
func withCarsModelsGroupsParamsID(id int) carsmodelsgroupsparamsOption {
	return func(m *CarsModelsGroupsParamsMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsModelsGroupsParams
		)
		m.oldValue = func(ctx context.Context) (*CarsModelsGroupsParams, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsModelsGroupsParams.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsModelsGroupsParams sets the old CarsModelsGroupsParams of the mutation.
func withCarsModelsGroupsParams(node *CarsModelsGroupsParams) carsmodelsgroupsparamsOption {
	return func(m *CarsModelsGroupsParamsMutation) {
		m.oldValue = func(context.Context) (*CarsModelsGroupsParams, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsModelsGroupsParamsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsModelsGroupsParamsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsModelsGroupsParams entities.
func (m *CarsModelsGroupsParamsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsModelsGroupsParamsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsModelsGroupsParamsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsModelsGroupsParams.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModelID sets the "model_id" field.
func (m *CarsModelsGroupsParamsMutation) SetModelID(i int) {
	m.model = &i
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) ModelID() (r int, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *CarsModelsGroupsParamsMutation) ResetModelID() {
	m.model = nil
}

// SetGroupID sets the "group_id" field.
func (m *CarsModelsGroupsParamsMutation) SetGroupID(i int) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) GroupID() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *CarsModelsGroupsParamsMutation) ResetGroupID() {
	m.group = nil
}

// SetParamRemark sets the "param_remark" field.
func (m *CarsModelsGroupsParamsMutation) SetParamRemark(s string) {
	m.param_remark = &s
}

// ParamRemark returns the value of the "param_remark" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) ParamRemark() (r string, exists bool) {
	v := m.param_remark
	if v == nil {
		return
	}
	return *v, true
}

// OldParamRemark returns the old "param_remark" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldParamRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParamRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParamRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParamRemark: %w", err)
	}
	return oldValue.ParamRemark, nil
}

// ResetParamRemark resets all changes to the "param_remark" field.
func (m *CarsModelsGroupsParamsMutation) ResetParamRemark() {
	m.param_remark = nil
}

// SetParamName sets the "param_name" field.
func (m *CarsModelsGroupsParamsMutation) SetParamName(s string) {
	m.param_name = &s
}

// ParamName returns the value of the "param_name" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) ParamName() (r string, exists bool) {
	v := m.param_name
	if v == nil {
		return
	}
	return *v, true
}

// OldParamName returns the old "param_name" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldParamName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParamName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParamName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParamName: %w", err)
	}
	return oldValue.ParamName, nil
}

// ResetParamName resets all changes to the "param_name" field.
func (m *CarsModelsGroupsParamsMutation) ResetParamName() {
	m.param_name = nil
}

// SetParamType sets the "param_type" field.
func (m *CarsModelsGroupsParamsMutation) SetParamType(ct carsmodelsgroupsparams.ParamType) {
	m.param_type = &ct
}

// ParamType returns the value of the "param_type" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) ParamType() (r carsmodelsgroupsparams.ParamType, exists bool) {
	v := m.param_type
	if v == nil {
		return
	}
	return *v, true
}

// OldParamType returns the old "param_type" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldParamType(ctx context.Context) (v carsmodelsgroupsparams.ParamType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParamType: %w", err)
	}
	return oldValue.ParamType, nil
}

// ResetParamType resets all changes to the "param_type" field.
func (m *CarsModelsGroupsParamsMutation) ResetParamType() {
	m.param_type = nil
}

// SetValueRange sets the "value_range" field.
func (m *CarsModelsGroupsParamsMutation) SetValueRange(s string) {
	m.value_range = &s
}

// ValueRange returns the value of the "value_range" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) ValueRange() (r string, exists bool) {
	v := m.value_range
	if v == nil {
		return
	}
	return *v, true
}

// OldValueRange returns the old "value_range" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldValueRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueRange: %w", err)
	}
	return oldValue.ValueRange, nil
}

// ResetValueRange resets all changes to the "value_range" field.
func (m *CarsModelsGroupsParamsMutation) ResetValueRange() {
	m.value_range = nil
}

// SetStatus sets the "status" field.
func (m *CarsModelsGroupsParamsMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CarsModelsGroupsParamsMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CarsModelsGroupsParamsMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CarsModelsGroupsParamsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *CarsModelsGroupsParamsMutation) SetIsDeleted(i int) {
	m.is_deleted = &i
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) IsDeleted() (r int, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldIsDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds i to the "is_deleted" field.
func (m *CarsModelsGroupsParamsMutation) AddIsDeleted(i int) {
	if m.addis_deleted != nil {
		*m.addis_deleted += i
	} else {
		m.addis_deleted = &i
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *CarsModelsGroupsParamsMutation) AddedIsDeleted() (r int, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *CarsModelsGroupsParamsMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarsModelsGroupsParamsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsModelsGroupsParamsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsModelsGroupsParamsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsModelsGroupsParamsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsModelsGroupsParams entity.
// If the CarsModelsGroupsParams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsModelsGroupsParamsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsModelsGroupsParamsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearModel clears the "model" edge to the CarsModels entity.
func (m *CarsModelsGroupsParamsMutation) ClearModel() {
	m.clearedmodel = true
	m.clearedFields[carsmodelsgroupsparams.FieldModelID] = struct{}{}
}

// ModelCleared reports if the "model" edge to the CarsModels entity was cleared.
func (m *CarsModelsGroupsParamsMutation) ModelCleared() bool {
	return m.clearedmodel
}

// ModelIDs returns the "model" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModelID instead. It exists only for internal usage by the builders.
func (m *CarsModelsGroupsParamsMutation) ModelIDs() (ids []int) {
	if id := m.model; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModel resets all changes to the "model" edge.
func (m *CarsModelsGroupsParamsMutation) ResetModel() {
	m.model = nil
	m.clearedmodel = false
}

// ClearGroup clears the "group" edge to the CarsModelsGroups entity.
func (m *CarsModelsGroupsParamsMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[carsmodelsgroupsparams.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the CarsModelsGroups entity was cleared.
func (m *CarsModelsGroupsParamsMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *CarsModelsGroupsParamsMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *CarsModelsGroupsParamsMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the CarsModelsGroupsParamsMutation builder.
func (m *CarsModelsGroupsParamsMutation) Where(ps ...predicate.CarsModelsGroupsParams) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsModelsGroupsParamsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsModelsGroupsParamsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsModelsGroupsParams, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsModelsGroupsParamsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsModelsGroupsParamsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsModelsGroupsParams).
func (m *CarsModelsGroupsParamsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsModelsGroupsParamsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.model != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldModelID)
	}
	if m.group != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldGroupID)
	}
	if m.param_remark != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldParamRemark)
	}
	if m.param_name != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldParamName)
	}
	if m.param_type != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldParamType)
	}
	if m.value_range != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldValueRange)
	}
	if m.status != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldIsDeleted)
	}
	if m.create_time != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsModelsGroupsParamsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsmodelsgroupsparams.FieldModelID:
		return m.ModelID()
	case carsmodelsgroupsparams.FieldGroupID:
		return m.GroupID()
	case carsmodelsgroupsparams.FieldParamRemark:
		return m.ParamRemark()
	case carsmodelsgroupsparams.FieldParamName:
		return m.ParamName()
	case carsmodelsgroupsparams.FieldParamType:
		return m.ParamType()
	case carsmodelsgroupsparams.FieldValueRange:
		return m.ValueRange()
	case carsmodelsgroupsparams.FieldStatus:
		return m.Status()
	case carsmodelsgroupsparams.FieldIsDeleted:
		return m.IsDeleted()
	case carsmodelsgroupsparams.FieldCreateTime:
		return m.CreateTime()
	case carsmodelsgroupsparams.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsModelsGroupsParamsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsmodelsgroupsparams.FieldModelID:
		return m.OldModelID(ctx)
	case carsmodelsgroupsparams.FieldGroupID:
		return m.OldGroupID(ctx)
	case carsmodelsgroupsparams.FieldParamRemark:
		return m.OldParamRemark(ctx)
	case carsmodelsgroupsparams.FieldParamName:
		return m.OldParamName(ctx)
	case carsmodelsgroupsparams.FieldParamType:
		return m.OldParamType(ctx)
	case carsmodelsgroupsparams.FieldValueRange:
		return m.OldValueRange(ctx)
	case carsmodelsgroupsparams.FieldStatus:
		return m.OldStatus(ctx)
	case carsmodelsgroupsparams.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case carsmodelsgroupsparams.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsmodelsgroupsparams.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsModelsGroupsParams field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsGroupsParamsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsmodelsgroupsparams.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case carsmodelsgroupsparams.FieldGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case carsmodelsgroupsparams.FieldParamRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParamRemark(v)
		return nil
	case carsmodelsgroupsparams.FieldParamName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParamName(v)
		return nil
	case carsmodelsgroupsparams.FieldParamType:
		v, ok := value.(carsmodelsgroupsparams.ParamType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParamType(v)
		return nil
	case carsmodelsgroupsparams.FieldValueRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueRange(v)
		return nil
	case carsmodelsgroupsparams.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case carsmodelsgroupsparams.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case carsmodelsgroupsparams.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsmodelsgroupsparams.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroupsParams field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsModelsGroupsParamsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, carsmodelsgroupsparams.FieldIsDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsModelsGroupsParamsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsmodelsgroupsparams.FieldStatus:
		return m.AddedStatus()
	case carsmodelsgroupsparams.FieldIsDeleted:
		return m.AddedIsDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsModelsGroupsParamsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsmodelsgroupsparams.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case carsmodelsgroupsparams.FieldIsDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroupsParams numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsModelsGroupsParamsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsModelsGroupsParamsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsModelsGroupsParamsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarsModelsGroupsParams nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsModelsGroupsParamsMutation) ResetField(name string) error {
	switch name {
	case carsmodelsgroupsparams.FieldModelID:
		m.ResetModelID()
		return nil
	case carsmodelsgroupsparams.FieldGroupID:
		m.ResetGroupID()
		return nil
	case carsmodelsgroupsparams.FieldParamRemark:
		m.ResetParamRemark()
		return nil
	case carsmodelsgroupsparams.FieldParamName:
		m.ResetParamName()
		return nil
	case carsmodelsgroupsparams.FieldParamType:
		m.ResetParamType()
		return nil
	case carsmodelsgroupsparams.FieldValueRange:
		m.ResetValueRange()
		return nil
	case carsmodelsgroupsparams.FieldStatus:
		m.ResetStatus()
		return nil
	case carsmodelsgroupsparams.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case carsmodelsgroupsparams.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsmodelsgroupsparams.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroupsParams field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsModelsGroupsParamsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.model != nil {
		edges = append(edges, carsmodelsgroupsparams.EdgeModel)
	}
	if m.group != nil {
		edges = append(edges, carsmodelsgroupsparams.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsModelsGroupsParamsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carsmodelsgroupsparams.EdgeModel:
		if id := m.model; id != nil {
			return []ent.Value{*id}
		}
	case carsmodelsgroupsparams.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsModelsGroupsParamsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsModelsGroupsParamsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsModelsGroupsParamsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmodel {
		edges = append(edges, carsmodelsgroupsparams.EdgeModel)
	}
	if m.clearedgroup {
		edges = append(edges, carsmodelsgroupsparams.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsModelsGroupsParamsMutation) EdgeCleared(name string) bool {
	switch name {
	case carsmodelsgroupsparams.EdgeModel:
		return m.clearedmodel
	case carsmodelsgroupsparams.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsModelsGroupsParamsMutation) ClearEdge(name string) error {
	switch name {
	case carsmodelsgroupsparams.EdgeModel:
		m.ClearModel()
		return nil
	case carsmodelsgroupsparams.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroupsParams unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsModelsGroupsParamsMutation) ResetEdge(name string) error {
	switch name {
	case carsmodelsgroupsparams.EdgeModel:
		m.ResetModel()
		return nil
	case carsmodelsgroupsparams.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown CarsModelsGroupsParams edge %s", name)
}

// CarsOperateLogMutation represents an operation that mutates the CarsOperateLog nodes in the graph.
type CarsOperateLogMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	origin                        *string
	origin_uid                    *int
	addorigin_uid                 *int
	origin_ip                     *string
	operate_action                *string
	device_id                     *string
	car_longitude                 *float64
	addcar_longitude              *float64
	car_latitude                  *float64
	addcar_latitude               *float64
	car_mileage                   *float64
	addcar_mileage                *float64
	car_speed                     *float64
	addcar_speed                  *float64
	car_power                     *float64
	addcar_power                  *float64
	car_status                    *string
	operate_result                *string
	operate_state                 *int
	addoperate_state              *int
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	car                           *int
	clearedcar                    bool
	done                          bool
	oldValue                      func(context.Context) (*CarsOperateLog, error)
	predicates                    []predicate.CarsOperateLog
}

var _ ent.Mutation = (*CarsOperateLogMutation)(nil)

// carsoperatelogOption allows management of the mutation configuration using functional options.
type carsoperatelogOption func(*CarsOperateLogMutation)

// newCarsOperateLogMutation creates new mutation for the CarsOperateLog entity.
func newCarsOperateLogMutation(c config, op Op, opts ...carsoperatelogOption) *CarsOperateLogMutation {
	m := &CarsOperateLogMutation{
		config:        c,
		op:            op,
		typ:           TypeCarsOperateLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarsOperateLogID sets the ID field of the mutation.
func withCarsOperateLogID(id int) carsoperatelogOption {
	return func(m *CarsOperateLogMutation) {
		var (
			err   error
			once  sync.Once
			value *CarsOperateLog
		)
		m.oldValue = func(ctx context.Context) (*CarsOperateLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarsOperateLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarsOperateLog sets the old CarsOperateLog of the mutation.
func withCarsOperateLog(node *CarsOperateLog) carsoperatelogOption {
	return func(m *CarsOperateLogMutation) {
		m.oldValue = func(context.Context) (*CarsOperateLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarsOperateLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarsOperateLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarsOperateLog entities.
func (m *CarsOperateLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarsOperateLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarsOperateLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarsOperateLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CarsOperateLogMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CarsOperateLogMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CarsOperateLogMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetOrigin sets the "origin" field.
func (m *CarsOperateLogMutation) SetOrigin(s string) {
	m.origin = &s
}

// Origin returns the value of the "origin" field in the mutation.
func (m *CarsOperateLogMutation) Origin() (r string, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOrigin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *CarsOperateLogMutation) ResetOrigin() {
	m.origin = nil
}

// SetOriginUID sets the "origin_uid" field.
func (m *CarsOperateLogMutation) SetOriginUID(i int) {
	m.origin_uid = &i
	m.addorigin_uid = nil
}

// OriginUID returns the value of the "origin_uid" field in the mutation.
func (m *CarsOperateLogMutation) OriginUID() (r int, exists bool) {
	v := m.origin_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginUID returns the old "origin_uid" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOriginUID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginUID: %w", err)
	}
	return oldValue.OriginUID, nil
}

// AddOriginUID adds i to the "origin_uid" field.
func (m *CarsOperateLogMutation) AddOriginUID(i int) {
	if m.addorigin_uid != nil {
		*m.addorigin_uid += i
	} else {
		m.addorigin_uid = &i
	}
}

// AddedOriginUID returns the value that was added to the "origin_uid" field in this mutation.
func (m *CarsOperateLogMutation) AddedOriginUID() (r int, exists bool) {
	v := m.addorigin_uid
	if v == nil {
		return
	}
	return *v, true
}

// ResetOriginUID resets all changes to the "origin_uid" field.
func (m *CarsOperateLogMutation) ResetOriginUID() {
	m.origin_uid = nil
	m.addorigin_uid = nil
}

// SetOriginIP sets the "origin_ip" field.
func (m *CarsOperateLogMutation) SetOriginIP(s string) {
	m.origin_ip = &s
}

// OriginIP returns the value of the "origin_ip" field in the mutation.
func (m *CarsOperateLogMutation) OriginIP() (r string, exists bool) {
	v := m.origin_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginIP returns the old "origin_ip" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOriginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginIP: %w", err)
	}
	return oldValue.OriginIP, nil
}

// ResetOriginIP resets all changes to the "origin_ip" field.
func (m *CarsOperateLogMutation) ResetOriginIP() {
	m.origin_ip = nil
}

// SetOperateAction sets the "operate_action" field.
func (m *CarsOperateLogMutation) SetOperateAction(s string) {
	m.operate_action = &s
}

// OperateAction returns the value of the "operate_action" field in the mutation.
func (m *CarsOperateLogMutation) OperateAction() (r string, exists bool) {
	v := m.operate_action
	if v == nil {
		return
	}
	return *v, true
}

// OldOperateAction returns the old "operate_action" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOperateAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperateAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperateAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperateAction: %w", err)
	}
	return oldValue.OperateAction, nil
}

// ResetOperateAction resets all changes to the "operate_action" field.
func (m *CarsOperateLogMutation) ResetOperateAction() {
	m.operate_action = nil
}

// SetCarID sets the "car_id" field.
func (m *CarsOperateLogMutation) SetCarID(i int) {
	m.car = &i
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *CarsOperateLogMutation) CarID() (r int, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ResetCarID resets all changes to the "car_id" field.
func (m *CarsOperateLogMutation) ResetCarID() {
	m.car = nil
}

// SetDeviceID sets the "device_id" field.
func (m *CarsOperateLogMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *CarsOperateLogMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *CarsOperateLogMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetCarLongitude sets the "car_longitude" field.
func (m *CarsOperateLogMutation) SetCarLongitude(f float64) {
	m.car_longitude = &f
	m.addcar_longitude = nil
}

// CarLongitude returns the value of the "car_longitude" field in the mutation.
func (m *CarsOperateLogMutation) CarLongitude() (r float64, exists bool) {
	v := m.car_longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldCarLongitude returns the old "car_longitude" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarLongitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarLongitude: %w", err)
	}
	return oldValue.CarLongitude, nil
}

// AddCarLongitude adds f to the "car_longitude" field.
func (m *CarsOperateLogMutation) AddCarLongitude(f float64) {
	if m.addcar_longitude != nil {
		*m.addcar_longitude += f
	} else {
		m.addcar_longitude = &f
	}
}

// AddedCarLongitude returns the value that was added to the "car_longitude" field in this mutation.
func (m *CarsOperateLogMutation) AddedCarLongitude() (r float64, exists bool) {
	v := m.addcar_longitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarLongitude clears the value of the "car_longitude" field.
func (m *CarsOperateLogMutation) ClearCarLongitude() {
	m.car_longitude = nil
	m.addcar_longitude = nil
	m.clearedFields[carsoperatelog.FieldCarLongitude] = struct{}{}
}

// CarLongitudeCleared returns if the "car_longitude" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarLongitudeCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarLongitude]
	return ok
}

// ResetCarLongitude resets all changes to the "car_longitude" field.
func (m *CarsOperateLogMutation) ResetCarLongitude() {
	m.car_longitude = nil
	m.addcar_longitude = nil
	delete(m.clearedFields, carsoperatelog.FieldCarLongitude)
}

// SetCarLatitude sets the "car_latitude" field.
func (m *CarsOperateLogMutation) SetCarLatitude(f float64) {
	m.car_latitude = &f
	m.addcar_latitude = nil
}

// CarLatitude returns the value of the "car_latitude" field in the mutation.
func (m *CarsOperateLogMutation) CarLatitude() (r float64, exists bool) {
	v := m.car_latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldCarLatitude returns the old "car_latitude" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarLatitude(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarLatitude: %w", err)
	}
	return oldValue.CarLatitude, nil
}

// AddCarLatitude adds f to the "car_latitude" field.
func (m *CarsOperateLogMutation) AddCarLatitude(f float64) {
	if m.addcar_latitude != nil {
		*m.addcar_latitude += f
	} else {
		m.addcar_latitude = &f
	}
}

// AddedCarLatitude returns the value that was added to the "car_latitude" field in this mutation.
func (m *CarsOperateLogMutation) AddedCarLatitude() (r float64, exists bool) {
	v := m.addcar_latitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarLatitude clears the value of the "car_latitude" field.
func (m *CarsOperateLogMutation) ClearCarLatitude() {
	m.car_latitude = nil
	m.addcar_latitude = nil
	m.clearedFields[carsoperatelog.FieldCarLatitude] = struct{}{}
}

// CarLatitudeCleared returns if the "car_latitude" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarLatitudeCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarLatitude]
	return ok
}

// ResetCarLatitude resets all changes to the "car_latitude" field.
func (m *CarsOperateLogMutation) ResetCarLatitude() {
	m.car_latitude = nil
	m.addcar_latitude = nil
	delete(m.clearedFields, carsoperatelog.FieldCarLatitude)
}

// SetCarMileage sets the "car_mileage" field.
func (m *CarsOperateLogMutation) SetCarMileage(f float64) {
	m.car_mileage = &f
	m.addcar_mileage = nil
}

// CarMileage returns the value of the "car_mileage" field in the mutation.
func (m *CarsOperateLogMutation) CarMileage() (r float64, exists bool) {
	v := m.car_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMileage returns the old "car_mileage" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarMileage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMileage: %w", err)
	}
	return oldValue.CarMileage, nil
}

// AddCarMileage adds f to the "car_mileage" field.
func (m *CarsOperateLogMutation) AddCarMileage(f float64) {
	if m.addcar_mileage != nil {
		*m.addcar_mileage += f
	} else {
		m.addcar_mileage = &f
	}
}

// AddedCarMileage returns the value that was added to the "car_mileage" field in this mutation.
func (m *CarsOperateLogMutation) AddedCarMileage() (r float64, exists bool) {
	v := m.addcar_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarMileage clears the value of the "car_mileage" field.
func (m *CarsOperateLogMutation) ClearCarMileage() {
	m.car_mileage = nil
	m.addcar_mileage = nil
	m.clearedFields[carsoperatelog.FieldCarMileage] = struct{}{}
}

// CarMileageCleared returns if the "car_mileage" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarMileageCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarMileage]
	return ok
}

// ResetCarMileage resets all changes to the "car_mileage" field.
func (m *CarsOperateLogMutation) ResetCarMileage() {
	m.car_mileage = nil
	m.addcar_mileage = nil
	delete(m.clearedFields, carsoperatelog.FieldCarMileage)
}

// SetCarSpeed sets the "car_speed" field.
func (m *CarsOperateLogMutation) SetCarSpeed(f float64) {
	m.car_speed = &f
	m.addcar_speed = nil
}

// CarSpeed returns the value of the "car_speed" field in the mutation.
func (m *CarsOperateLogMutation) CarSpeed() (r float64, exists bool) {
	v := m.car_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldCarSpeed returns the old "car_speed" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarSpeed(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarSpeed: %w", err)
	}
	return oldValue.CarSpeed, nil
}

// AddCarSpeed adds f to the "car_speed" field.
func (m *CarsOperateLogMutation) AddCarSpeed(f float64) {
	if m.addcar_speed != nil {
		*m.addcar_speed += f
	} else {
		m.addcar_speed = &f
	}
}

// AddedCarSpeed returns the value that was added to the "car_speed" field in this mutation.
func (m *CarsOperateLogMutation) AddedCarSpeed() (r float64, exists bool) {
	v := m.addcar_speed
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarSpeed clears the value of the "car_speed" field.
func (m *CarsOperateLogMutation) ClearCarSpeed() {
	m.car_speed = nil
	m.addcar_speed = nil
	m.clearedFields[carsoperatelog.FieldCarSpeed] = struct{}{}
}

// CarSpeedCleared returns if the "car_speed" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarSpeedCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarSpeed]
	return ok
}

// ResetCarSpeed resets all changes to the "car_speed" field.
func (m *CarsOperateLogMutation) ResetCarSpeed() {
	m.car_speed = nil
	m.addcar_speed = nil
	delete(m.clearedFields, carsoperatelog.FieldCarSpeed)
}

// SetCarPower sets the "car_power" field.
func (m *CarsOperateLogMutation) SetCarPower(f float64) {
	m.car_power = &f
	m.addcar_power = nil
}

// CarPower returns the value of the "car_power" field in the mutation.
func (m *CarsOperateLogMutation) CarPower() (r float64, exists bool) {
	v := m.car_power
	if v == nil {
		return
	}
	return *v, true
}

// OldCarPower returns the old "car_power" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarPower(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarPower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarPower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarPower: %w", err)
	}
	return oldValue.CarPower, nil
}

// AddCarPower adds f to the "car_power" field.
func (m *CarsOperateLogMutation) AddCarPower(f float64) {
	if m.addcar_power != nil {
		*m.addcar_power += f
	} else {
		m.addcar_power = &f
	}
}

// AddedCarPower returns the value that was added to the "car_power" field in this mutation.
func (m *CarsOperateLogMutation) AddedCarPower() (r float64, exists bool) {
	v := m.addcar_power
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarPower clears the value of the "car_power" field.
func (m *CarsOperateLogMutation) ClearCarPower() {
	m.car_power = nil
	m.addcar_power = nil
	m.clearedFields[carsoperatelog.FieldCarPower] = struct{}{}
}

// CarPowerCleared returns if the "car_power" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarPowerCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarPower]
	return ok
}

// ResetCarPower resets all changes to the "car_power" field.
func (m *CarsOperateLogMutation) ResetCarPower() {
	m.car_power = nil
	m.addcar_power = nil
	delete(m.clearedFields, carsoperatelog.FieldCarPower)
}

// SetCarStatus sets the "car_status" field.
func (m *CarsOperateLogMutation) SetCarStatus(s string) {
	m.car_status = &s
}

// CarStatus returns the value of the "car_status" field in the mutation.
func (m *CarsOperateLogMutation) CarStatus() (r string, exists bool) {
	v := m.car_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCarStatus returns the old "car_status" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCarStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarStatus: %w", err)
	}
	return oldValue.CarStatus, nil
}

// ClearCarStatus clears the value of the "car_status" field.
func (m *CarsOperateLogMutation) ClearCarStatus() {
	m.car_status = nil
	m.clearedFields[carsoperatelog.FieldCarStatus] = struct{}{}
}

// CarStatusCleared returns if the "car_status" field was cleared in this mutation.
func (m *CarsOperateLogMutation) CarStatusCleared() bool {
	_, ok := m.clearedFields[carsoperatelog.FieldCarStatus]
	return ok
}

// ResetCarStatus resets all changes to the "car_status" field.
func (m *CarsOperateLogMutation) ResetCarStatus() {
	m.car_status = nil
	delete(m.clearedFields, carsoperatelog.FieldCarStatus)
}

// SetOperateResult sets the "operate_result" field.
func (m *CarsOperateLogMutation) SetOperateResult(s string) {
	m.operate_result = &s
}

// OperateResult returns the value of the "operate_result" field in the mutation.
func (m *CarsOperateLogMutation) OperateResult() (r string, exists bool) {
	v := m.operate_result
	if v == nil {
		return
	}
	return *v, true
}

// OldOperateResult returns the old "operate_result" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOperateResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperateResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperateResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperateResult: %w", err)
	}
	return oldValue.OperateResult, nil
}

// ResetOperateResult resets all changes to the "operate_result" field.
func (m *CarsOperateLogMutation) ResetOperateResult() {
	m.operate_result = nil
}

// SetOperateState sets the "operate_state" field.
func (m *CarsOperateLogMutation) SetOperateState(i int) {
	m.operate_state = &i
	m.addoperate_state = nil
}

// OperateState returns the value of the "operate_state" field in the mutation.
func (m *CarsOperateLogMutation) OperateState() (r int, exists bool) {
	v := m.operate_state
	if v == nil {
		return
	}
	return *v, true
}

// OldOperateState returns the old "operate_state" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldOperateState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperateState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperateState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperateState: %w", err)
	}
	return oldValue.OperateState, nil
}

// AddOperateState adds i to the "operate_state" field.
func (m *CarsOperateLogMutation) AddOperateState(i int) {
	if m.addoperate_state != nil {
		*m.addoperate_state += i
	} else {
		m.addoperate_state = &i
	}
}

// AddedOperateState returns the value that was added to the "operate_state" field in this mutation.
func (m *CarsOperateLogMutation) AddedOperateState() (r int, exists bool) {
	v := m.addoperate_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperateState resets all changes to the "operate_state" field.
func (m *CarsOperateLogMutation) ResetOperateState() {
	m.operate_state = nil
	m.addoperate_state = nil
}

// SetCreateTime sets the "create_time" field.
func (m *CarsOperateLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarsOperateLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarsOperateLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarsOperateLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarsOperateLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CarsOperateLog entity.
// If the CarsOperateLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarsOperateLogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarsOperateLogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *CarsOperateLogMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *CarsOperateLogMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[carsoperatelog.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *CarsOperateLogMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *CarsOperateLogMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *CarsOperateLogMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *CarsOperateLogMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// ClearCar clears the "car" edge to the Car entity.
func (m *CarsOperateLogMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[carsoperatelog.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *CarsOperateLogMutation) CarCleared() bool {
	return m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *CarsOperateLogMutation) CarIDs() (ids []int) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *CarsOperateLogMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// Where appends a list predicates to the CarsOperateLogMutation builder.
func (m *CarsOperateLogMutation) Where(ps ...predicate.CarsOperateLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarsOperateLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarsOperateLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarsOperateLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarsOperateLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarsOperateLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarsOperateLog).
func (m *CarsOperateLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarsOperateLogMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.background_scenic_area != nil {
		fields = append(fields, carsoperatelog.FieldScenicAreaID)
	}
	if m.origin != nil {
		fields = append(fields, carsoperatelog.FieldOrigin)
	}
	if m.origin_uid != nil {
		fields = append(fields, carsoperatelog.FieldOriginUID)
	}
	if m.origin_ip != nil {
		fields = append(fields, carsoperatelog.FieldOriginIP)
	}
	if m.operate_action != nil {
		fields = append(fields, carsoperatelog.FieldOperateAction)
	}
	if m.car != nil {
		fields = append(fields, carsoperatelog.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, carsoperatelog.FieldDeviceID)
	}
	if m.car_longitude != nil {
		fields = append(fields, carsoperatelog.FieldCarLongitude)
	}
	if m.car_latitude != nil {
		fields = append(fields, carsoperatelog.FieldCarLatitude)
	}
	if m.car_mileage != nil {
		fields = append(fields, carsoperatelog.FieldCarMileage)
	}
	if m.car_speed != nil {
		fields = append(fields, carsoperatelog.FieldCarSpeed)
	}
	if m.car_power != nil {
		fields = append(fields, carsoperatelog.FieldCarPower)
	}
	if m.car_status != nil {
		fields = append(fields, carsoperatelog.FieldCarStatus)
	}
	if m.operate_result != nil {
		fields = append(fields, carsoperatelog.FieldOperateResult)
	}
	if m.operate_state != nil {
		fields = append(fields, carsoperatelog.FieldOperateState)
	}
	if m.create_time != nil {
		fields = append(fields, carsoperatelog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, carsoperatelog.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarsOperateLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carsoperatelog.FieldScenicAreaID:
		return m.ScenicAreaID()
	case carsoperatelog.FieldOrigin:
		return m.Origin()
	case carsoperatelog.FieldOriginUID:
		return m.OriginUID()
	case carsoperatelog.FieldOriginIP:
		return m.OriginIP()
	case carsoperatelog.FieldOperateAction:
		return m.OperateAction()
	case carsoperatelog.FieldCarID:
		return m.CarID()
	case carsoperatelog.FieldDeviceID:
		return m.DeviceID()
	case carsoperatelog.FieldCarLongitude:
		return m.CarLongitude()
	case carsoperatelog.FieldCarLatitude:
		return m.CarLatitude()
	case carsoperatelog.FieldCarMileage:
		return m.CarMileage()
	case carsoperatelog.FieldCarSpeed:
		return m.CarSpeed()
	case carsoperatelog.FieldCarPower:
		return m.CarPower()
	case carsoperatelog.FieldCarStatus:
		return m.CarStatus()
	case carsoperatelog.FieldOperateResult:
		return m.OperateResult()
	case carsoperatelog.FieldOperateState:
		return m.OperateState()
	case carsoperatelog.FieldCreateTime:
		return m.CreateTime()
	case carsoperatelog.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarsOperateLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carsoperatelog.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case carsoperatelog.FieldOrigin:
		return m.OldOrigin(ctx)
	case carsoperatelog.FieldOriginUID:
		return m.OldOriginUID(ctx)
	case carsoperatelog.FieldOriginIP:
		return m.OldOriginIP(ctx)
	case carsoperatelog.FieldOperateAction:
		return m.OldOperateAction(ctx)
	case carsoperatelog.FieldCarID:
		return m.OldCarID(ctx)
	case carsoperatelog.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case carsoperatelog.FieldCarLongitude:
		return m.OldCarLongitude(ctx)
	case carsoperatelog.FieldCarLatitude:
		return m.OldCarLatitude(ctx)
	case carsoperatelog.FieldCarMileage:
		return m.OldCarMileage(ctx)
	case carsoperatelog.FieldCarSpeed:
		return m.OldCarSpeed(ctx)
	case carsoperatelog.FieldCarPower:
		return m.OldCarPower(ctx)
	case carsoperatelog.FieldCarStatus:
		return m.OldCarStatus(ctx)
	case carsoperatelog.FieldOperateResult:
		return m.OldOperateResult(ctx)
	case carsoperatelog.FieldOperateState:
		return m.OldOperateState(ctx)
	case carsoperatelog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case carsoperatelog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown CarsOperateLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsOperateLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carsoperatelog.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case carsoperatelog.FieldOrigin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case carsoperatelog.FieldOriginUID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginUID(v)
		return nil
	case carsoperatelog.FieldOriginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginIP(v)
		return nil
	case carsoperatelog.FieldOperateAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperateAction(v)
		return nil
	case carsoperatelog.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case carsoperatelog.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case carsoperatelog.FieldCarLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarLongitude(v)
		return nil
	case carsoperatelog.FieldCarLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarLatitude(v)
		return nil
	case carsoperatelog.FieldCarMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMileage(v)
		return nil
	case carsoperatelog.FieldCarSpeed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarSpeed(v)
		return nil
	case carsoperatelog.FieldCarPower:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarPower(v)
		return nil
	case carsoperatelog.FieldCarStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarStatus(v)
		return nil
	case carsoperatelog.FieldOperateResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperateResult(v)
		return nil
	case carsoperatelog.FieldOperateState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperateState(v)
		return nil
	case carsoperatelog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case carsoperatelog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarsOperateLogMutation) AddedFields() []string {
	var fields []string
	if m.addorigin_uid != nil {
		fields = append(fields, carsoperatelog.FieldOriginUID)
	}
	if m.addcar_longitude != nil {
		fields = append(fields, carsoperatelog.FieldCarLongitude)
	}
	if m.addcar_latitude != nil {
		fields = append(fields, carsoperatelog.FieldCarLatitude)
	}
	if m.addcar_mileage != nil {
		fields = append(fields, carsoperatelog.FieldCarMileage)
	}
	if m.addcar_speed != nil {
		fields = append(fields, carsoperatelog.FieldCarSpeed)
	}
	if m.addcar_power != nil {
		fields = append(fields, carsoperatelog.FieldCarPower)
	}
	if m.addoperate_state != nil {
		fields = append(fields, carsoperatelog.FieldOperateState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarsOperateLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case carsoperatelog.FieldOriginUID:
		return m.AddedOriginUID()
	case carsoperatelog.FieldCarLongitude:
		return m.AddedCarLongitude()
	case carsoperatelog.FieldCarLatitude:
		return m.AddedCarLatitude()
	case carsoperatelog.FieldCarMileage:
		return m.AddedCarMileage()
	case carsoperatelog.FieldCarSpeed:
		return m.AddedCarSpeed()
	case carsoperatelog.FieldCarPower:
		return m.AddedCarPower()
	case carsoperatelog.FieldOperateState:
		return m.AddedOperateState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarsOperateLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case carsoperatelog.FieldOriginUID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginUID(v)
		return nil
	case carsoperatelog.FieldCarLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarLongitude(v)
		return nil
	case carsoperatelog.FieldCarLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarLatitude(v)
		return nil
	case carsoperatelog.FieldCarMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMileage(v)
		return nil
	case carsoperatelog.FieldCarSpeed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarSpeed(v)
		return nil
	case carsoperatelog.FieldCarPower:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarPower(v)
		return nil
	case carsoperatelog.FieldOperateState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperateState(v)
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarsOperateLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carsoperatelog.FieldCarLongitude) {
		fields = append(fields, carsoperatelog.FieldCarLongitude)
	}
	if m.FieldCleared(carsoperatelog.FieldCarLatitude) {
		fields = append(fields, carsoperatelog.FieldCarLatitude)
	}
	if m.FieldCleared(carsoperatelog.FieldCarMileage) {
		fields = append(fields, carsoperatelog.FieldCarMileage)
	}
	if m.FieldCleared(carsoperatelog.FieldCarSpeed) {
		fields = append(fields, carsoperatelog.FieldCarSpeed)
	}
	if m.FieldCleared(carsoperatelog.FieldCarPower) {
		fields = append(fields, carsoperatelog.FieldCarPower)
	}
	if m.FieldCleared(carsoperatelog.FieldCarStatus) {
		fields = append(fields, carsoperatelog.FieldCarStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarsOperateLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarsOperateLogMutation) ClearField(name string) error {
	switch name {
	case carsoperatelog.FieldCarLongitude:
		m.ClearCarLongitude()
		return nil
	case carsoperatelog.FieldCarLatitude:
		m.ClearCarLatitude()
		return nil
	case carsoperatelog.FieldCarMileage:
		m.ClearCarMileage()
		return nil
	case carsoperatelog.FieldCarSpeed:
		m.ClearCarSpeed()
		return nil
	case carsoperatelog.FieldCarPower:
		m.ClearCarPower()
		return nil
	case carsoperatelog.FieldCarStatus:
		m.ClearCarStatus()
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarsOperateLogMutation) ResetField(name string) error {
	switch name {
	case carsoperatelog.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case carsoperatelog.FieldOrigin:
		m.ResetOrigin()
		return nil
	case carsoperatelog.FieldOriginUID:
		m.ResetOriginUID()
		return nil
	case carsoperatelog.FieldOriginIP:
		m.ResetOriginIP()
		return nil
	case carsoperatelog.FieldOperateAction:
		m.ResetOperateAction()
		return nil
	case carsoperatelog.FieldCarID:
		m.ResetCarID()
		return nil
	case carsoperatelog.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case carsoperatelog.FieldCarLongitude:
		m.ResetCarLongitude()
		return nil
	case carsoperatelog.FieldCarLatitude:
		m.ResetCarLatitude()
		return nil
	case carsoperatelog.FieldCarMileage:
		m.ResetCarMileage()
		return nil
	case carsoperatelog.FieldCarSpeed:
		m.ResetCarSpeed()
		return nil
	case carsoperatelog.FieldCarPower:
		m.ResetCarPower()
		return nil
	case carsoperatelog.FieldCarStatus:
		m.ResetCarStatus()
		return nil
	case carsoperatelog.FieldOperateResult:
		m.ResetOperateResult()
		return nil
	case carsoperatelog.FieldOperateState:
		m.ResetOperateState()
		return nil
	case carsoperatelog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case carsoperatelog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarsOperateLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.background_scenic_area != nil {
		edges = append(edges, carsoperatelog.EdgeBackgroundScenicArea)
	}
	if m.car != nil {
		edges = append(edges, carsoperatelog.EdgeCar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarsOperateLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carsoperatelog.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	case carsoperatelog.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarsOperateLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarsOperateLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarsOperateLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbackground_scenic_area {
		edges = append(edges, carsoperatelog.EdgeBackgroundScenicArea)
	}
	if m.clearedcar {
		edges = append(edges, carsoperatelog.EdgeCar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarsOperateLogMutation) EdgeCleared(name string) bool {
	switch name {
	case carsoperatelog.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	case carsoperatelog.EdgeCar:
		return m.clearedcar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarsOperateLogMutation) ClearEdge(name string) error {
	switch name {
	case carsoperatelog.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	case carsoperatelog.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarsOperateLogMutation) ResetEdge(name string) error {
	switch name {
	case carsoperatelog.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	case carsoperatelog.EdgeCar:
		m.ResetCar()
		return nil
	}
	return fmt.Errorf("unknown CarsOperateLog edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op                Op
	typ               string
	id                *int
	delete_time       *time.Time
	scenic_area_id    *int
	addscenic_area_id *int
	name              *string
	coupon_no         *string
	user_id           *int
	adduser_id        *int
	limit_amount      *int
	addlimit_amount   *int
	coupon_amount     *int
	addcoupon_amount  *int
	bind_order_id     *int
	addbind_order_id  *int
	state             *int
	addstate          *int
	valid_start_time  *time.Time
	valid_end_time    *time.Time
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Coupon, error)
	predicates        []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id int) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupon.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupon.FieldDeleteTime)
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *CouponMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *CouponMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *CouponMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *CouponMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *CouponMutation) ClearScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	m.clearedFields[coupon.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *CouponMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *CouponMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	delete(m.clearedFields, coupon.FieldScenicAreaID)
}

// SetName sets the "name" field.
func (m *CouponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponMutation) ResetName() {
	m.name = nil
}

// SetCouponNo sets the "coupon_no" field.
func (m *CouponMutation) SetCouponNo(s string) {
	m.coupon_no = &s
}

// CouponNo returns the value of the "coupon_no" field in the mutation.
func (m *CouponMutation) CouponNo() (r string, exists bool) {
	v := m.coupon_no
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponNo returns the old "coupon_no" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponNo: %w", err)
	}
	return oldValue.CouponNo, nil
}

// ResetCouponNo resets all changes to the "coupon_no" field.
func (m *CouponMutation) ResetCouponNo() {
	m.coupon_no = nil
}

// SetUserID sets the "user_id" field.
func (m *CouponMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CouponMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CouponMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetLimitAmount sets the "limit_amount" field.
func (m *CouponMutation) SetLimitAmount(i int) {
	m.limit_amount = &i
	m.addlimit_amount = nil
}

// LimitAmount returns the value of the "limit_amount" field in the mutation.
func (m *CouponMutation) LimitAmount() (r int, exists bool) {
	v := m.limit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitAmount returns the old "limit_amount" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldLimitAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitAmount: %w", err)
	}
	return oldValue.LimitAmount, nil
}

// AddLimitAmount adds i to the "limit_amount" field.
func (m *CouponMutation) AddLimitAmount(i int) {
	if m.addlimit_amount != nil {
		*m.addlimit_amount += i
	} else {
		m.addlimit_amount = &i
	}
}

// AddedLimitAmount returns the value that was added to the "limit_amount" field in this mutation.
func (m *CouponMutation) AddedLimitAmount() (r int, exists bool) {
	v := m.addlimit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetLimitAmount resets all changes to the "limit_amount" field.
func (m *CouponMutation) ResetLimitAmount() {
	m.limit_amount = nil
	m.addlimit_amount = nil
}

// SetCouponAmount sets the "coupon_amount" field.
func (m *CouponMutation) SetCouponAmount(i int) {
	m.coupon_amount = &i
	m.addcoupon_amount = nil
}

// CouponAmount returns the value of the "coupon_amount" field in the mutation.
func (m *CouponMutation) CouponAmount() (r int, exists bool) {
	v := m.coupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponAmount returns the old "coupon_amount" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCouponAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponAmount: %w", err)
	}
	return oldValue.CouponAmount, nil
}

// AddCouponAmount adds i to the "coupon_amount" field.
func (m *CouponMutation) AddCouponAmount(i int) {
	if m.addcoupon_amount != nil {
		*m.addcoupon_amount += i
	} else {
		m.addcoupon_amount = &i
	}
}

// AddedCouponAmount returns the value that was added to the "coupon_amount" field in this mutation.
func (m *CouponMutation) AddedCouponAmount() (r int, exists bool) {
	v := m.addcoupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponAmount resets all changes to the "coupon_amount" field.
func (m *CouponMutation) ResetCouponAmount() {
	m.coupon_amount = nil
	m.addcoupon_amount = nil
}

// SetBindOrderID sets the "bind_order_id" field.
func (m *CouponMutation) SetBindOrderID(i int) {
	m.bind_order_id = &i
	m.addbind_order_id = nil
}

// BindOrderID returns the value of the "bind_order_id" field in the mutation.
func (m *CouponMutation) BindOrderID() (r int, exists bool) {
	v := m.bind_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBindOrderID returns the old "bind_order_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldBindOrderID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBindOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBindOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBindOrderID: %w", err)
	}
	return oldValue.BindOrderID, nil
}

// AddBindOrderID adds i to the "bind_order_id" field.
func (m *CouponMutation) AddBindOrderID(i int) {
	if m.addbind_order_id != nil {
		*m.addbind_order_id += i
	} else {
		m.addbind_order_id = &i
	}
}

// AddedBindOrderID returns the value that was added to the "bind_order_id" field in this mutation.
func (m *CouponMutation) AddedBindOrderID() (r int, exists bool) {
	v := m.addbind_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBindOrderID clears the value of the "bind_order_id" field.
func (m *CouponMutation) ClearBindOrderID() {
	m.bind_order_id = nil
	m.addbind_order_id = nil
	m.clearedFields[coupon.FieldBindOrderID] = struct{}{}
}

// BindOrderIDCleared returns if the "bind_order_id" field was cleared in this mutation.
func (m *CouponMutation) BindOrderIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldBindOrderID]
	return ok
}

// ResetBindOrderID resets all changes to the "bind_order_id" field.
func (m *CouponMutation) ResetBindOrderID() {
	m.bind_order_id = nil
	m.addbind_order_id = nil
	delete(m.clearedFields, coupon.FieldBindOrderID)
}

// SetState sets the "state" field.
func (m *CouponMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CouponMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CouponMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CouponMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CouponMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetValidStartTime sets the "valid_start_time" field.
func (m *CouponMutation) SetValidStartTime(t time.Time) {
	m.valid_start_time = &t
}

// ValidStartTime returns the value of the "valid_start_time" field in the mutation.
func (m *CouponMutation) ValidStartTime() (r time.Time, exists bool) {
	v := m.valid_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldValidStartTime returns the old "valid_start_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValidStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidStartTime: %w", err)
	}
	return oldValue.ValidStartTime, nil
}

// ClearValidStartTime clears the value of the "valid_start_time" field.
func (m *CouponMutation) ClearValidStartTime() {
	m.valid_start_time = nil
	m.clearedFields[coupon.FieldValidStartTime] = struct{}{}
}

// ValidStartTimeCleared returns if the "valid_start_time" field was cleared in this mutation.
func (m *CouponMutation) ValidStartTimeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldValidStartTime]
	return ok
}

// ResetValidStartTime resets all changes to the "valid_start_time" field.
func (m *CouponMutation) ResetValidStartTime() {
	m.valid_start_time = nil
	delete(m.clearedFields, coupon.FieldValidStartTime)
}

// SetValidEndTime sets the "valid_end_time" field.
func (m *CouponMutation) SetValidEndTime(t time.Time) {
	m.valid_end_time = &t
}

// ValidEndTime returns the value of the "valid_end_time" field in the mutation.
func (m *CouponMutation) ValidEndTime() (r time.Time, exists bool) {
	v := m.valid_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldValidEndTime returns the old "valid_end_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValidEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidEndTime: %w", err)
	}
	return oldValue.ValidEndTime, nil
}

// ClearValidEndTime clears the value of the "valid_end_time" field.
func (m *CouponMutation) ClearValidEndTime() {
	m.valid_end_time = nil
	m.clearedFields[coupon.FieldValidEndTime] = struct{}{}
}

// ValidEndTimeCleared returns if the "valid_end_time" field was cleared in this mutation.
func (m *CouponMutation) ValidEndTimeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldValidEndTime]
	return ok
}

// ResetValidEndTime resets all changes to the "valid_end_time" field.
func (m *CouponMutation) ResetValidEndTime() {
	m.valid_end_time = nil
	delete(m.clearedFields, coupon.FieldValidEndTime)
}

// SetCreateTime sets the "create_time" field.
func (m *CouponMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.delete_time != nil {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, coupon.FieldScenicAreaID)
	}
	if m.name != nil {
		fields = append(fields, coupon.FieldName)
	}
	if m.coupon_no != nil {
		fields = append(fields, coupon.FieldCouponNo)
	}
	if m.user_id != nil {
		fields = append(fields, coupon.FieldUserID)
	}
	if m.limit_amount != nil {
		fields = append(fields, coupon.FieldLimitAmount)
	}
	if m.coupon_amount != nil {
		fields = append(fields, coupon.FieldCouponAmount)
	}
	if m.bind_order_id != nil {
		fields = append(fields, coupon.FieldBindOrderID)
	}
	if m.state != nil {
		fields = append(fields, coupon.FieldState)
	}
	if m.valid_start_time != nil {
		fields = append(fields, coupon.FieldValidStartTime)
	}
	if m.valid_end_time != nil {
		fields = append(fields, coupon.FieldValidEndTime)
	}
	if m.create_time != nil {
		fields = append(fields, coupon.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupon.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldDeleteTime:
		return m.DeleteTime()
	case coupon.FieldScenicAreaID:
		return m.ScenicAreaID()
	case coupon.FieldName:
		return m.Name()
	case coupon.FieldCouponNo:
		return m.CouponNo()
	case coupon.FieldUserID:
		return m.UserID()
	case coupon.FieldLimitAmount:
		return m.LimitAmount()
	case coupon.FieldCouponAmount:
		return m.CouponAmount()
	case coupon.FieldBindOrderID:
		return m.BindOrderID()
	case coupon.FieldState:
		return m.State()
	case coupon.FieldValidStartTime:
		return m.ValidStartTime()
	case coupon.FieldValidEndTime:
		return m.ValidEndTime()
	case coupon.FieldCreateTime:
		return m.CreateTime()
	case coupon.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupon.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case coupon.FieldName:
		return m.OldName(ctx)
	case coupon.FieldCouponNo:
		return m.OldCouponNo(ctx)
	case coupon.FieldUserID:
		return m.OldUserID(ctx)
	case coupon.FieldLimitAmount:
		return m.OldLimitAmount(ctx)
	case coupon.FieldCouponAmount:
		return m.OldCouponAmount(ctx)
	case coupon.FieldBindOrderID:
		return m.OldBindOrderID(ctx)
	case coupon.FieldState:
		return m.OldState(ctx)
	case coupon.FieldValidStartTime:
		return m.OldValidStartTime(ctx)
	case coupon.FieldValidEndTime:
		return m.OldValidEndTime(ctx)
	case coupon.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupon.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupon.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case coupon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupon.FieldCouponNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponNo(v)
		return nil
	case coupon.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case coupon.FieldLimitAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitAmount(v)
		return nil
	case coupon.FieldCouponAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponAmount(v)
		return nil
	case coupon.FieldBindOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBindOrderID(v)
		return nil
	case coupon.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case coupon.FieldValidStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidStartTime(v)
		return nil
	case coupon.FieldValidEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidEndTime(v)
		return nil
	case coupon.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupon.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, coupon.FieldScenicAreaID)
	}
	if m.adduser_id != nil {
		fields = append(fields, coupon.FieldUserID)
	}
	if m.addlimit_amount != nil {
		fields = append(fields, coupon.FieldLimitAmount)
	}
	if m.addcoupon_amount != nil {
		fields = append(fields, coupon.FieldCouponAmount)
	}
	if m.addbind_order_id != nil {
		fields = append(fields, coupon.FieldBindOrderID)
	}
	if m.addstate != nil {
		fields = append(fields, coupon.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case coupon.FieldUserID:
		return m.AddedUserID()
	case coupon.FieldLimitAmount:
		return m.AddedLimitAmount()
	case coupon.FieldCouponAmount:
		return m.AddedCouponAmount()
	case coupon.FieldBindOrderID:
		return m.AddedBindOrderID()
	case coupon.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case coupon.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case coupon.FieldLimitAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimitAmount(v)
		return nil
	case coupon.FieldCouponAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponAmount(v)
		return nil
	case coupon.FieldBindOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBindOrderID(v)
		return nil
	case coupon.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldDeleteTime) {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.FieldCleared(coupon.FieldScenicAreaID) {
		fields = append(fields, coupon.FieldScenicAreaID)
	}
	if m.FieldCleared(coupon.FieldBindOrderID) {
		fields = append(fields, coupon.FieldBindOrderID)
	}
	if m.FieldCleared(coupon.FieldValidStartTime) {
		fields = append(fields, coupon.FieldValidStartTime)
	}
	if m.FieldCleared(coupon.FieldValidEndTime) {
		fields = append(fields, coupon.FieldValidEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case coupon.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case coupon.FieldBindOrderID:
		m.ClearBindOrderID()
		return nil
	case coupon.FieldValidStartTime:
		m.ClearValidStartTime()
		return nil
	case coupon.FieldValidEndTime:
		m.ClearValidEndTime()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupon.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case coupon.FieldName:
		m.ResetName()
		return nil
	case coupon.FieldCouponNo:
		m.ResetCouponNo()
		return nil
	case coupon.FieldUserID:
		m.ResetUserID()
		return nil
	case coupon.FieldLimitAmount:
		m.ResetLimitAmount()
		return nil
	case coupon.FieldCouponAmount:
		m.ResetCouponAmount()
		return nil
	case coupon.FieldBindOrderID:
		m.ResetBindOrderID()
		return nil
	case coupon.FieldState:
		m.ResetState()
		return nil
	case coupon.FieldValidStartTime:
		m.ResetValidStartTime()
		return nil
	case coupon.FieldValidEndTime:
		m.ResetValidEndTime()
		return nil
	case coupon.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupon.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// FeedbackMutation represents an operation that mutates the Feedback nodes in the graph.
type FeedbackMutation struct {
	config
	op                Op
	typ               string
	id                *int
	user_id           *int
	adduser_id        *int
	scenic_area_id    *int
	addscenic_area_id *int
	content           *string
	state             *int
	addstate          *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Feedback, error)
	predicates        []predicate.Feedback
}

var _ ent.Mutation = (*FeedbackMutation)(nil)

// feedbackOption allows management of the mutation configuration using functional options.
type feedbackOption func(*FeedbackMutation)

// newFeedbackMutation creates new mutation for the Feedback entity.
func newFeedbackMutation(c config, op Op, opts ...feedbackOption) *FeedbackMutation {
	m := &FeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedbackID sets the ID field of the mutation.
func withFeedbackID(id int) feedbackOption {
	return func(m *FeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *Feedback
		)
		m.oldValue = func(ctx context.Context) (*Feedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedback sets the old Feedback of the mutation.
func withFeedback(node *Feedback) feedbackOption {
	return func(m *FeedbackMutation) {
		m.oldValue = func(context.Context) (*Feedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feedback entities.
func (m *FeedbackMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedbackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedbackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FeedbackMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FeedbackMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FeedbackMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FeedbackMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FeedbackMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *FeedbackMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *FeedbackMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *FeedbackMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *FeedbackMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *FeedbackMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetContent sets the "content" field.
func (m *FeedbackMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FeedbackMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *FeedbackMutation) ResetContent() {
	m.content = nil
}

// SetState sets the "state" field.
func (m *FeedbackMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *FeedbackMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *FeedbackMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *FeedbackMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *FeedbackMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *FeedbackMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FeedbackMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FeedbackMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FeedbackMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FeedbackMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FeedbackMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the FeedbackMutation builder.
func (m *FeedbackMutation) Where(ps ...predicate.Feedback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feedback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feedback).
func (m *FeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedbackMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, feedback.FieldUserID)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, feedback.FieldScenicAreaID)
	}
	if m.content != nil {
		fields = append(fields, feedback.FieldContent)
	}
	if m.state != nil {
		fields = append(fields, feedback.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, feedback.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, feedback.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldUserID:
		return m.UserID()
	case feedback.FieldScenicAreaID:
		return m.ScenicAreaID()
	case feedback.FieldContent:
		return m.Content()
	case feedback.FieldState:
		return m.State()
	case feedback.FieldCreateTime:
		return m.CreateTime()
	case feedback.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedback.FieldUserID:
		return m.OldUserID(ctx)
	case feedback.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case feedback.FieldContent:
		return m.OldContent(ctx)
	case feedback.FieldState:
		return m.OldState(ctx)
	case feedback.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case feedback.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Feedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case feedback.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case feedback.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case feedback.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case feedback.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case feedback.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedbackMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, feedback.FieldUserID)
	}
	if m.addscenic_area_id != nil {
		fields = append(fields, feedback.FieldScenicAreaID)
	}
	if m.addstate != nil {
		fields = append(fields, feedback.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldUserID:
		return m.AddedUserID()
	case feedback.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case feedback.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case feedback.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case feedback.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedbackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedbackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Feedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedbackMutation) ResetField(name string) error {
	switch name {
	case feedback.FieldUserID:
		m.ResetUserID()
		return nil
	case feedback.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case feedback.FieldContent:
		m.ResetContent()
		return nil
	case feedback.FieldState:
		m.ResetState()
		return nil
	case feedback.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case feedback.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedbackMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedbackMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedbackMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Feedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedbackMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Feedback edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                Op
	typ               string
	id                *int
	storage_type      *int
	addstorage_type   *int
	creator_id        *int
	addcreator_id     *int
	scenic_area_id    *int
	addscenic_area_id *int
	file_category     *int
	addfile_category  *int
	file_type         *int
	addfile_type      *int
	file_sha1         *string
	file_path         *string
	mime_type         *string
	file_suffix       *string
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*File, error)
	predicates        []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStorageType sets the "storage_type" field.
func (m *FileMutation) SetStorageType(i int) {
	m.storage_type = &i
	m.addstorage_type = nil
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *FileMutation) StorageType() (r int, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStorageType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// AddStorageType adds i to the "storage_type" field.
func (m *FileMutation) AddStorageType(i int) {
	if m.addstorage_type != nil {
		*m.addstorage_type += i
	} else {
		m.addstorage_type = &i
	}
}

// AddedStorageType returns the value that was added to the "storage_type" field in this mutation.
func (m *FileMutation) AddedStorageType() (r int, exists bool) {
	v := m.addstorage_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *FileMutation) ResetStorageType() {
	m.storage_type = nil
	m.addstorage_type = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *FileMutation) SetCreatorID(i int) {
	m.creator_id = &i
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *FileMutation) CreatorID() (r int, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds i to the "creator_id" field.
func (m *FileMutation) AddCreatorID(i int) {
	if m.addcreator_id != nil {
		*m.addcreator_id += i
	} else {
		m.addcreator_id = &i
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *FileMutation) AddedCreatorID() (r int, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *FileMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *FileMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *FileMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *FileMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *FileMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *FileMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetFileCategory sets the "file_category" field.
func (m *FileMutation) SetFileCategory(i int) {
	m.file_category = &i
	m.addfile_category = nil
}

// FileCategory returns the value of the "file_category" field in the mutation.
func (m *FileMutation) FileCategory() (r int, exists bool) {
	v := m.file_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFileCategory returns the old "file_category" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileCategory: %w", err)
	}
	return oldValue.FileCategory, nil
}

// AddFileCategory adds i to the "file_category" field.
func (m *FileMutation) AddFileCategory(i int) {
	if m.addfile_category != nil {
		*m.addfile_category += i
	} else {
		m.addfile_category = &i
	}
}

// AddedFileCategory returns the value that was added to the "file_category" field in this mutation.
func (m *FileMutation) AddedFileCategory() (r int, exists bool) {
	v := m.addfile_category
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileCategory resets all changes to the "file_category" field.
func (m *FileMutation) ResetFileCategory() {
	m.file_category = nil
	m.addfile_category = nil
}

// SetFileType sets the "file_type" field.
func (m *FileMutation) SetFileType(i int) {
	m.file_type = &i
	m.addfile_type = nil
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *FileMutation) FileType() (r int, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// AddFileType adds i to the "file_type" field.
func (m *FileMutation) AddFileType(i int) {
	if m.addfile_type != nil {
		*m.addfile_type += i
	} else {
		m.addfile_type = &i
	}
}

// AddedFileType returns the value that was added to the "file_type" field in this mutation.
func (m *FileMutation) AddedFileType() (r int, exists bool) {
	v := m.addfile_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileType resets all changes to the "file_type" field.
func (m *FileMutation) ResetFileType() {
	m.file_type = nil
	m.addfile_type = nil
}

// SetFileSha1 sets the "file_sha1" field.
func (m *FileMutation) SetFileSha1(s string) {
	m.file_sha1 = &s
}

// FileSha1 returns the value of the "file_sha1" field in the mutation.
func (m *FileMutation) FileSha1() (r string, exists bool) {
	v := m.file_sha1
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSha1 returns the old "file_sha1" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileSha1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSha1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSha1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSha1: %w", err)
	}
	return oldValue.FileSha1, nil
}

// ResetFileSha1 resets all changes to the "file_sha1" field.
func (m *FileMutation) ResetFileSha1() {
	m.file_sha1 = nil
}

// SetFilePath sets the "file_path" field.
func (m *FileMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *FileMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *FileMutation) ResetFilePath() {
	m.file_path = nil
}

// SetMimeType sets the "mime_type" field.
func (m *FileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *FileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *FileMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetFileSuffix sets the "file_suffix" field.
func (m *FileMutation) SetFileSuffix(s string) {
	m.file_suffix = &s
}

// FileSuffix returns the value of the "file_suffix" field in the mutation.
func (m *FileMutation) FileSuffix() (r string, exists bool) {
	v := m.file_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSuffix returns the old "file_suffix" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSuffix: %w", err)
	}
	return oldValue.FileSuffix, nil
}

// ResetFileSuffix resets all changes to the "file_suffix" field.
func (m *FileMutation) ResetFileSuffix() {
	m.file_suffix = nil
}

// SetCreateTime sets the "create_time" field.
func (m *FileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.storage_type != nil {
		fields = append(fields, file.FieldStorageType)
	}
	if m.creator_id != nil {
		fields = append(fields, file.FieldCreatorID)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, file.FieldScenicAreaID)
	}
	if m.file_category != nil {
		fields = append(fields, file.FieldFileCategory)
	}
	if m.file_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	if m.file_sha1 != nil {
		fields = append(fields, file.FieldFileSha1)
	}
	if m.file_path != nil {
		fields = append(fields, file.FieldFilePath)
	}
	if m.mime_type != nil {
		fields = append(fields, file.FieldMimeType)
	}
	if m.file_suffix != nil {
		fields = append(fields, file.FieldFileSuffix)
	}
	if m.create_time != nil {
		fields = append(fields, file.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, file.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldStorageType:
		return m.StorageType()
	case file.FieldCreatorID:
		return m.CreatorID()
	case file.FieldScenicAreaID:
		return m.ScenicAreaID()
	case file.FieldFileCategory:
		return m.FileCategory()
	case file.FieldFileType:
		return m.FileType()
	case file.FieldFileSha1:
		return m.FileSha1()
	case file.FieldFilePath:
		return m.FilePath()
	case file.FieldMimeType:
		return m.MimeType()
	case file.FieldFileSuffix:
		return m.FileSuffix()
	case file.FieldCreateTime:
		return m.CreateTime()
	case file.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldStorageType:
		return m.OldStorageType(ctx)
	case file.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case file.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case file.FieldFileCategory:
		return m.OldFileCategory(ctx)
	case file.FieldFileType:
		return m.OldFileType(ctx)
	case file.FieldFileSha1:
		return m.OldFileSha1(ctx)
	case file.FieldFilePath:
		return m.OldFilePath(ctx)
	case file.FieldMimeType:
		return m.OldMimeType(ctx)
	case file.FieldFileSuffix:
		return m.OldFileSuffix(ctx)
	case file.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case file.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldStorageType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case file.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case file.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case file.FieldFileCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileCategory(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case file.FieldFileSha1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSha1(v)
		return nil
	case file.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case file.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case file.FieldFileSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSuffix(v)
		return nil
	case file.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case file.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addstorage_type != nil {
		fields = append(fields, file.FieldStorageType)
	}
	if m.addcreator_id != nil {
		fields = append(fields, file.FieldCreatorID)
	}
	if m.addscenic_area_id != nil {
		fields = append(fields, file.FieldScenicAreaID)
	}
	if m.addfile_category != nil {
		fields = append(fields, file.FieldFileCategory)
	}
	if m.addfile_type != nil {
		fields = append(fields, file.FieldFileType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldStorageType:
		return m.AddedStorageType()
	case file.FieldCreatorID:
		return m.AddedCreatorID()
	case file.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case file.FieldFileCategory:
		return m.AddedFileCategory()
	case file.FieldFileType:
		return m.AddedFileType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldStorageType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageType(v)
		return nil
	case file.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	case file.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case file.FieldFileCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileCategory(v)
		return nil
	case file.FieldFileType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileType(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldStorageType:
		m.ResetStorageType()
		return nil
	case file.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case file.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case file.FieldFileCategory:
		m.ResetFileCategory()
		return nil
	case file.FieldFileType:
		m.ResetFileType()
		return nil
	case file.FieldFileSha1:
		m.ResetFileSha1()
		return nil
	case file.FieldFilePath:
		m.ResetFilePath()
		return nil
	case file.FieldMimeType:
		m.ResetMimeType()
		return nil
	case file.FieldFileSuffix:
		m.ResetFileSuffix()
		return nil
	case file.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case file.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown File edge %s", name)
}

// MapVersionMutation represents an operation that mutates the MapVersion nodes in the graph.
type MapVersionMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	file_id                       *int
	addfile_id                    *int
	file_path                     *string
	version                       *string
	name                          *string
	remark                        *string
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*MapVersion, error)
	predicates                    []predicate.MapVersion
}

var _ ent.Mutation = (*MapVersionMutation)(nil)

// mapversionOption allows management of the mutation configuration using functional options.
type mapversionOption func(*MapVersionMutation)

// newMapVersionMutation creates new mutation for the MapVersion entity.
func newMapVersionMutation(c config, op Op, opts ...mapversionOption) *MapVersionMutation {
	m := &MapVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeMapVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMapVersionID sets the ID field of the mutation.
func withMapVersionID(id int) mapversionOption {
	return func(m *MapVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *MapVersion
		)
		m.oldValue = func(ctx context.Context) (*MapVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MapVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMapVersion sets the old MapVersion of the mutation.
func withMapVersion(node *MapVersion) mapversionOption {
	return func(m *MapVersionMutation) {
		m.oldValue = func(context.Context) (*MapVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MapVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MapVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MapVersion entities.
func (m *MapVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MapVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MapVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MapVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *MapVersionMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *MapVersionMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *MapVersionMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetFileID sets the "file_id" field.
func (m *MapVersionMutation) SetFileID(i int) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *MapVersionMutation) FileID() (r int, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *MapVersionMutation) AddFileID(i int) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *MapVersionMutation) AddedFileID() (r int, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *MapVersionMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetFilePath sets the "file_path" field.
func (m *MapVersionMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *MapVersionMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *MapVersionMutation) ResetFilePath() {
	m.file_path = nil
}

// SetVersion sets the "version" field.
func (m *MapVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *MapVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *MapVersionMutation) ResetVersion() {
	m.version = nil
}

// SetName sets the "name" field.
func (m *MapVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MapVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MapVersionMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *MapVersionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MapVersionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *MapVersionMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *MapVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MapVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MapVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MapVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MapVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the MapVersion entity.
// If the MapVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapVersionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MapVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *MapVersionMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *MapVersionMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[mapversion.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *MapVersionMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *MapVersionMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *MapVersionMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *MapVersionMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the MapVersionMutation builder.
func (m *MapVersionMutation) Where(ps ...predicate.MapVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MapVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MapVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MapVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MapVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MapVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MapVersion).
func (m *MapVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MapVersionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.background_scenic_area != nil {
		fields = append(fields, mapversion.FieldScenicAreaID)
	}
	if m.file_id != nil {
		fields = append(fields, mapversion.FieldFileID)
	}
	if m.file_path != nil {
		fields = append(fields, mapversion.FieldFilePath)
	}
	if m.version != nil {
		fields = append(fields, mapversion.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, mapversion.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, mapversion.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, mapversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, mapversion.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MapVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mapversion.FieldScenicAreaID:
		return m.ScenicAreaID()
	case mapversion.FieldFileID:
		return m.FileID()
	case mapversion.FieldFilePath:
		return m.FilePath()
	case mapversion.FieldVersion:
		return m.Version()
	case mapversion.FieldName:
		return m.Name()
	case mapversion.FieldRemark:
		return m.Remark()
	case mapversion.FieldCreateTime:
		return m.CreateTime()
	case mapversion.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MapVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mapversion.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case mapversion.FieldFileID:
		return m.OldFileID(ctx)
	case mapversion.FieldFilePath:
		return m.OldFilePath(ctx)
	case mapversion.FieldVersion:
		return m.OldVersion(ctx)
	case mapversion.FieldName:
		return m.OldName(ctx)
	case mapversion.FieldRemark:
		return m.OldRemark(ctx)
	case mapversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case mapversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown MapVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MapVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mapversion.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case mapversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case mapversion.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case mapversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case mapversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mapversion.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case mapversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case mapversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown MapVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MapVersionMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, mapversion.FieldFileID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MapVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mapversion.FieldFileID:
		return m.AddedFileID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MapVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mapversion.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	}
	return fmt.Errorf("unknown MapVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MapVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MapVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MapVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MapVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MapVersionMutation) ResetField(name string) error {
	switch name {
	case mapversion.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case mapversion.FieldFileID:
		m.ResetFileID()
		return nil
	case mapversion.FieldFilePath:
		m.ResetFilePath()
		return nil
	case mapversion.FieldVersion:
		m.ResetVersion()
		return nil
	case mapversion.FieldName:
		m.ResetName()
		return nil
	case mapversion.FieldRemark:
		m.ResetRemark()
		return nil
	case mapversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case mapversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown MapVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MapVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, mapversion.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MapVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mapversion.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MapVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MapVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MapVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, mapversion.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MapVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case mapversion.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MapVersionMutation) ClearEdge(name string) error {
	switch name {
	case mapversion.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown MapVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MapVersionMutation) ResetEdge(name string) error {
	switch name {
	case mapversion.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown MapVersion edge %s", name)
}

// OperationUserMutation represents an operation that mutates the OperationUser nodes in the graph.
type OperationUserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	scenic_area_id    *int
	addscenic_area_id *int
	username          *string
	nickname          *string
	phone             *string
	password          *string
	open_id           *string
	avatar_url        *string
	status            *int
	addstatus         *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*OperationUser, error)
	predicates        []predicate.OperationUser
}

var _ ent.Mutation = (*OperationUserMutation)(nil)

// operationuserOption allows management of the mutation configuration using functional options.
type operationuserOption func(*OperationUserMutation)

// newOperationUserMutation creates new mutation for the OperationUser entity.
func newOperationUserMutation(c config, op Op, opts ...operationuserOption) *OperationUserMutation {
	m := &OperationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOperationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationUserID sets the ID field of the mutation.
func withOperationUserID(id int) operationuserOption {
	return func(m *OperationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OperationUser
		)
		m.oldValue = func(ctx context.Context) (*OperationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OperationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperationUser sets the old OperationUser of the mutation.
func withOperationUser(node *OperationUser) operationuserOption {
	return func(m *OperationUserMutation) {
		m.oldValue = func(context.Context) (*OperationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OperationUser entities.
func (m *OperationUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperationUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperationUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OperationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *OperationUserMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *OperationUserMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *OperationUserMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *OperationUserMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *OperationUserMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetUsername sets the "username" field.
func (m *OperationUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperationUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperationUserMutation) ResetUsername() {
	m.username = nil
}

// SetNickname sets the "nickname" field.
func (m *OperationUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *OperationUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *OperationUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetPhone sets the "phone" field.
func (m *OperationUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *OperationUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *OperationUserMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *OperationUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *OperationUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *OperationUserMutation) ResetPassword() {
	m.password = nil
}

// SetOpenID sets the "open_id" field.
func (m *OperationUserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *OperationUserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *OperationUserMutation) ResetOpenID() {
	m.open_id = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *OperationUserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *OperationUserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *OperationUserMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetStatus sets the "status" field.
func (m *OperationUserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OperationUserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OperationUserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OperationUserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OperationUserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OperationUserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OperationUserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OperationUserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OperationUserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OperationUserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OperationUser entity.
// If the OperationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationUserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OperationUserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OperationUserMutation builder.
func (m *OperationUserMutation) Where(ps ...predicate.OperationUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperationUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperationUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OperationUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperationUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperationUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OperationUser).
func (m *OperationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperationUserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.scenic_area_id != nil {
		fields = append(fields, operationuser.FieldScenicAreaID)
	}
	if m.username != nil {
		fields = append(fields, operationuser.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, operationuser.FieldNickname)
	}
	if m.phone != nil {
		fields = append(fields, operationuser.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, operationuser.FieldPassword)
	}
	if m.open_id != nil {
		fields = append(fields, operationuser.FieldOpenID)
	}
	if m.avatar_url != nil {
		fields = append(fields, operationuser.FieldAvatarURL)
	}
	if m.status != nil {
		fields = append(fields, operationuser.FieldStatus)
	}
	if m.create_time != nil {
		fields = append(fields, operationuser.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, operationuser.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operationuser.FieldScenicAreaID:
		return m.ScenicAreaID()
	case operationuser.FieldUsername:
		return m.Username()
	case operationuser.FieldNickname:
		return m.Nickname()
	case operationuser.FieldPhone:
		return m.Phone()
	case operationuser.FieldPassword:
		return m.Password()
	case operationuser.FieldOpenID:
		return m.OpenID()
	case operationuser.FieldAvatarURL:
		return m.AvatarURL()
	case operationuser.FieldStatus:
		return m.Status()
	case operationuser.FieldCreateTime:
		return m.CreateTime()
	case operationuser.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operationuser.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case operationuser.FieldUsername:
		return m.OldUsername(ctx)
	case operationuser.FieldNickname:
		return m.OldNickname(ctx)
	case operationuser.FieldPhone:
		return m.OldPhone(ctx)
	case operationuser.FieldPassword:
		return m.OldPassword(ctx)
	case operationuser.FieldOpenID:
		return m.OldOpenID(ctx)
	case operationuser.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case operationuser.FieldStatus:
		return m.OldStatus(ctx)
	case operationuser.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case operationuser.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OperationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operationuser.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case operationuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operationuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case operationuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case operationuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case operationuser.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case operationuser.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case operationuser.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case operationuser.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case operationuser.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OperationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperationUserMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, operationuser.FieldScenicAreaID)
	}
	if m.addstatus != nil {
		fields = append(fields, operationuser.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperationUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operationuser.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case operationuser.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operationuser.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case operationuser.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OperationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperationUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OperationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperationUserMutation) ResetField(name string) error {
	switch name {
	case operationuser.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case operationuser.FieldUsername:
		m.ResetUsername()
		return nil
	case operationuser.FieldNickname:
		m.ResetNickname()
		return nil
	case operationuser.FieldPhone:
		m.ResetPhone()
		return nil
	case operationuser.FieldPassword:
		m.ResetPassword()
		return nil
	case operationuser.FieldOpenID:
		m.ResetOpenID()
		return nil
	case operationuser.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case operationuser.FieldStatus:
		m.ResetStatus()
		return nil
	case operationuser.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case operationuser.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OperationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperationUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperationUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperationUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OperationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperationUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OperationUser edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	_type                         *int
	add_type                      *int
	period                        *int
	addperiod                     *int
	order_no                      *string
	wx_tx_id                      *string
	mch_id                        *string
	scenic_area_name              *string
	user_id                       *int
	adduser_id                    *int
	open_id                       *string
	nickname                      *string
	phone                         *string
	device_id                     *string
	car_name                      *string
	car_license_plate             *string
	model_id                      *int
	addmodel_id                   *int
	model_name                    *string
	coupon_id                     *int
	addcoupon_id                  *int
	coupon_name                   *string
	use_mileage_meter             *int
	adduse_mileage_meter          *int
	use_time_second               *int
	adduse_time_second            *int
	deposit_amount                *int
	adddeposit_amount             *int
	original_amount               *int
	addoriginal_amount            *int
	order_amount                  *int
	addorder_amount               *int
	refunded_amount               *int
	addrefunded_amount            *int
	coupon_amount                 *int
	addcoupon_amount              *int
	order_state                   *int
	addorder_state                *int
	deposit_state                 *int
	adddeposit_state              *int
	emergency_state               *int
	addemergency_state            *int
	is_test_order                 *bool
	is_cancel                     *bool
	is_profit_sharing             *bool
	remark                        *string
	user_score                    *int
	adduser_score                 *int
	user_comment                  *string
	deposit_time                  *time.Time
	finish_time                   *time.Time
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	car                           *int
	clearedcar                    bool
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	billing                       *int
	clearedbilling                bool
	refund                        map[int]struct{}
	removedrefund                 map[int]struct{}
	clearedrefund                 bool
	sharing                       *int
	clearedsharing                bool
	done                          bool
	oldValue                      func(context.Context) (*Order, error)
	predicates                    []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetPeriod sets the "period" field.
func (m *OrderMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *OrderMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *OrderMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *OrderMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *OrderMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetOrderNo sets the "order_no" field.
func (m *OrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetWxTxID sets the "wx_tx_id" field.
func (m *OrderMutation) SetWxTxID(s string) {
	m.wx_tx_id = &s
}

// WxTxID returns the value of the "wx_tx_id" field in the mutation.
func (m *OrderMutation) WxTxID() (r string, exists bool) {
	v := m.wx_tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWxTxID returns the old "wx_tx_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWxTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWxTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWxTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxTxID: %w", err)
	}
	return oldValue.WxTxID, nil
}

// ResetWxTxID resets all changes to the "wx_tx_id" field.
func (m *OrderMutation) ResetWxTxID() {
	m.wx_tx_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *OrderMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *OrderMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *OrderMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetMchID sets the "mch_id" field.
func (m *OrderMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *OrderMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *OrderMutation) ResetMchID() {
	m.mch_id = nil
}

// SetScenicAreaName sets the "scenic_area_name" field.
func (m *OrderMutation) SetScenicAreaName(s string) {
	m.scenic_area_name = &s
}

// ScenicAreaName returns the value of the "scenic_area_name" field in the mutation.
func (m *OrderMutation) ScenicAreaName() (r string, exists bool) {
	v := m.scenic_area_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaName returns the old "scenic_area_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldScenicAreaName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaName: %w", err)
	}
	return oldValue.ScenicAreaName, nil
}

// ResetScenicAreaName resets all changes to the "scenic_area_name" field.
func (m *OrderMutation) ResetScenicAreaName() {
	m.scenic_area_name = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOpenID sets the "open_id" field.
func (m *OrderMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *OrderMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *OrderMutation) ResetOpenID() {
	m.open_id = nil
}

// SetNickname sets the "nickname" field.
func (m *OrderMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *OrderMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *OrderMutation) ResetNickname() {
	m.nickname = nil
}

// SetPhone sets the "phone" field.
func (m *OrderMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *OrderMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *OrderMutation) ResetPhone() {
	m.phone = nil
}

// SetCarID sets the "car_id" field.
func (m *OrderMutation) SetCarID(i int) {
	m.car = &i
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *OrderMutation) CarID() (r int, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ResetCarID resets all changes to the "car_id" field.
func (m *OrderMutation) ResetCarID() {
	m.car = nil
}

// SetDeviceID sets the "device_id" field.
func (m *OrderMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *OrderMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *OrderMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetCarName sets the "car_name" field.
func (m *OrderMutation) SetCarName(s string) {
	m.car_name = &s
}

// CarName returns the value of the "car_name" field in the mutation.
func (m *OrderMutation) CarName() (r string, exists bool) {
	v := m.car_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCarName returns the old "car_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCarName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarName: %w", err)
	}
	return oldValue.CarName, nil
}

// ResetCarName resets all changes to the "car_name" field.
func (m *OrderMutation) ResetCarName() {
	m.car_name = nil
}

// SetCarLicensePlate sets the "car_license_plate" field.
func (m *OrderMutation) SetCarLicensePlate(s string) {
	m.car_license_plate = &s
}

// CarLicensePlate returns the value of the "car_license_plate" field in the mutation.
func (m *OrderMutation) CarLicensePlate() (r string, exists bool) {
	v := m.car_license_plate
	if v == nil {
		return
	}
	return *v, true
}

// OldCarLicensePlate returns the old "car_license_plate" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCarLicensePlate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarLicensePlate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarLicensePlate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarLicensePlate: %w", err)
	}
	return oldValue.CarLicensePlate, nil
}

// ResetCarLicensePlate resets all changes to the "car_license_plate" field.
func (m *OrderMutation) ResetCarLicensePlate() {
	m.car_license_plate = nil
}

// SetModelID sets the "model_id" field.
func (m *OrderMutation) SetModelID(i int) {
	m.model_id = &i
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *OrderMutation) ModelID() (r int, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldModelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds i to the "model_id" field.
func (m *OrderMutation) AddModelID(i int) {
	if m.addmodel_id != nil {
		*m.addmodel_id += i
	} else {
		m.addmodel_id = &i
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *OrderMutation) AddedModelID() (r int, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetModelID resets all changes to the "model_id" field.
func (m *OrderMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
}

// SetModelName sets the "model_name" field.
func (m *OrderMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *OrderMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ResetModelName resets all changes to the "model_name" field.
func (m *OrderMutation) ResetModelName() {
	m.model_name = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *OrderMutation) SetCouponID(i int) {
	m.coupon_id = &i
	m.addcoupon_id = nil
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *OrderMutation) CouponID() (r int, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// AddCouponID adds i to the "coupon_id" field.
func (m *OrderMutation) AddCouponID(i int) {
	if m.addcoupon_id != nil {
		*m.addcoupon_id += i
	} else {
		m.addcoupon_id = &i
	}
}

// AddedCouponID returns the value that was added to the "coupon_id" field in this mutation.
func (m *OrderMutation) AddedCouponID() (r int, exists bool) {
	v := m.addcoupon_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *OrderMutation) ResetCouponID() {
	m.coupon_id = nil
	m.addcoupon_id = nil
}

// SetCouponName sets the "coupon_name" field.
func (m *OrderMutation) SetCouponName(s string) {
	m.coupon_name = &s
}

// CouponName returns the value of the "coupon_name" field in the mutation.
func (m *OrderMutation) CouponName() (r string, exists bool) {
	v := m.coupon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponName returns the old "coupon_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponName: %w", err)
	}
	return oldValue.CouponName, nil
}

// ResetCouponName resets all changes to the "coupon_name" field.
func (m *OrderMutation) ResetCouponName() {
	m.coupon_name = nil
}

// SetUseMileageMeter sets the "use_mileage_meter" field.
func (m *OrderMutation) SetUseMileageMeter(i int) {
	m.use_mileage_meter = &i
	m.adduse_mileage_meter = nil
}

// UseMileageMeter returns the value of the "use_mileage_meter" field in the mutation.
func (m *OrderMutation) UseMileageMeter() (r int, exists bool) {
	v := m.use_mileage_meter
	if v == nil {
		return
	}
	return *v, true
}

// OldUseMileageMeter returns the old "use_mileage_meter" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUseMileageMeter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseMileageMeter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseMileageMeter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseMileageMeter: %w", err)
	}
	return oldValue.UseMileageMeter, nil
}

// AddUseMileageMeter adds i to the "use_mileage_meter" field.
func (m *OrderMutation) AddUseMileageMeter(i int) {
	if m.adduse_mileage_meter != nil {
		*m.adduse_mileage_meter += i
	} else {
		m.adduse_mileage_meter = &i
	}
}

// AddedUseMileageMeter returns the value that was added to the "use_mileage_meter" field in this mutation.
func (m *OrderMutation) AddedUseMileageMeter() (r int, exists bool) {
	v := m.adduse_mileage_meter
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseMileageMeter resets all changes to the "use_mileage_meter" field.
func (m *OrderMutation) ResetUseMileageMeter() {
	m.use_mileage_meter = nil
	m.adduse_mileage_meter = nil
}

// SetUseTimeSecond sets the "use_time_second" field.
func (m *OrderMutation) SetUseTimeSecond(i int) {
	m.use_time_second = &i
	m.adduse_time_second = nil
}

// UseTimeSecond returns the value of the "use_time_second" field in the mutation.
func (m *OrderMutation) UseTimeSecond() (r int, exists bool) {
	v := m.use_time_second
	if v == nil {
		return
	}
	return *v, true
}

// OldUseTimeSecond returns the old "use_time_second" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUseTimeSecond(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseTimeSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseTimeSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseTimeSecond: %w", err)
	}
	return oldValue.UseTimeSecond, nil
}

// AddUseTimeSecond adds i to the "use_time_second" field.
func (m *OrderMutation) AddUseTimeSecond(i int) {
	if m.adduse_time_second != nil {
		*m.adduse_time_second += i
	} else {
		m.adduse_time_second = &i
	}
}

// AddedUseTimeSecond returns the value that was added to the "use_time_second" field in this mutation.
func (m *OrderMutation) AddedUseTimeSecond() (r int, exists bool) {
	v := m.adduse_time_second
	if v == nil {
		return
	}
	return *v, true
}

// ResetUseTimeSecond resets all changes to the "use_time_second" field.
func (m *OrderMutation) ResetUseTimeSecond() {
	m.use_time_second = nil
	m.adduse_time_second = nil
}

// SetDepositAmount sets the "deposit_amount" field.
func (m *OrderMutation) SetDepositAmount(i int) {
	m.deposit_amount = &i
	m.adddeposit_amount = nil
}

// DepositAmount returns the value of the "deposit_amount" field in the mutation.
func (m *OrderMutation) DepositAmount() (r int, exists bool) {
	v := m.deposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositAmount returns the old "deposit_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDepositAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositAmount: %w", err)
	}
	return oldValue.DepositAmount, nil
}

// AddDepositAmount adds i to the "deposit_amount" field.
func (m *OrderMutation) AddDepositAmount(i int) {
	if m.adddeposit_amount != nil {
		*m.adddeposit_amount += i
	} else {
		m.adddeposit_amount = &i
	}
}

// AddedDepositAmount returns the value that was added to the "deposit_amount" field in this mutation.
func (m *OrderMutation) AddedDepositAmount() (r int, exists bool) {
	v := m.adddeposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepositAmount resets all changes to the "deposit_amount" field.
func (m *OrderMutation) ResetDepositAmount() {
	m.deposit_amount = nil
	m.adddeposit_amount = nil
}

// SetOriginalAmount sets the "original_amount" field.
func (m *OrderMutation) SetOriginalAmount(i int) {
	m.original_amount = &i
	m.addoriginal_amount = nil
}

// OriginalAmount returns the value of the "original_amount" field in the mutation.
func (m *OrderMutation) OriginalAmount() (r int, exists bool) {
	v := m.original_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalAmount returns the old "original_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOriginalAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalAmount: %w", err)
	}
	return oldValue.OriginalAmount, nil
}

// AddOriginalAmount adds i to the "original_amount" field.
func (m *OrderMutation) AddOriginalAmount(i int) {
	if m.addoriginal_amount != nil {
		*m.addoriginal_amount += i
	} else {
		m.addoriginal_amount = &i
	}
}

// AddedOriginalAmount returns the value that was added to the "original_amount" field in this mutation.
func (m *OrderMutation) AddedOriginalAmount() (r int, exists bool) {
	v := m.addoriginal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOriginalAmount resets all changes to the "original_amount" field.
func (m *OrderMutation) ResetOriginalAmount() {
	m.original_amount = nil
	m.addoriginal_amount = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *OrderMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *OrderMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *OrderMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *OrderMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *OrderMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetRefundedAmount sets the "refunded_amount" field.
func (m *OrderMutation) SetRefundedAmount(i int) {
	m.refunded_amount = &i
	m.addrefunded_amount = nil
}

// RefundedAmount returns the value of the "refunded_amount" field in the mutation.
func (m *OrderMutation) RefundedAmount() (r int, exists bool) {
	v := m.refunded_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundedAmount returns the old "refunded_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRefundedAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundedAmount: %w", err)
	}
	return oldValue.RefundedAmount, nil
}

// AddRefundedAmount adds i to the "refunded_amount" field.
func (m *OrderMutation) AddRefundedAmount(i int) {
	if m.addrefunded_amount != nil {
		*m.addrefunded_amount += i
	} else {
		m.addrefunded_amount = &i
	}
}

// AddedRefundedAmount returns the value that was added to the "refunded_amount" field in this mutation.
func (m *OrderMutation) AddedRefundedAmount() (r int, exists bool) {
	v := m.addrefunded_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefundedAmount resets all changes to the "refunded_amount" field.
func (m *OrderMutation) ResetRefundedAmount() {
	m.refunded_amount = nil
	m.addrefunded_amount = nil
}

// SetCouponAmount sets the "coupon_amount" field.
func (m *OrderMutation) SetCouponAmount(i int) {
	m.coupon_amount = &i
	m.addcoupon_amount = nil
}

// CouponAmount returns the value of the "coupon_amount" field in the mutation.
func (m *OrderMutation) CouponAmount() (r int, exists bool) {
	v := m.coupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponAmount returns the old "coupon_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponAmount: %w", err)
	}
	return oldValue.CouponAmount, nil
}

// AddCouponAmount adds i to the "coupon_amount" field.
func (m *OrderMutation) AddCouponAmount(i int) {
	if m.addcoupon_amount != nil {
		*m.addcoupon_amount += i
	} else {
		m.addcoupon_amount = &i
	}
}

// AddedCouponAmount returns the value that was added to the "coupon_amount" field in this mutation.
func (m *OrderMutation) AddedCouponAmount() (r int, exists bool) {
	v := m.addcoupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponAmount resets all changes to the "coupon_amount" field.
func (m *OrderMutation) ResetCouponAmount() {
	m.coupon_amount = nil
	m.addcoupon_amount = nil
}

// SetOrderState sets the "order_state" field.
func (m *OrderMutation) SetOrderState(i int) {
	m.order_state = &i
	m.addorder_state = nil
}

// OrderState returns the value of the "order_state" field in the mutation.
func (m *OrderMutation) OrderState() (r int, exists bool) {
	v := m.order_state
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderState returns the old "order_state" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderState: %w", err)
	}
	return oldValue.OrderState, nil
}

// AddOrderState adds i to the "order_state" field.
func (m *OrderMutation) AddOrderState(i int) {
	if m.addorder_state != nil {
		*m.addorder_state += i
	} else {
		m.addorder_state = &i
	}
}

// AddedOrderState returns the value that was added to the "order_state" field in this mutation.
func (m *OrderMutation) AddedOrderState() (r int, exists bool) {
	v := m.addorder_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderState resets all changes to the "order_state" field.
func (m *OrderMutation) ResetOrderState() {
	m.order_state = nil
	m.addorder_state = nil
}

// SetDepositState sets the "deposit_state" field.
func (m *OrderMutation) SetDepositState(i int) {
	m.deposit_state = &i
	m.adddeposit_state = nil
}

// DepositState returns the value of the "deposit_state" field in the mutation.
func (m *OrderMutation) DepositState() (r int, exists bool) {
	v := m.deposit_state
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositState returns the old "deposit_state" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDepositState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositState: %w", err)
	}
	return oldValue.DepositState, nil
}

// AddDepositState adds i to the "deposit_state" field.
func (m *OrderMutation) AddDepositState(i int) {
	if m.adddeposit_state != nil {
		*m.adddeposit_state += i
	} else {
		m.adddeposit_state = &i
	}
}

// AddedDepositState returns the value that was added to the "deposit_state" field in this mutation.
func (m *OrderMutation) AddedDepositState() (r int, exists bool) {
	v := m.adddeposit_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepositState resets all changes to the "deposit_state" field.
func (m *OrderMutation) ResetDepositState() {
	m.deposit_state = nil
	m.adddeposit_state = nil
}

// SetEmergencyState sets the "emergency_state" field.
func (m *OrderMutation) SetEmergencyState(i int) {
	m.emergency_state = &i
	m.addemergency_state = nil
}

// EmergencyState returns the value of the "emergency_state" field in the mutation.
func (m *OrderMutation) EmergencyState() (r int, exists bool) {
	v := m.emergency_state
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyState returns the old "emergency_state" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEmergencyState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyState: %w", err)
	}
	return oldValue.EmergencyState, nil
}

// AddEmergencyState adds i to the "emergency_state" field.
func (m *OrderMutation) AddEmergencyState(i int) {
	if m.addemergency_state != nil {
		*m.addemergency_state += i
	} else {
		m.addemergency_state = &i
	}
}

// AddedEmergencyState returns the value that was added to the "emergency_state" field in this mutation.
func (m *OrderMutation) AddedEmergencyState() (r int, exists bool) {
	v := m.addemergency_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmergencyState resets all changes to the "emergency_state" field.
func (m *OrderMutation) ResetEmergencyState() {
	m.emergency_state = nil
	m.addemergency_state = nil
}

// SetIsTestOrder sets the "is_test_order" field.
func (m *OrderMutation) SetIsTestOrder(b bool) {
	m.is_test_order = &b
}

// IsTestOrder returns the value of the "is_test_order" field in the mutation.
func (m *OrderMutation) IsTestOrder() (r bool, exists bool) {
	v := m.is_test_order
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTestOrder returns the old "is_test_order" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsTestOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTestOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTestOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTestOrder: %w", err)
	}
	return oldValue.IsTestOrder, nil
}

// ResetIsTestOrder resets all changes to the "is_test_order" field.
func (m *OrderMutation) ResetIsTestOrder() {
	m.is_test_order = nil
}

// SetIsCancel sets the "is_cancel" field.
func (m *OrderMutation) SetIsCancel(b bool) {
	m.is_cancel = &b
}

// IsCancel returns the value of the "is_cancel" field in the mutation.
func (m *OrderMutation) IsCancel() (r bool, exists bool) {
	v := m.is_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCancel returns the old "is_cancel" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsCancel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCancel: %w", err)
	}
	return oldValue.IsCancel, nil
}

// ResetIsCancel resets all changes to the "is_cancel" field.
func (m *OrderMutation) ResetIsCancel() {
	m.is_cancel = nil
}

// SetIsProfitSharing sets the "is_profit_sharing" field.
func (m *OrderMutation) SetIsProfitSharing(b bool) {
	m.is_profit_sharing = &b
}

// IsProfitSharing returns the value of the "is_profit_sharing" field in the mutation.
func (m *OrderMutation) IsProfitSharing() (r bool, exists bool) {
	v := m.is_profit_sharing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsProfitSharing returns the old "is_profit_sharing" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsProfitSharing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsProfitSharing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsProfitSharing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsProfitSharing: %w", err)
	}
	return oldValue.IsProfitSharing, nil
}

// ResetIsProfitSharing resets all changes to the "is_profit_sharing" field.
func (m *OrderMutation) ResetIsProfitSharing() {
	m.is_profit_sharing = nil
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
}

// SetUserScore sets the "user_score" field.
func (m *OrderMutation) SetUserScore(i int) {
	m.user_score = &i
	m.adduser_score = nil
}

// UserScore returns the value of the "user_score" field in the mutation.
func (m *OrderMutation) UserScore() (r int, exists bool) {
	v := m.user_score
	if v == nil {
		return
	}
	return *v, true
}

// OldUserScore returns the old "user_score" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserScore: %w", err)
	}
	return oldValue.UserScore, nil
}

// AddUserScore adds i to the "user_score" field.
func (m *OrderMutation) AddUserScore(i int) {
	if m.adduser_score != nil {
		*m.adduser_score += i
	} else {
		m.adduser_score = &i
	}
}

// AddedUserScore returns the value that was added to the "user_score" field in this mutation.
func (m *OrderMutation) AddedUserScore() (r int, exists bool) {
	v := m.adduser_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserScore resets all changes to the "user_score" field.
func (m *OrderMutation) ResetUserScore() {
	m.user_score = nil
	m.adduser_score = nil
}

// SetUserComment sets the "user_comment" field.
func (m *OrderMutation) SetUserComment(s string) {
	m.user_comment = &s
}

// UserComment returns the value of the "user_comment" field in the mutation.
func (m *OrderMutation) UserComment() (r string, exists bool) {
	v := m.user_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldUserComment returns the old "user_comment" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserComment: %w", err)
	}
	return oldValue.UserComment, nil
}

// ResetUserComment resets all changes to the "user_comment" field.
func (m *OrderMutation) ResetUserComment() {
	m.user_comment = nil
}

// SetDepositTime sets the "deposit_time" field.
func (m *OrderMutation) SetDepositTime(t time.Time) {
	m.deposit_time = &t
}

// DepositTime returns the value of the "deposit_time" field in the mutation.
func (m *OrderMutation) DepositTime() (r time.Time, exists bool) {
	v := m.deposit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositTime returns the old "deposit_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDepositTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositTime: %w", err)
	}
	return oldValue.DepositTime, nil
}

// ClearDepositTime clears the value of the "deposit_time" field.
func (m *OrderMutation) ClearDepositTime() {
	m.deposit_time = nil
	m.clearedFields[order.FieldDepositTime] = struct{}{}
}

// DepositTimeCleared returns if the "deposit_time" field was cleared in this mutation.
func (m *OrderMutation) DepositTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldDepositTime]
	return ok
}

// ResetDepositTime resets all changes to the "deposit_time" field.
func (m *OrderMutation) ResetDepositTime() {
	m.deposit_time = nil
	delete(m.clearedFields, order.FieldDepositTime)
}

// SetFinishTime sets the "finish_time" field.
func (m *OrderMutation) SetFinishTime(t time.Time) {
	m.finish_time = &t
}

// FinishTime returns the value of the "finish_time" field in the mutation.
func (m *OrderMutation) FinishTime() (r time.Time, exists bool) {
	v := m.finish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old "finish_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFinishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ClearFinishTime clears the value of the "finish_time" field.
func (m *OrderMutation) ClearFinishTime() {
	m.finish_time = nil
	m.clearedFields[order.FieldFinishTime] = struct{}{}
}

// FinishTimeCleared returns if the "finish_time" field was cleared in this mutation.
func (m *OrderMutation) FinishTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldFinishTime]
	return ok
}

// ResetFinishTime resets all changes to the "finish_time" field.
func (m *OrderMutation) ResetFinishTime() {
	m.finish_time = nil
	delete(m.clearedFields, order.FieldFinishTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearCar clears the "car" edge to the Car entity.
func (m *OrderMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[order.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *OrderMutation) CarCleared() bool {
	return m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CarIDs() (ids []int) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *OrderMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *OrderMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *OrderMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[order.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *OrderMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *OrderMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *OrderMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// SetBillingID sets the "billing" edge to the OrderBilling entity by id.
func (m *OrderMutation) SetBillingID(id int) {
	m.billing = &id
}

// ClearBilling clears the "billing" edge to the OrderBilling entity.
func (m *OrderMutation) ClearBilling() {
	m.clearedbilling = true
}

// BillingCleared reports if the "billing" edge to the OrderBilling entity was cleared.
func (m *OrderMutation) BillingCleared() bool {
	return m.clearedbilling
}

// BillingID returns the "billing" edge ID in the mutation.
func (m *OrderMutation) BillingID() (id int, exists bool) {
	if m.billing != nil {
		return *m.billing, true
	}
	return
}

// BillingIDs returns the "billing" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) BillingIDs() (ids []int) {
	if id := m.billing; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBilling resets all changes to the "billing" edge.
func (m *OrderMutation) ResetBilling() {
	m.billing = nil
	m.clearedbilling = false
}

// AddRefundIDs adds the "refund" edge to the OrderRefund entity by ids.
func (m *OrderMutation) AddRefundIDs(ids ...int) {
	if m.refund == nil {
		m.refund = make(map[int]struct{})
	}
	for i := range ids {
		m.refund[ids[i]] = struct{}{}
	}
}

// ClearRefund clears the "refund" edge to the OrderRefund entity.
func (m *OrderMutation) ClearRefund() {
	m.clearedrefund = true
}

// RefundCleared reports if the "refund" edge to the OrderRefund entity was cleared.
func (m *OrderMutation) RefundCleared() bool {
	return m.clearedrefund
}

// RemoveRefundIDs removes the "refund" edge to the OrderRefund entity by IDs.
func (m *OrderMutation) RemoveRefundIDs(ids ...int) {
	if m.removedrefund == nil {
		m.removedrefund = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.refund, ids[i])
		m.removedrefund[ids[i]] = struct{}{}
	}
}

// RemovedRefund returns the removed IDs of the "refund" edge to the OrderRefund entity.
func (m *OrderMutation) RemovedRefundIDs() (ids []int) {
	for id := range m.removedrefund {
		ids = append(ids, id)
	}
	return
}

// RefundIDs returns the "refund" edge IDs in the mutation.
func (m *OrderMutation) RefundIDs() (ids []int) {
	for id := range m.refund {
		ids = append(ids, id)
	}
	return
}

// ResetRefund resets all changes to the "refund" edge.
func (m *OrderMutation) ResetRefund() {
	m.refund = nil
	m.clearedrefund = false
	m.removedrefund = nil
}

// SetSharingID sets the "sharing" edge to the OrderSharing entity by id.
func (m *OrderMutation) SetSharingID(id int) {
	m.sharing = &id
}

// ClearSharing clears the "sharing" edge to the OrderSharing entity.
func (m *OrderMutation) ClearSharing() {
	m.clearedsharing = true
}

// SharingCleared reports if the "sharing" edge to the OrderSharing entity was cleared.
func (m *OrderMutation) SharingCleared() bool {
	return m.clearedsharing
}

// SharingID returns the "sharing" edge ID in the mutation.
func (m *OrderMutation) SharingID() (id int, exists bool) {
	if m.sharing != nil {
		return *m.sharing, true
	}
	return
}

// SharingIDs returns the "sharing" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SharingID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) SharingIDs() (ids []int) {
	if id := m.sharing; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSharing resets all changes to the "sharing" edge.
func (m *OrderMutation) ResetSharing() {
	m.sharing = nil
	m.clearedsharing = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 39)
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.period != nil {
		fields = append(fields, order.FieldPeriod)
	}
	if m.order_no != nil {
		fields = append(fields, order.FieldOrderNo)
	}
	if m.wx_tx_id != nil {
		fields = append(fields, order.FieldWxTxID)
	}
	if m.background_scenic_area != nil {
		fields = append(fields, order.FieldScenicAreaID)
	}
	if m.mch_id != nil {
		fields = append(fields, order.FieldMchID)
	}
	if m.scenic_area_name != nil {
		fields = append(fields, order.FieldScenicAreaName)
	}
	if m.user_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.open_id != nil {
		fields = append(fields, order.FieldOpenID)
	}
	if m.nickname != nil {
		fields = append(fields, order.FieldNickname)
	}
	if m.phone != nil {
		fields = append(fields, order.FieldPhone)
	}
	if m.car != nil {
		fields = append(fields, order.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, order.FieldDeviceID)
	}
	if m.car_name != nil {
		fields = append(fields, order.FieldCarName)
	}
	if m.car_license_plate != nil {
		fields = append(fields, order.FieldCarLicensePlate)
	}
	if m.model_id != nil {
		fields = append(fields, order.FieldModelID)
	}
	if m.model_name != nil {
		fields = append(fields, order.FieldModelName)
	}
	if m.coupon_id != nil {
		fields = append(fields, order.FieldCouponID)
	}
	if m.coupon_name != nil {
		fields = append(fields, order.FieldCouponName)
	}
	if m.use_mileage_meter != nil {
		fields = append(fields, order.FieldUseMileageMeter)
	}
	if m.use_time_second != nil {
		fields = append(fields, order.FieldUseTimeSecond)
	}
	if m.deposit_amount != nil {
		fields = append(fields, order.FieldDepositAmount)
	}
	if m.original_amount != nil {
		fields = append(fields, order.FieldOriginalAmount)
	}
	if m.order_amount != nil {
		fields = append(fields, order.FieldOrderAmount)
	}
	if m.refunded_amount != nil {
		fields = append(fields, order.FieldRefundedAmount)
	}
	if m.coupon_amount != nil {
		fields = append(fields, order.FieldCouponAmount)
	}
	if m.order_state != nil {
		fields = append(fields, order.FieldOrderState)
	}
	if m.deposit_state != nil {
		fields = append(fields, order.FieldDepositState)
	}
	if m.emergency_state != nil {
		fields = append(fields, order.FieldEmergencyState)
	}
	if m.is_test_order != nil {
		fields = append(fields, order.FieldIsTestOrder)
	}
	if m.is_cancel != nil {
		fields = append(fields, order.FieldIsCancel)
	}
	if m.is_profit_sharing != nil {
		fields = append(fields, order.FieldIsProfitSharing)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	if m.user_score != nil {
		fields = append(fields, order.FieldUserScore)
	}
	if m.user_comment != nil {
		fields = append(fields, order.FieldUserComment)
	}
	if m.deposit_time != nil {
		fields = append(fields, order.FieldDepositTime)
	}
	if m.finish_time != nil {
		fields = append(fields, order.FieldFinishTime)
	}
	if m.create_time != nil {
		fields = append(fields, order.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, order.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldType:
		return m.GetType()
	case order.FieldPeriod:
		return m.Period()
	case order.FieldOrderNo:
		return m.OrderNo()
	case order.FieldWxTxID:
		return m.WxTxID()
	case order.FieldScenicAreaID:
		return m.ScenicAreaID()
	case order.FieldMchID:
		return m.MchID()
	case order.FieldScenicAreaName:
		return m.ScenicAreaName()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldOpenID:
		return m.OpenID()
	case order.FieldNickname:
		return m.Nickname()
	case order.FieldPhone:
		return m.Phone()
	case order.FieldCarID:
		return m.CarID()
	case order.FieldDeviceID:
		return m.DeviceID()
	case order.FieldCarName:
		return m.CarName()
	case order.FieldCarLicensePlate:
		return m.CarLicensePlate()
	case order.FieldModelID:
		return m.ModelID()
	case order.FieldModelName:
		return m.ModelName()
	case order.FieldCouponID:
		return m.CouponID()
	case order.FieldCouponName:
		return m.CouponName()
	case order.FieldUseMileageMeter:
		return m.UseMileageMeter()
	case order.FieldUseTimeSecond:
		return m.UseTimeSecond()
	case order.FieldDepositAmount:
		return m.DepositAmount()
	case order.FieldOriginalAmount:
		return m.OriginalAmount()
	case order.FieldOrderAmount:
		return m.OrderAmount()
	case order.FieldRefundedAmount:
		return m.RefundedAmount()
	case order.FieldCouponAmount:
		return m.CouponAmount()
	case order.FieldOrderState:
		return m.OrderState()
	case order.FieldDepositState:
		return m.DepositState()
	case order.FieldEmergencyState:
		return m.EmergencyState()
	case order.FieldIsTestOrder:
		return m.IsTestOrder()
	case order.FieldIsCancel:
		return m.IsCancel()
	case order.FieldIsProfitSharing:
		return m.IsProfitSharing()
	case order.FieldRemark:
		return m.Remark()
	case order.FieldUserScore:
		return m.UserScore()
	case order.FieldUserComment:
		return m.UserComment()
	case order.FieldDepositTime:
		return m.DepositTime()
	case order.FieldFinishTime:
		return m.FinishTime()
	case order.FieldCreateTime:
		return m.CreateTime()
	case order.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldPeriod:
		return m.OldPeriod(ctx)
	case order.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case order.FieldWxTxID:
		return m.OldWxTxID(ctx)
	case order.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case order.FieldMchID:
		return m.OldMchID(ctx)
	case order.FieldScenicAreaName:
		return m.OldScenicAreaName(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldOpenID:
		return m.OldOpenID(ctx)
	case order.FieldNickname:
		return m.OldNickname(ctx)
	case order.FieldPhone:
		return m.OldPhone(ctx)
	case order.FieldCarID:
		return m.OldCarID(ctx)
	case order.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case order.FieldCarName:
		return m.OldCarName(ctx)
	case order.FieldCarLicensePlate:
		return m.OldCarLicensePlate(ctx)
	case order.FieldModelID:
		return m.OldModelID(ctx)
	case order.FieldModelName:
		return m.OldModelName(ctx)
	case order.FieldCouponID:
		return m.OldCouponID(ctx)
	case order.FieldCouponName:
		return m.OldCouponName(ctx)
	case order.FieldUseMileageMeter:
		return m.OldUseMileageMeter(ctx)
	case order.FieldUseTimeSecond:
		return m.OldUseTimeSecond(ctx)
	case order.FieldDepositAmount:
		return m.OldDepositAmount(ctx)
	case order.FieldOriginalAmount:
		return m.OldOriginalAmount(ctx)
	case order.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case order.FieldRefundedAmount:
		return m.OldRefundedAmount(ctx)
	case order.FieldCouponAmount:
		return m.OldCouponAmount(ctx)
	case order.FieldOrderState:
		return m.OldOrderState(ctx)
	case order.FieldDepositState:
		return m.OldDepositState(ctx)
	case order.FieldEmergencyState:
		return m.OldEmergencyState(ctx)
	case order.FieldIsTestOrder:
		return m.OldIsTestOrder(ctx)
	case order.FieldIsCancel:
		return m.OldIsCancel(ctx)
	case order.FieldIsProfitSharing:
		return m.OldIsProfitSharing(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	case order.FieldUserScore:
		return m.OldUserScore(ctx)
	case order.FieldUserComment:
		return m.OldUserComment(ctx)
	case order.FieldDepositTime:
		return m.OldDepositTime(ctx)
	case order.FieldFinishTime:
		return m.OldFinishTime(ctx)
	case order.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case order.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case order.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case order.FieldWxTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxTxID(v)
		return nil
	case order.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case order.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case order.FieldScenicAreaName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaName(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case order.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case order.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case order.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case order.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case order.FieldCarName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarName(v)
		return nil
	case order.FieldCarLicensePlate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarLicensePlate(v)
		return nil
	case order.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case order.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case order.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case order.FieldCouponName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponName(v)
		return nil
	case order.FieldUseMileageMeter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseMileageMeter(v)
		return nil
	case order.FieldUseTimeSecond:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseTimeSecond(v)
		return nil
	case order.FieldDepositAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositAmount(v)
		return nil
	case order.FieldOriginalAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalAmount(v)
		return nil
	case order.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case order.FieldRefundedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundedAmount(v)
		return nil
	case order.FieldCouponAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponAmount(v)
		return nil
	case order.FieldOrderState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderState(v)
		return nil
	case order.FieldDepositState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositState(v)
		return nil
	case order.FieldEmergencyState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyState(v)
		return nil
	case order.FieldIsTestOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTestOrder(v)
		return nil
	case order.FieldIsCancel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCancel(v)
		return nil
	case order.FieldIsProfitSharing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsProfitSharing(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case order.FieldUserScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserScore(v)
		return nil
	case order.FieldUserComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserComment(v)
		return nil
	case order.FieldDepositTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositTime(v)
		return nil
	case order.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	case order.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case order.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.addperiod != nil {
		fields = append(fields, order.FieldPeriod)
	}
	if m.adduser_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.addmodel_id != nil {
		fields = append(fields, order.FieldModelID)
	}
	if m.addcoupon_id != nil {
		fields = append(fields, order.FieldCouponID)
	}
	if m.adduse_mileage_meter != nil {
		fields = append(fields, order.FieldUseMileageMeter)
	}
	if m.adduse_time_second != nil {
		fields = append(fields, order.FieldUseTimeSecond)
	}
	if m.adddeposit_amount != nil {
		fields = append(fields, order.FieldDepositAmount)
	}
	if m.addoriginal_amount != nil {
		fields = append(fields, order.FieldOriginalAmount)
	}
	if m.addorder_amount != nil {
		fields = append(fields, order.FieldOrderAmount)
	}
	if m.addrefunded_amount != nil {
		fields = append(fields, order.FieldRefundedAmount)
	}
	if m.addcoupon_amount != nil {
		fields = append(fields, order.FieldCouponAmount)
	}
	if m.addorder_state != nil {
		fields = append(fields, order.FieldOrderState)
	}
	if m.adddeposit_state != nil {
		fields = append(fields, order.FieldDepositState)
	}
	if m.addemergency_state != nil {
		fields = append(fields, order.FieldEmergencyState)
	}
	if m.adduser_score != nil {
		fields = append(fields, order.FieldUserScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldType:
		return m.AddedType()
	case order.FieldPeriod:
		return m.AddedPeriod()
	case order.FieldUserID:
		return m.AddedUserID()
	case order.FieldModelID:
		return m.AddedModelID()
	case order.FieldCouponID:
		return m.AddedCouponID()
	case order.FieldUseMileageMeter:
		return m.AddedUseMileageMeter()
	case order.FieldUseTimeSecond:
		return m.AddedUseTimeSecond()
	case order.FieldDepositAmount:
		return m.AddedDepositAmount()
	case order.FieldOriginalAmount:
		return m.AddedOriginalAmount()
	case order.FieldOrderAmount:
		return m.AddedOrderAmount()
	case order.FieldRefundedAmount:
		return m.AddedRefundedAmount()
	case order.FieldCouponAmount:
		return m.AddedCouponAmount()
	case order.FieldOrderState:
		return m.AddedOrderState()
	case order.FieldDepositState:
		return m.AddedDepositState()
	case order.FieldEmergencyState:
		return m.AddedEmergencyState()
	case order.FieldUserScore:
		return m.AddedUserScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case order.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case order.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case order.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponID(v)
		return nil
	case order.FieldUseMileageMeter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseMileageMeter(v)
		return nil
	case order.FieldUseTimeSecond:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUseTimeSecond(v)
		return nil
	case order.FieldDepositAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositAmount(v)
		return nil
	case order.FieldOriginalAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalAmount(v)
		return nil
	case order.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case order.FieldRefundedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundedAmount(v)
		return nil
	case order.FieldCouponAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponAmount(v)
		return nil
	case order.FieldOrderState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderState(v)
		return nil
	case order.FieldDepositState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositState(v)
		return nil
	case order.FieldEmergencyState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmergencyState(v)
		return nil
	case order.FieldUserScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserScore(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDepositTime) {
		fields = append(fields, order.FieldDepositTime)
	}
	if m.FieldCleared(order.FieldFinishTime) {
		fields = append(fields, order.FieldFinishTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDepositTime:
		m.ClearDepositTime()
		return nil
	case order.FieldFinishTime:
		m.ClearFinishTime()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldPeriod:
		m.ResetPeriod()
		return nil
	case order.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case order.FieldWxTxID:
		m.ResetWxTxID()
		return nil
	case order.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case order.FieldMchID:
		m.ResetMchID()
		return nil
	case order.FieldScenicAreaName:
		m.ResetScenicAreaName()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldOpenID:
		m.ResetOpenID()
		return nil
	case order.FieldNickname:
		m.ResetNickname()
		return nil
	case order.FieldPhone:
		m.ResetPhone()
		return nil
	case order.FieldCarID:
		m.ResetCarID()
		return nil
	case order.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case order.FieldCarName:
		m.ResetCarName()
		return nil
	case order.FieldCarLicensePlate:
		m.ResetCarLicensePlate()
		return nil
	case order.FieldModelID:
		m.ResetModelID()
		return nil
	case order.FieldModelName:
		m.ResetModelName()
		return nil
	case order.FieldCouponID:
		m.ResetCouponID()
		return nil
	case order.FieldCouponName:
		m.ResetCouponName()
		return nil
	case order.FieldUseMileageMeter:
		m.ResetUseMileageMeter()
		return nil
	case order.FieldUseTimeSecond:
		m.ResetUseTimeSecond()
		return nil
	case order.FieldDepositAmount:
		m.ResetDepositAmount()
		return nil
	case order.FieldOriginalAmount:
		m.ResetOriginalAmount()
		return nil
	case order.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case order.FieldRefundedAmount:
		m.ResetRefundedAmount()
		return nil
	case order.FieldCouponAmount:
		m.ResetCouponAmount()
		return nil
	case order.FieldOrderState:
		m.ResetOrderState()
		return nil
	case order.FieldDepositState:
		m.ResetDepositState()
		return nil
	case order.FieldEmergencyState:
		m.ResetEmergencyState()
		return nil
	case order.FieldIsTestOrder:
		m.ResetIsTestOrder()
		return nil
	case order.FieldIsCancel:
		m.ResetIsCancel()
		return nil
	case order.FieldIsProfitSharing:
		m.ResetIsProfitSharing()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	case order.FieldUserScore:
		m.ResetUserScore()
		return nil
	case order.FieldUserComment:
		m.ResetUserComment()
		return nil
	case order.FieldDepositTime:
		m.ResetDepositTime()
		return nil
	case order.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	case order.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case order.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.car != nil {
		edges = append(edges, order.EdgeCar)
	}
	if m.background_scenic_area != nil {
		edges = append(edges, order.EdgeBackgroundScenicArea)
	}
	if m.billing != nil {
		edges = append(edges, order.EdgeBilling)
	}
	if m.refund != nil {
		edges = append(edges, order.EdgeRefund)
	}
	if m.sharing != nil {
		edges = append(edges, order.EdgeSharing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeBilling:
		if id := m.billing; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeRefund:
		ids := make([]ent.Value, 0, len(m.refund))
		for id := range m.refund {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeSharing:
		if id := m.sharing; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrefund != nil {
		edges = append(edges, order.EdgeRefund)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeRefund:
		ids := make([]ent.Value, 0, len(m.removedrefund))
		for id := range m.removedrefund {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcar {
		edges = append(edges, order.EdgeCar)
	}
	if m.clearedbackground_scenic_area {
		edges = append(edges, order.EdgeBackgroundScenicArea)
	}
	if m.clearedbilling {
		edges = append(edges, order.EdgeBilling)
	}
	if m.clearedrefund {
		edges = append(edges, order.EdgeRefund)
	}
	if m.clearedsharing {
		edges = append(edges, order.EdgeSharing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeCar:
		return m.clearedcar
	case order.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	case order.EdgeBilling:
		return m.clearedbilling
	case order.EdgeRefund:
		return m.clearedrefund
	case order.EdgeSharing:
		return m.clearedsharing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeCar:
		m.ClearCar()
		return nil
	case order.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	case order.EdgeBilling:
		m.ClearBilling()
		return nil
	case order.EdgeSharing:
		m.ClearSharing()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeCar:
		m.ResetCar()
		return nil
	case order.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	case order.EdgeBilling:
		m.ResetBilling()
		return nil
	case order.EdgeRefund:
		m.ResetRefund()
		return nil
	case order.EdgeSharing:
		m.ResetSharing()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderAppealMutation represents an operation that mutates the OrderAppeal nodes in the graph.
type OrderAppealMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	scenic_area_id       *int
	addscenic_area_id    *int
	user_id              *int
	adduser_id           *int
	order_id             *int
	addorder_id          *int
	order_no             *string
	_type                *int
	add_type             *int
	end_stop_id          *int
	addend_stop_id       *int
	end_stop_image_id    *int
	addend_stop_image_id *int
	state                *int
	addstate             *int
	refund_amount        *int
	addrefund_amount     *int
	user_comment         *string
	review_comment       *string
	refund_time          *time.Time
	review_time          *time.Time
	create_time          *time.Time
	update_time          *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*OrderAppeal, error)
	predicates           []predicate.OrderAppeal
}

var _ ent.Mutation = (*OrderAppealMutation)(nil)

// orderappealOption allows management of the mutation configuration using functional options.
type orderappealOption func(*OrderAppealMutation)

// newOrderAppealMutation creates new mutation for the OrderAppeal entity.
func newOrderAppealMutation(c config, op Op, opts ...orderappealOption) *OrderAppealMutation {
	m := &OrderAppealMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAppeal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAppealID sets the ID field of the mutation.
func withOrderAppealID(id int) orderappealOption {
	return func(m *OrderAppealMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAppeal
		)
		m.oldValue = func(ctx context.Context) (*OrderAppeal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAppeal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAppeal sets the old OrderAppeal of the mutation.
func withOrderAppeal(node *OrderAppeal) orderappealOption {
	return func(m *OrderAppealMutation) {
		m.oldValue = func(context.Context) (*OrderAppeal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAppealMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAppealMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderAppeal entities.
func (m *OrderAppealMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAppealMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderAppealMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderAppeal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *OrderAppealMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *OrderAppealMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *OrderAppealMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *OrderAppealMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *OrderAppealMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderAppealMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderAppealMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderAppealMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderAppealMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderAppealMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderAppealMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderAppealMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *OrderAppealMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderAppealMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderAppealMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetOrderNo sets the "order_no" field.
func (m *OrderAppealMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderAppealMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderAppealMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetType sets the "type" field.
func (m *OrderAppealMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderAppealMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderAppealMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderAppealMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderAppealMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetEndStopID sets the "end_stop_id" field.
func (m *OrderAppealMutation) SetEndStopID(i int) {
	m.end_stop_id = &i
	m.addend_stop_id = nil
}

// EndStopID returns the value of the "end_stop_id" field in the mutation.
func (m *OrderAppealMutation) EndStopID() (r int, exists bool) {
	v := m.end_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStopID returns the old "end_stop_id" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldEndStopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStopID: %w", err)
	}
	return oldValue.EndStopID, nil
}

// AddEndStopID adds i to the "end_stop_id" field.
func (m *OrderAppealMutation) AddEndStopID(i int) {
	if m.addend_stop_id != nil {
		*m.addend_stop_id += i
	} else {
		m.addend_stop_id = &i
	}
}

// AddedEndStopID returns the value that was added to the "end_stop_id" field in this mutation.
func (m *OrderAppealMutation) AddedEndStopID() (r int, exists bool) {
	v := m.addend_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndStopID resets all changes to the "end_stop_id" field.
func (m *OrderAppealMutation) ResetEndStopID() {
	m.end_stop_id = nil
	m.addend_stop_id = nil
}

// SetEndStopImageID sets the "end_stop_image_id" field.
func (m *OrderAppealMutation) SetEndStopImageID(i int) {
	m.end_stop_image_id = &i
	m.addend_stop_image_id = nil
}

// EndStopImageID returns the value of the "end_stop_image_id" field in the mutation.
func (m *OrderAppealMutation) EndStopImageID() (r int, exists bool) {
	v := m.end_stop_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStopImageID returns the old "end_stop_image_id" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldEndStopImageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStopImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStopImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStopImageID: %w", err)
	}
	return oldValue.EndStopImageID, nil
}

// AddEndStopImageID adds i to the "end_stop_image_id" field.
func (m *OrderAppealMutation) AddEndStopImageID(i int) {
	if m.addend_stop_image_id != nil {
		*m.addend_stop_image_id += i
	} else {
		m.addend_stop_image_id = &i
	}
}

// AddedEndStopImageID returns the value that was added to the "end_stop_image_id" field in this mutation.
func (m *OrderAppealMutation) AddedEndStopImageID() (r int, exists bool) {
	v := m.addend_stop_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndStopImageID resets all changes to the "end_stop_image_id" field.
func (m *OrderAppealMutation) ResetEndStopImageID() {
	m.end_stop_image_id = nil
	m.addend_stop_image_id = nil
}

// SetState sets the "state" field.
func (m *OrderAppealMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OrderAppealMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OrderAppealMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OrderAppealMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OrderAppealMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetRefundAmount sets the "refund_amount" field.
func (m *OrderAppealMutation) SetRefundAmount(i int) {
	m.refund_amount = &i
	m.addrefund_amount = nil
}

// RefundAmount returns the value of the "refund_amount" field in the mutation.
func (m *OrderAppealMutation) RefundAmount() (r int, exists bool) {
	v := m.refund_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAmount returns the old "refund_amount" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldRefundAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAmount: %w", err)
	}
	return oldValue.RefundAmount, nil
}

// AddRefundAmount adds i to the "refund_amount" field.
func (m *OrderAppealMutation) AddRefundAmount(i int) {
	if m.addrefund_amount != nil {
		*m.addrefund_amount += i
	} else {
		m.addrefund_amount = &i
	}
}

// AddedRefundAmount returns the value that was added to the "refund_amount" field in this mutation.
func (m *OrderAppealMutation) AddedRefundAmount() (r int, exists bool) {
	v := m.addrefund_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefundAmount resets all changes to the "refund_amount" field.
func (m *OrderAppealMutation) ResetRefundAmount() {
	m.refund_amount = nil
	m.addrefund_amount = nil
}

// SetUserComment sets the "user_comment" field.
func (m *OrderAppealMutation) SetUserComment(s string) {
	m.user_comment = &s
}

// UserComment returns the value of the "user_comment" field in the mutation.
func (m *OrderAppealMutation) UserComment() (r string, exists bool) {
	v := m.user_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldUserComment returns the old "user_comment" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldUserComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserComment: %w", err)
	}
	return oldValue.UserComment, nil
}

// ResetUserComment resets all changes to the "user_comment" field.
func (m *OrderAppealMutation) ResetUserComment() {
	m.user_comment = nil
}

// SetReviewComment sets the "review_comment" field.
func (m *OrderAppealMutation) SetReviewComment(s string) {
	m.review_comment = &s
}

// ReviewComment returns the value of the "review_comment" field in the mutation.
func (m *OrderAppealMutation) ReviewComment() (r string, exists bool) {
	v := m.review_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewComment returns the old "review_comment" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldReviewComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewComment: %w", err)
	}
	return oldValue.ReviewComment, nil
}

// ResetReviewComment resets all changes to the "review_comment" field.
func (m *OrderAppealMutation) ResetReviewComment() {
	m.review_comment = nil
}

// SetRefundTime sets the "refund_time" field.
func (m *OrderAppealMutation) SetRefundTime(t time.Time) {
	m.refund_time = &t
}

// RefundTime returns the value of the "refund_time" field in the mutation.
func (m *OrderAppealMutation) RefundTime() (r time.Time, exists bool) {
	v := m.refund_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundTime returns the old "refund_time" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldRefundTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundTime: %w", err)
	}
	return oldValue.RefundTime, nil
}

// ClearRefundTime clears the value of the "refund_time" field.
func (m *OrderAppealMutation) ClearRefundTime() {
	m.refund_time = nil
	m.clearedFields[orderappeal.FieldRefundTime] = struct{}{}
}

// RefundTimeCleared returns if the "refund_time" field was cleared in this mutation.
func (m *OrderAppealMutation) RefundTimeCleared() bool {
	_, ok := m.clearedFields[orderappeal.FieldRefundTime]
	return ok
}

// ResetRefundTime resets all changes to the "refund_time" field.
func (m *OrderAppealMutation) ResetRefundTime() {
	m.refund_time = nil
	delete(m.clearedFields, orderappeal.FieldRefundTime)
}

// SetReviewTime sets the "review_time" field.
func (m *OrderAppealMutation) SetReviewTime(t time.Time) {
	m.review_time = &t
}

// ReviewTime returns the value of the "review_time" field in the mutation.
func (m *OrderAppealMutation) ReviewTime() (r time.Time, exists bool) {
	v := m.review_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewTime returns the old "review_time" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldReviewTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewTime: %w", err)
	}
	return oldValue.ReviewTime, nil
}

// ClearReviewTime clears the value of the "review_time" field.
func (m *OrderAppealMutation) ClearReviewTime() {
	m.review_time = nil
	m.clearedFields[orderappeal.FieldReviewTime] = struct{}{}
}

// ReviewTimeCleared returns if the "review_time" field was cleared in this mutation.
func (m *OrderAppealMutation) ReviewTimeCleared() bool {
	_, ok := m.clearedFields[orderappeal.FieldReviewTime]
	return ok
}

// ResetReviewTime resets all changes to the "review_time" field.
func (m *OrderAppealMutation) ResetReviewTime() {
	m.review_time = nil
	delete(m.clearedFields, orderappeal.FieldReviewTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrderAppealMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderAppealMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderAppealMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderAppealMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderAppealMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderAppeal entity.
// If the OrderAppeal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAppealMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderAppealMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrderAppealMutation builder.
func (m *OrderAppealMutation) Where(ps ...predicate.OrderAppeal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderAppealMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderAppealMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderAppeal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderAppealMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderAppealMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderAppeal).
func (m *OrderAppealMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAppealMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.scenic_area_id != nil {
		fields = append(fields, orderappeal.FieldScenicAreaID)
	}
	if m.user_id != nil {
		fields = append(fields, orderappeal.FieldUserID)
	}
	if m.order_id != nil {
		fields = append(fields, orderappeal.FieldOrderID)
	}
	if m.order_no != nil {
		fields = append(fields, orderappeal.FieldOrderNo)
	}
	if m._type != nil {
		fields = append(fields, orderappeal.FieldType)
	}
	if m.end_stop_id != nil {
		fields = append(fields, orderappeal.FieldEndStopID)
	}
	if m.end_stop_image_id != nil {
		fields = append(fields, orderappeal.FieldEndStopImageID)
	}
	if m.state != nil {
		fields = append(fields, orderappeal.FieldState)
	}
	if m.refund_amount != nil {
		fields = append(fields, orderappeal.FieldRefundAmount)
	}
	if m.user_comment != nil {
		fields = append(fields, orderappeal.FieldUserComment)
	}
	if m.review_comment != nil {
		fields = append(fields, orderappeal.FieldReviewComment)
	}
	if m.refund_time != nil {
		fields = append(fields, orderappeal.FieldRefundTime)
	}
	if m.review_time != nil {
		fields = append(fields, orderappeal.FieldReviewTime)
	}
	if m.create_time != nil {
		fields = append(fields, orderappeal.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderappeal.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAppealMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderappeal.FieldScenicAreaID:
		return m.ScenicAreaID()
	case orderappeal.FieldUserID:
		return m.UserID()
	case orderappeal.FieldOrderID:
		return m.OrderID()
	case orderappeal.FieldOrderNo:
		return m.OrderNo()
	case orderappeal.FieldType:
		return m.GetType()
	case orderappeal.FieldEndStopID:
		return m.EndStopID()
	case orderappeal.FieldEndStopImageID:
		return m.EndStopImageID()
	case orderappeal.FieldState:
		return m.State()
	case orderappeal.FieldRefundAmount:
		return m.RefundAmount()
	case orderappeal.FieldUserComment:
		return m.UserComment()
	case orderappeal.FieldReviewComment:
		return m.ReviewComment()
	case orderappeal.FieldRefundTime:
		return m.RefundTime()
	case orderappeal.FieldReviewTime:
		return m.ReviewTime()
	case orderappeal.FieldCreateTime:
		return m.CreateTime()
	case orderappeal.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAppealMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderappeal.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case orderappeal.FieldUserID:
		return m.OldUserID(ctx)
	case orderappeal.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderappeal.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case orderappeal.FieldType:
		return m.OldType(ctx)
	case orderappeal.FieldEndStopID:
		return m.OldEndStopID(ctx)
	case orderappeal.FieldEndStopImageID:
		return m.OldEndStopImageID(ctx)
	case orderappeal.FieldState:
		return m.OldState(ctx)
	case orderappeal.FieldRefundAmount:
		return m.OldRefundAmount(ctx)
	case orderappeal.FieldUserComment:
		return m.OldUserComment(ctx)
	case orderappeal.FieldReviewComment:
		return m.OldReviewComment(ctx)
	case orderappeal.FieldRefundTime:
		return m.OldRefundTime(ctx)
	case orderappeal.FieldReviewTime:
		return m.OldReviewTime(ctx)
	case orderappeal.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderappeal.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAppeal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAppealMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderappeal.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case orderappeal.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderappeal.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderappeal.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case orderappeal.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderappeal.FieldEndStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStopID(v)
		return nil
	case orderappeal.FieldEndStopImageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStopImageID(v)
		return nil
	case orderappeal.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case orderappeal.FieldRefundAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAmount(v)
		return nil
	case orderappeal.FieldUserComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserComment(v)
		return nil
	case orderappeal.FieldReviewComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewComment(v)
		return nil
	case orderappeal.FieldRefundTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundTime(v)
		return nil
	case orderappeal.FieldReviewTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewTime(v)
		return nil
	case orderappeal.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderappeal.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAppeal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAppealMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, orderappeal.FieldScenicAreaID)
	}
	if m.adduser_id != nil {
		fields = append(fields, orderappeal.FieldUserID)
	}
	if m.addorder_id != nil {
		fields = append(fields, orderappeal.FieldOrderID)
	}
	if m.add_type != nil {
		fields = append(fields, orderappeal.FieldType)
	}
	if m.addend_stop_id != nil {
		fields = append(fields, orderappeal.FieldEndStopID)
	}
	if m.addend_stop_image_id != nil {
		fields = append(fields, orderappeal.FieldEndStopImageID)
	}
	if m.addstate != nil {
		fields = append(fields, orderappeal.FieldState)
	}
	if m.addrefund_amount != nil {
		fields = append(fields, orderappeal.FieldRefundAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAppealMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderappeal.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case orderappeal.FieldUserID:
		return m.AddedUserID()
	case orderappeal.FieldOrderID:
		return m.AddedOrderID()
	case orderappeal.FieldType:
		return m.AddedType()
	case orderappeal.FieldEndStopID:
		return m.AddedEndStopID()
	case orderappeal.FieldEndStopImageID:
		return m.AddedEndStopImageID()
	case orderappeal.FieldState:
		return m.AddedState()
	case orderappeal.FieldRefundAmount:
		return m.AddedRefundAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAppealMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderappeal.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case orderappeal.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orderappeal.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderappeal.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case orderappeal.FieldEndStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndStopID(v)
		return nil
	case orderappeal.FieldEndStopImageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndStopImageID(v)
		return nil
	case orderappeal.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case orderappeal.FieldRefundAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAppeal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAppealMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderappeal.FieldRefundTime) {
		fields = append(fields, orderappeal.FieldRefundTime)
	}
	if m.FieldCleared(orderappeal.FieldReviewTime) {
		fields = append(fields, orderappeal.FieldReviewTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAppealMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAppealMutation) ClearField(name string) error {
	switch name {
	case orderappeal.FieldRefundTime:
		m.ClearRefundTime()
		return nil
	case orderappeal.FieldReviewTime:
		m.ClearReviewTime()
		return nil
	}
	return fmt.Errorf("unknown OrderAppeal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAppealMutation) ResetField(name string) error {
	switch name {
	case orderappeal.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case orderappeal.FieldUserID:
		m.ResetUserID()
		return nil
	case orderappeal.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderappeal.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case orderappeal.FieldType:
		m.ResetType()
		return nil
	case orderappeal.FieldEndStopID:
		m.ResetEndStopID()
		return nil
	case orderappeal.FieldEndStopImageID:
		m.ResetEndStopImageID()
		return nil
	case orderappeal.FieldState:
		m.ResetState()
		return nil
	case orderappeal.FieldRefundAmount:
		m.ResetRefundAmount()
		return nil
	case orderappeal.FieldUserComment:
		m.ResetUserComment()
		return nil
	case orderappeal.FieldReviewComment:
		m.ResetReviewComment()
		return nil
	case orderappeal.FieldRefundTime:
		m.ResetRefundTime()
		return nil
	case orderappeal.FieldReviewTime:
		m.ResetReviewTime()
		return nil
	case orderappeal.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderappeal.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderAppeal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAppealMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAppealMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAppealMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAppealMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAppealMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAppealMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAppealMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderAppeal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAppealMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderAppeal edge %s", name)
}

// OrderBillingMutation represents an operation that mutates the OrderBilling nodes in the graph.
type OrderBillingMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_type                      *int
	add_type                   *int
	start_time_price           *int
	addstart_time_price        *int
	start_time_unit            *int
	addstart_time_unit         *int
	normal_time_price          *int
	addnormal_time_price       *int
	normal_time_unit           *int
	addnormal_time_unit        *int
	cumulative_second          *float64
	addcumulative_second       *float64
	cumulative_meter           *float64
	addcumulative_meter        *float64
	ticket_count               *int
	addticket_count            *int
	cumulative_stop            *int
	addcumulative_stop         *int
	start_stop_price           *int
	addstart_stop_price        *int
	start_stop_unit            *int
	addstart_stop_unit         *int
	normal_stop_price          *int
	addnormal_stop_price       *int
	normal_stop_unit           *int
	addnormal_stop_unit        *int
	coupon_id                  *int
	addcoupon_id               *int
	coupon_limit_amount        *int
	addcoupon_limit_amount     *int
	coupon_deduction_amount    *int
	addcoupon_deduction_amount *int
	capped_amount              *int
	addcapped_amount           *int
	state                      *int
	addstate                   *int
	start_time                 *time.Time
	finish_time                *time.Time
	create_time                *time.Time
	update_time                *time.Time
	clearedFields              map[string]struct{}
	_order                     *int
	cleared_order              bool
	done                       bool
	oldValue                   func(context.Context) (*OrderBilling, error)
	predicates                 []predicate.OrderBilling
}

var _ ent.Mutation = (*OrderBillingMutation)(nil)

// orderbillingOption allows management of the mutation configuration using functional options.
type orderbillingOption func(*OrderBillingMutation)

// newOrderBillingMutation creates new mutation for the OrderBilling entity.
func newOrderBillingMutation(c config, op Op, opts ...orderbillingOption) *OrderBillingMutation {
	m := &OrderBillingMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderBilling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderBillingID sets the ID field of the mutation.
func withOrderBillingID(id int) orderbillingOption {
	return func(m *OrderBillingMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderBilling
		)
		m.oldValue = func(ctx context.Context) (*OrderBilling, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderBilling.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderBilling sets the old OrderBilling of the mutation.
func withOrderBilling(node *OrderBilling) orderbillingOption {
	return func(m *OrderBillingMutation) {
		m.oldValue = func(context.Context) (*OrderBilling, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderBillingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderBillingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderBilling entities.
func (m *OrderBillingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderBillingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderBillingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderBilling.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *OrderBillingMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderBillingMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderBillingMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderBillingMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderBillingMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderBillingMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderBillingMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderBillingMutation) ResetOrderID() {
	m._order = nil
}

// SetStartTimePrice sets the "start_time_price" field.
func (m *OrderBillingMutation) SetStartTimePrice(i int) {
	m.start_time_price = &i
	m.addstart_time_price = nil
}

// StartTimePrice returns the value of the "start_time_price" field in the mutation.
func (m *OrderBillingMutation) StartTimePrice() (r int, exists bool) {
	v := m.start_time_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimePrice returns the old "start_time_price" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldStartTimePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimePrice: %w", err)
	}
	return oldValue.StartTimePrice, nil
}

// AddStartTimePrice adds i to the "start_time_price" field.
func (m *OrderBillingMutation) AddStartTimePrice(i int) {
	if m.addstart_time_price != nil {
		*m.addstart_time_price += i
	} else {
		m.addstart_time_price = &i
	}
}

// AddedStartTimePrice returns the value that was added to the "start_time_price" field in this mutation.
func (m *OrderBillingMutation) AddedStartTimePrice() (r int, exists bool) {
	v := m.addstart_time_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTimePrice resets all changes to the "start_time_price" field.
func (m *OrderBillingMutation) ResetStartTimePrice() {
	m.start_time_price = nil
	m.addstart_time_price = nil
}

// SetStartTimeUnit sets the "start_time_unit" field.
func (m *OrderBillingMutation) SetStartTimeUnit(i int) {
	m.start_time_unit = &i
	m.addstart_time_unit = nil
}

// StartTimeUnit returns the value of the "start_time_unit" field in the mutation.
func (m *OrderBillingMutation) StartTimeUnit() (r int, exists bool) {
	v := m.start_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTimeUnit returns the old "start_time_unit" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldStartTimeUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTimeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTimeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTimeUnit: %w", err)
	}
	return oldValue.StartTimeUnit, nil
}

// AddStartTimeUnit adds i to the "start_time_unit" field.
func (m *OrderBillingMutation) AddStartTimeUnit(i int) {
	if m.addstart_time_unit != nil {
		*m.addstart_time_unit += i
	} else {
		m.addstart_time_unit = &i
	}
}

// AddedStartTimeUnit returns the value that was added to the "start_time_unit" field in this mutation.
func (m *OrderBillingMutation) AddedStartTimeUnit() (r int, exists bool) {
	v := m.addstart_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTimeUnit resets all changes to the "start_time_unit" field.
func (m *OrderBillingMutation) ResetStartTimeUnit() {
	m.start_time_unit = nil
	m.addstart_time_unit = nil
}

// SetNormalTimePrice sets the "normal_time_price" field.
func (m *OrderBillingMutation) SetNormalTimePrice(i int) {
	m.normal_time_price = &i
	m.addnormal_time_price = nil
}

// NormalTimePrice returns the value of the "normal_time_price" field in the mutation.
func (m *OrderBillingMutation) NormalTimePrice() (r int, exists bool) {
	v := m.normal_time_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTimePrice returns the old "normal_time_price" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldNormalTimePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTimePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTimePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTimePrice: %w", err)
	}
	return oldValue.NormalTimePrice, nil
}

// AddNormalTimePrice adds i to the "normal_time_price" field.
func (m *OrderBillingMutation) AddNormalTimePrice(i int) {
	if m.addnormal_time_price != nil {
		*m.addnormal_time_price += i
	} else {
		m.addnormal_time_price = &i
	}
}

// AddedNormalTimePrice returns the value that was added to the "normal_time_price" field in this mutation.
func (m *OrderBillingMutation) AddedNormalTimePrice() (r int, exists bool) {
	v := m.addnormal_time_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTimePrice resets all changes to the "normal_time_price" field.
func (m *OrderBillingMutation) ResetNormalTimePrice() {
	m.normal_time_price = nil
	m.addnormal_time_price = nil
}

// SetNormalTimeUnit sets the "normal_time_unit" field.
func (m *OrderBillingMutation) SetNormalTimeUnit(i int) {
	m.normal_time_unit = &i
	m.addnormal_time_unit = nil
}

// NormalTimeUnit returns the value of the "normal_time_unit" field in the mutation.
func (m *OrderBillingMutation) NormalTimeUnit() (r int, exists bool) {
	v := m.normal_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalTimeUnit returns the old "normal_time_unit" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldNormalTimeUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalTimeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalTimeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalTimeUnit: %w", err)
	}
	return oldValue.NormalTimeUnit, nil
}

// AddNormalTimeUnit adds i to the "normal_time_unit" field.
func (m *OrderBillingMutation) AddNormalTimeUnit(i int) {
	if m.addnormal_time_unit != nil {
		*m.addnormal_time_unit += i
	} else {
		m.addnormal_time_unit = &i
	}
}

// AddedNormalTimeUnit returns the value that was added to the "normal_time_unit" field in this mutation.
func (m *OrderBillingMutation) AddedNormalTimeUnit() (r int, exists bool) {
	v := m.addnormal_time_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalTimeUnit resets all changes to the "normal_time_unit" field.
func (m *OrderBillingMutation) ResetNormalTimeUnit() {
	m.normal_time_unit = nil
	m.addnormal_time_unit = nil
}

// SetCumulativeSecond sets the "cumulative_second" field.
func (m *OrderBillingMutation) SetCumulativeSecond(f float64) {
	m.cumulative_second = &f
	m.addcumulative_second = nil
}

// CumulativeSecond returns the value of the "cumulative_second" field in the mutation.
func (m *OrderBillingMutation) CumulativeSecond() (r float64, exists bool) {
	v := m.cumulative_second
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeSecond returns the old "cumulative_second" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCumulativeSecond(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeSecond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeSecond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeSecond: %w", err)
	}
	return oldValue.CumulativeSecond, nil
}

// AddCumulativeSecond adds f to the "cumulative_second" field.
func (m *OrderBillingMutation) AddCumulativeSecond(f float64) {
	if m.addcumulative_second != nil {
		*m.addcumulative_second += f
	} else {
		m.addcumulative_second = &f
	}
}

// AddedCumulativeSecond returns the value that was added to the "cumulative_second" field in this mutation.
func (m *OrderBillingMutation) AddedCumulativeSecond() (r float64, exists bool) {
	v := m.addcumulative_second
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeSecond resets all changes to the "cumulative_second" field.
func (m *OrderBillingMutation) ResetCumulativeSecond() {
	m.cumulative_second = nil
	m.addcumulative_second = nil
}

// SetCumulativeMeter sets the "cumulative_meter" field.
func (m *OrderBillingMutation) SetCumulativeMeter(f float64) {
	m.cumulative_meter = &f
	m.addcumulative_meter = nil
}

// CumulativeMeter returns the value of the "cumulative_meter" field in the mutation.
func (m *OrderBillingMutation) CumulativeMeter() (r float64, exists bool) {
	v := m.cumulative_meter
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMeter returns the old "cumulative_meter" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCumulativeMeter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMeter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMeter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMeter: %w", err)
	}
	return oldValue.CumulativeMeter, nil
}

// AddCumulativeMeter adds f to the "cumulative_meter" field.
func (m *OrderBillingMutation) AddCumulativeMeter(f float64) {
	if m.addcumulative_meter != nil {
		*m.addcumulative_meter += f
	} else {
		m.addcumulative_meter = &f
	}
}

// AddedCumulativeMeter returns the value that was added to the "cumulative_meter" field in this mutation.
func (m *OrderBillingMutation) AddedCumulativeMeter() (r float64, exists bool) {
	v := m.addcumulative_meter
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMeter resets all changes to the "cumulative_meter" field.
func (m *OrderBillingMutation) ResetCumulativeMeter() {
	m.cumulative_meter = nil
	m.addcumulative_meter = nil
}

// SetTicketCount sets the "ticket_count" field.
func (m *OrderBillingMutation) SetTicketCount(i int) {
	m.ticket_count = &i
	m.addticket_count = nil
}

// TicketCount returns the value of the "ticket_count" field in the mutation.
func (m *OrderBillingMutation) TicketCount() (r int, exists bool) {
	v := m.ticket_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketCount returns the old "ticket_count" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldTicketCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketCount: %w", err)
	}
	return oldValue.TicketCount, nil
}

// AddTicketCount adds i to the "ticket_count" field.
func (m *OrderBillingMutation) AddTicketCount(i int) {
	if m.addticket_count != nil {
		*m.addticket_count += i
	} else {
		m.addticket_count = &i
	}
}

// AddedTicketCount returns the value that was added to the "ticket_count" field in this mutation.
func (m *OrderBillingMutation) AddedTicketCount() (r int, exists bool) {
	v := m.addticket_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTicketCount resets all changes to the "ticket_count" field.
func (m *OrderBillingMutation) ResetTicketCount() {
	m.ticket_count = nil
	m.addticket_count = nil
}

// SetCumulativeStop sets the "cumulative_stop" field.
func (m *OrderBillingMutation) SetCumulativeStop(i int) {
	m.cumulative_stop = &i
	m.addcumulative_stop = nil
}

// CumulativeStop returns the value of the "cumulative_stop" field in the mutation.
func (m *OrderBillingMutation) CumulativeStop() (r int, exists bool) {
	v := m.cumulative_stop
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeStop returns the old "cumulative_stop" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCumulativeStop(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeStop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeStop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeStop: %w", err)
	}
	return oldValue.CumulativeStop, nil
}

// AddCumulativeStop adds i to the "cumulative_stop" field.
func (m *OrderBillingMutation) AddCumulativeStop(i int) {
	if m.addcumulative_stop != nil {
		*m.addcumulative_stop += i
	} else {
		m.addcumulative_stop = &i
	}
}

// AddedCumulativeStop returns the value that was added to the "cumulative_stop" field in this mutation.
func (m *OrderBillingMutation) AddedCumulativeStop() (r int, exists bool) {
	v := m.addcumulative_stop
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeStop resets all changes to the "cumulative_stop" field.
func (m *OrderBillingMutation) ResetCumulativeStop() {
	m.cumulative_stop = nil
	m.addcumulative_stop = nil
}

// SetStartStopPrice sets the "start_stop_price" field.
func (m *OrderBillingMutation) SetStartStopPrice(i int) {
	m.start_stop_price = &i
	m.addstart_stop_price = nil
}

// StartStopPrice returns the value of the "start_stop_price" field in the mutation.
func (m *OrderBillingMutation) StartStopPrice() (r int, exists bool) {
	v := m.start_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStopPrice returns the old "start_stop_price" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldStartStopPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStopPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStopPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStopPrice: %w", err)
	}
	return oldValue.StartStopPrice, nil
}

// AddStartStopPrice adds i to the "start_stop_price" field.
func (m *OrderBillingMutation) AddStartStopPrice(i int) {
	if m.addstart_stop_price != nil {
		*m.addstart_stop_price += i
	} else {
		m.addstart_stop_price = &i
	}
}

// AddedStartStopPrice returns the value that was added to the "start_stop_price" field in this mutation.
func (m *OrderBillingMutation) AddedStartStopPrice() (r int, exists bool) {
	v := m.addstart_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartStopPrice resets all changes to the "start_stop_price" field.
func (m *OrderBillingMutation) ResetStartStopPrice() {
	m.start_stop_price = nil
	m.addstart_stop_price = nil
}

// SetStartStopUnit sets the "start_stop_unit" field.
func (m *OrderBillingMutation) SetStartStopUnit(i int) {
	m.start_stop_unit = &i
	m.addstart_stop_unit = nil
}

// StartStopUnit returns the value of the "start_stop_unit" field in the mutation.
func (m *OrderBillingMutation) StartStopUnit() (r int, exists bool) {
	v := m.start_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStopUnit returns the old "start_stop_unit" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldStartStopUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStopUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStopUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStopUnit: %w", err)
	}
	return oldValue.StartStopUnit, nil
}

// AddStartStopUnit adds i to the "start_stop_unit" field.
func (m *OrderBillingMutation) AddStartStopUnit(i int) {
	if m.addstart_stop_unit != nil {
		*m.addstart_stop_unit += i
	} else {
		m.addstart_stop_unit = &i
	}
}

// AddedStartStopUnit returns the value that was added to the "start_stop_unit" field in this mutation.
func (m *OrderBillingMutation) AddedStartStopUnit() (r int, exists bool) {
	v := m.addstart_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartStopUnit resets all changes to the "start_stop_unit" field.
func (m *OrderBillingMutation) ResetStartStopUnit() {
	m.start_stop_unit = nil
	m.addstart_stop_unit = nil
}

// SetNormalStopPrice sets the "normal_stop_price" field.
func (m *OrderBillingMutation) SetNormalStopPrice(i int) {
	m.normal_stop_price = &i
	m.addnormal_stop_price = nil
}

// NormalStopPrice returns the value of the "normal_stop_price" field in the mutation.
func (m *OrderBillingMutation) NormalStopPrice() (r int, exists bool) {
	v := m.normal_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalStopPrice returns the old "normal_stop_price" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldNormalStopPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalStopPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalStopPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalStopPrice: %w", err)
	}
	return oldValue.NormalStopPrice, nil
}

// AddNormalStopPrice adds i to the "normal_stop_price" field.
func (m *OrderBillingMutation) AddNormalStopPrice(i int) {
	if m.addnormal_stop_price != nil {
		*m.addnormal_stop_price += i
	} else {
		m.addnormal_stop_price = &i
	}
}

// AddedNormalStopPrice returns the value that was added to the "normal_stop_price" field in this mutation.
func (m *OrderBillingMutation) AddedNormalStopPrice() (r int, exists bool) {
	v := m.addnormal_stop_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalStopPrice resets all changes to the "normal_stop_price" field.
func (m *OrderBillingMutation) ResetNormalStopPrice() {
	m.normal_stop_price = nil
	m.addnormal_stop_price = nil
}

// SetNormalStopUnit sets the "normal_stop_unit" field.
func (m *OrderBillingMutation) SetNormalStopUnit(i int) {
	m.normal_stop_unit = &i
	m.addnormal_stop_unit = nil
}

// NormalStopUnit returns the value of the "normal_stop_unit" field in the mutation.
func (m *OrderBillingMutation) NormalStopUnit() (r int, exists bool) {
	v := m.normal_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalStopUnit returns the old "normal_stop_unit" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldNormalStopUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalStopUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalStopUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalStopUnit: %w", err)
	}
	return oldValue.NormalStopUnit, nil
}

// AddNormalStopUnit adds i to the "normal_stop_unit" field.
func (m *OrderBillingMutation) AddNormalStopUnit(i int) {
	if m.addnormal_stop_unit != nil {
		*m.addnormal_stop_unit += i
	} else {
		m.addnormal_stop_unit = &i
	}
}

// AddedNormalStopUnit returns the value that was added to the "normal_stop_unit" field in this mutation.
func (m *OrderBillingMutation) AddedNormalStopUnit() (r int, exists bool) {
	v := m.addnormal_stop_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalStopUnit resets all changes to the "normal_stop_unit" field.
func (m *OrderBillingMutation) ResetNormalStopUnit() {
	m.normal_stop_unit = nil
	m.addnormal_stop_unit = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *OrderBillingMutation) SetCouponID(i int) {
	m.coupon_id = &i
	m.addcoupon_id = nil
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *OrderBillingMutation) CouponID() (r int, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCouponID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// AddCouponID adds i to the "coupon_id" field.
func (m *OrderBillingMutation) AddCouponID(i int) {
	if m.addcoupon_id != nil {
		*m.addcoupon_id += i
	} else {
		m.addcoupon_id = &i
	}
}

// AddedCouponID returns the value that was added to the "coupon_id" field in this mutation.
func (m *OrderBillingMutation) AddedCouponID() (r int, exists bool) {
	v := m.addcoupon_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *OrderBillingMutation) ResetCouponID() {
	m.coupon_id = nil
	m.addcoupon_id = nil
}

// SetCouponLimitAmount sets the "coupon_limit_amount" field.
func (m *OrderBillingMutation) SetCouponLimitAmount(i int) {
	m.coupon_limit_amount = &i
	m.addcoupon_limit_amount = nil
}

// CouponLimitAmount returns the value of the "coupon_limit_amount" field in the mutation.
func (m *OrderBillingMutation) CouponLimitAmount() (r int, exists bool) {
	v := m.coupon_limit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponLimitAmount returns the old "coupon_limit_amount" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCouponLimitAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponLimitAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponLimitAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponLimitAmount: %w", err)
	}
	return oldValue.CouponLimitAmount, nil
}

// AddCouponLimitAmount adds i to the "coupon_limit_amount" field.
func (m *OrderBillingMutation) AddCouponLimitAmount(i int) {
	if m.addcoupon_limit_amount != nil {
		*m.addcoupon_limit_amount += i
	} else {
		m.addcoupon_limit_amount = &i
	}
}

// AddedCouponLimitAmount returns the value that was added to the "coupon_limit_amount" field in this mutation.
func (m *OrderBillingMutation) AddedCouponLimitAmount() (r int, exists bool) {
	v := m.addcoupon_limit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponLimitAmount resets all changes to the "coupon_limit_amount" field.
func (m *OrderBillingMutation) ResetCouponLimitAmount() {
	m.coupon_limit_amount = nil
	m.addcoupon_limit_amount = nil
}

// SetCouponDeductionAmount sets the "coupon_deduction_amount" field.
func (m *OrderBillingMutation) SetCouponDeductionAmount(i int) {
	m.coupon_deduction_amount = &i
	m.addcoupon_deduction_amount = nil
}

// CouponDeductionAmount returns the value of the "coupon_deduction_amount" field in the mutation.
func (m *OrderBillingMutation) CouponDeductionAmount() (r int, exists bool) {
	v := m.coupon_deduction_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponDeductionAmount returns the old "coupon_deduction_amount" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCouponDeductionAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponDeductionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponDeductionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponDeductionAmount: %w", err)
	}
	return oldValue.CouponDeductionAmount, nil
}

// AddCouponDeductionAmount adds i to the "coupon_deduction_amount" field.
func (m *OrderBillingMutation) AddCouponDeductionAmount(i int) {
	if m.addcoupon_deduction_amount != nil {
		*m.addcoupon_deduction_amount += i
	} else {
		m.addcoupon_deduction_amount = &i
	}
}

// AddedCouponDeductionAmount returns the value that was added to the "coupon_deduction_amount" field in this mutation.
func (m *OrderBillingMutation) AddedCouponDeductionAmount() (r int, exists bool) {
	v := m.addcoupon_deduction_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponDeductionAmount resets all changes to the "coupon_deduction_amount" field.
func (m *OrderBillingMutation) ResetCouponDeductionAmount() {
	m.coupon_deduction_amount = nil
	m.addcoupon_deduction_amount = nil
}

// SetCappedAmount sets the "capped_amount" field.
func (m *OrderBillingMutation) SetCappedAmount(i int) {
	m.capped_amount = &i
	m.addcapped_amount = nil
}

// CappedAmount returns the value of the "capped_amount" field in the mutation.
func (m *OrderBillingMutation) CappedAmount() (r int, exists bool) {
	v := m.capped_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCappedAmount returns the old "capped_amount" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCappedAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCappedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCappedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCappedAmount: %w", err)
	}
	return oldValue.CappedAmount, nil
}

// AddCappedAmount adds i to the "capped_amount" field.
func (m *OrderBillingMutation) AddCappedAmount(i int) {
	if m.addcapped_amount != nil {
		*m.addcapped_amount += i
	} else {
		m.addcapped_amount = &i
	}
}

// AddedCappedAmount returns the value that was added to the "capped_amount" field in this mutation.
func (m *OrderBillingMutation) AddedCappedAmount() (r int, exists bool) {
	v := m.addcapped_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCappedAmount resets all changes to the "capped_amount" field.
func (m *OrderBillingMutation) ResetCappedAmount() {
	m.capped_amount = nil
	m.addcapped_amount = nil
}

// SetState sets the "state" field.
func (m *OrderBillingMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OrderBillingMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OrderBillingMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OrderBillingMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OrderBillingMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetStartTime sets the "start_time" field.
func (m *OrderBillingMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *OrderBillingMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *OrderBillingMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[orderbilling.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *OrderBillingMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[orderbilling.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *OrderBillingMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, orderbilling.FieldStartTime)
}

// SetFinishTime sets the "finish_time" field.
func (m *OrderBillingMutation) SetFinishTime(t time.Time) {
	m.finish_time = &t
}

// FinishTime returns the value of the "finish_time" field in the mutation.
func (m *OrderBillingMutation) FinishTime() (r time.Time, exists bool) {
	v := m.finish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old "finish_time" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldFinishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ClearFinishTime clears the value of the "finish_time" field.
func (m *OrderBillingMutation) ClearFinishTime() {
	m.finish_time = nil
	m.clearedFields[orderbilling.FieldFinishTime] = struct{}{}
}

// FinishTimeCleared returns if the "finish_time" field was cleared in this mutation.
func (m *OrderBillingMutation) FinishTimeCleared() bool {
	_, ok := m.clearedFields[orderbilling.FieldFinishTime]
	return ok
}

// ResetFinishTime resets all changes to the "finish_time" field.
func (m *OrderBillingMutation) ResetFinishTime() {
	m.finish_time = nil
	delete(m.clearedFields, orderbilling.FieldFinishTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrderBillingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderBillingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderBillingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderBillingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderBillingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderBilling entity.
// If the OrderBilling object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderBillingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderBillingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderBillingMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderbilling.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderBillingMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderBillingMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderBillingMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderBillingMutation builder.
func (m *OrderBillingMutation) Where(ps ...predicate.OrderBilling) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderBillingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderBillingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderBilling, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderBillingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderBillingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderBilling).
func (m *OrderBillingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderBillingMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m._type != nil {
		fields = append(fields, orderbilling.FieldType)
	}
	if m._order != nil {
		fields = append(fields, orderbilling.FieldOrderID)
	}
	if m.start_time_price != nil {
		fields = append(fields, orderbilling.FieldStartTimePrice)
	}
	if m.start_time_unit != nil {
		fields = append(fields, orderbilling.FieldStartTimeUnit)
	}
	if m.normal_time_price != nil {
		fields = append(fields, orderbilling.FieldNormalTimePrice)
	}
	if m.normal_time_unit != nil {
		fields = append(fields, orderbilling.FieldNormalTimeUnit)
	}
	if m.cumulative_second != nil {
		fields = append(fields, orderbilling.FieldCumulativeSecond)
	}
	if m.cumulative_meter != nil {
		fields = append(fields, orderbilling.FieldCumulativeMeter)
	}
	if m.ticket_count != nil {
		fields = append(fields, orderbilling.FieldTicketCount)
	}
	if m.cumulative_stop != nil {
		fields = append(fields, orderbilling.FieldCumulativeStop)
	}
	if m.start_stop_price != nil {
		fields = append(fields, orderbilling.FieldStartStopPrice)
	}
	if m.start_stop_unit != nil {
		fields = append(fields, orderbilling.FieldStartStopUnit)
	}
	if m.normal_stop_price != nil {
		fields = append(fields, orderbilling.FieldNormalStopPrice)
	}
	if m.normal_stop_unit != nil {
		fields = append(fields, orderbilling.FieldNormalStopUnit)
	}
	if m.coupon_id != nil {
		fields = append(fields, orderbilling.FieldCouponID)
	}
	if m.coupon_limit_amount != nil {
		fields = append(fields, orderbilling.FieldCouponLimitAmount)
	}
	if m.coupon_deduction_amount != nil {
		fields = append(fields, orderbilling.FieldCouponDeductionAmount)
	}
	if m.capped_amount != nil {
		fields = append(fields, orderbilling.FieldCappedAmount)
	}
	if m.state != nil {
		fields = append(fields, orderbilling.FieldState)
	}
	if m.start_time != nil {
		fields = append(fields, orderbilling.FieldStartTime)
	}
	if m.finish_time != nil {
		fields = append(fields, orderbilling.FieldFinishTime)
	}
	if m.create_time != nil {
		fields = append(fields, orderbilling.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderbilling.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderBillingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderbilling.FieldType:
		return m.GetType()
	case orderbilling.FieldOrderID:
		return m.OrderID()
	case orderbilling.FieldStartTimePrice:
		return m.StartTimePrice()
	case orderbilling.FieldStartTimeUnit:
		return m.StartTimeUnit()
	case orderbilling.FieldNormalTimePrice:
		return m.NormalTimePrice()
	case orderbilling.FieldNormalTimeUnit:
		return m.NormalTimeUnit()
	case orderbilling.FieldCumulativeSecond:
		return m.CumulativeSecond()
	case orderbilling.FieldCumulativeMeter:
		return m.CumulativeMeter()
	case orderbilling.FieldTicketCount:
		return m.TicketCount()
	case orderbilling.FieldCumulativeStop:
		return m.CumulativeStop()
	case orderbilling.FieldStartStopPrice:
		return m.StartStopPrice()
	case orderbilling.FieldStartStopUnit:
		return m.StartStopUnit()
	case orderbilling.FieldNormalStopPrice:
		return m.NormalStopPrice()
	case orderbilling.FieldNormalStopUnit:
		return m.NormalStopUnit()
	case orderbilling.FieldCouponID:
		return m.CouponID()
	case orderbilling.FieldCouponLimitAmount:
		return m.CouponLimitAmount()
	case orderbilling.FieldCouponDeductionAmount:
		return m.CouponDeductionAmount()
	case orderbilling.FieldCappedAmount:
		return m.CappedAmount()
	case orderbilling.FieldState:
		return m.State()
	case orderbilling.FieldStartTime:
		return m.StartTime()
	case orderbilling.FieldFinishTime:
		return m.FinishTime()
	case orderbilling.FieldCreateTime:
		return m.CreateTime()
	case orderbilling.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderBillingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderbilling.FieldType:
		return m.OldType(ctx)
	case orderbilling.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderbilling.FieldStartTimePrice:
		return m.OldStartTimePrice(ctx)
	case orderbilling.FieldStartTimeUnit:
		return m.OldStartTimeUnit(ctx)
	case orderbilling.FieldNormalTimePrice:
		return m.OldNormalTimePrice(ctx)
	case orderbilling.FieldNormalTimeUnit:
		return m.OldNormalTimeUnit(ctx)
	case orderbilling.FieldCumulativeSecond:
		return m.OldCumulativeSecond(ctx)
	case orderbilling.FieldCumulativeMeter:
		return m.OldCumulativeMeter(ctx)
	case orderbilling.FieldTicketCount:
		return m.OldTicketCount(ctx)
	case orderbilling.FieldCumulativeStop:
		return m.OldCumulativeStop(ctx)
	case orderbilling.FieldStartStopPrice:
		return m.OldStartStopPrice(ctx)
	case orderbilling.FieldStartStopUnit:
		return m.OldStartStopUnit(ctx)
	case orderbilling.FieldNormalStopPrice:
		return m.OldNormalStopPrice(ctx)
	case orderbilling.FieldNormalStopUnit:
		return m.OldNormalStopUnit(ctx)
	case orderbilling.FieldCouponID:
		return m.OldCouponID(ctx)
	case orderbilling.FieldCouponLimitAmount:
		return m.OldCouponLimitAmount(ctx)
	case orderbilling.FieldCouponDeductionAmount:
		return m.OldCouponDeductionAmount(ctx)
	case orderbilling.FieldCappedAmount:
		return m.OldCappedAmount(ctx)
	case orderbilling.FieldState:
		return m.OldState(ctx)
	case orderbilling.FieldStartTime:
		return m.OldStartTime(ctx)
	case orderbilling.FieldFinishTime:
		return m.OldFinishTime(ctx)
	case orderbilling.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderbilling.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderBilling field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderBillingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderbilling.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderbilling.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderbilling.FieldStartTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimePrice(v)
		return nil
	case orderbilling.FieldStartTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTimeUnit(v)
		return nil
	case orderbilling.FieldNormalTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTimePrice(v)
		return nil
	case orderbilling.FieldNormalTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalTimeUnit(v)
		return nil
	case orderbilling.FieldCumulativeSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeSecond(v)
		return nil
	case orderbilling.FieldCumulativeMeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMeter(v)
		return nil
	case orderbilling.FieldTicketCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketCount(v)
		return nil
	case orderbilling.FieldCumulativeStop:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeStop(v)
		return nil
	case orderbilling.FieldStartStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStopPrice(v)
		return nil
	case orderbilling.FieldStartStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStopUnit(v)
		return nil
	case orderbilling.FieldNormalStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalStopPrice(v)
		return nil
	case orderbilling.FieldNormalStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalStopUnit(v)
		return nil
	case orderbilling.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case orderbilling.FieldCouponLimitAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponLimitAmount(v)
		return nil
	case orderbilling.FieldCouponDeductionAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponDeductionAmount(v)
		return nil
	case orderbilling.FieldCappedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCappedAmount(v)
		return nil
	case orderbilling.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case orderbilling.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case orderbilling.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	case orderbilling.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderbilling.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderBilling field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderBillingMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, orderbilling.FieldType)
	}
	if m.addstart_time_price != nil {
		fields = append(fields, orderbilling.FieldStartTimePrice)
	}
	if m.addstart_time_unit != nil {
		fields = append(fields, orderbilling.FieldStartTimeUnit)
	}
	if m.addnormal_time_price != nil {
		fields = append(fields, orderbilling.FieldNormalTimePrice)
	}
	if m.addnormal_time_unit != nil {
		fields = append(fields, orderbilling.FieldNormalTimeUnit)
	}
	if m.addcumulative_second != nil {
		fields = append(fields, orderbilling.FieldCumulativeSecond)
	}
	if m.addcumulative_meter != nil {
		fields = append(fields, orderbilling.FieldCumulativeMeter)
	}
	if m.addticket_count != nil {
		fields = append(fields, orderbilling.FieldTicketCount)
	}
	if m.addcumulative_stop != nil {
		fields = append(fields, orderbilling.FieldCumulativeStop)
	}
	if m.addstart_stop_price != nil {
		fields = append(fields, orderbilling.FieldStartStopPrice)
	}
	if m.addstart_stop_unit != nil {
		fields = append(fields, orderbilling.FieldStartStopUnit)
	}
	if m.addnormal_stop_price != nil {
		fields = append(fields, orderbilling.FieldNormalStopPrice)
	}
	if m.addnormal_stop_unit != nil {
		fields = append(fields, orderbilling.FieldNormalStopUnit)
	}
	if m.addcoupon_id != nil {
		fields = append(fields, orderbilling.FieldCouponID)
	}
	if m.addcoupon_limit_amount != nil {
		fields = append(fields, orderbilling.FieldCouponLimitAmount)
	}
	if m.addcoupon_deduction_amount != nil {
		fields = append(fields, orderbilling.FieldCouponDeductionAmount)
	}
	if m.addcapped_amount != nil {
		fields = append(fields, orderbilling.FieldCappedAmount)
	}
	if m.addstate != nil {
		fields = append(fields, orderbilling.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderBillingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderbilling.FieldType:
		return m.AddedType()
	case orderbilling.FieldStartTimePrice:
		return m.AddedStartTimePrice()
	case orderbilling.FieldStartTimeUnit:
		return m.AddedStartTimeUnit()
	case orderbilling.FieldNormalTimePrice:
		return m.AddedNormalTimePrice()
	case orderbilling.FieldNormalTimeUnit:
		return m.AddedNormalTimeUnit()
	case orderbilling.FieldCumulativeSecond:
		return m.AddedCumulativeSecond()
	case orderbilling.FieldCumulativeMeter:
		return m.AddedCumulativeMeter()
	case orderbilling.FieldTicketCount:
		return m.AddedTicketCount()
	case orderbilling.FieldCumulativeStop:
		return m.AddedCumulativeStop()
	case orderbilling.FieldStartStopPrice:
		return m.AddedStartStopPrice()
	case orderbilling.FieldStartStopUnit:
		return m.AddedStartStopUnit()
	case orderbilling.FieldNormalStopPrice:
		return m.AddedNormalStopPrice()
	case orderbilling.FieldNormalStopUnit:
		return m.AddedNormalStopUnit()
	case orderbilling.FieldCouponID:
		return m.AddedCouponID()
	case orderbilling.FieldCouponLimitAmount:
		return m.AddedCouponLimitAmount()
	case orderbilling.FieldCouponDeductionAmount:
		return m.AddedCouponDeductionAmount()
	case orderbilling.FieldCappedAmount:
		return m.AddedCappedAmount()
	case orderbilling.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderBillingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderbilling.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case orderbilling.FieldStartTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimePrice(v)
		return nil
	case orderbilling.FieldStartTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTimeUnit(v)
		return nil
	case orderbilling.FieldNormalTimePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTimePrice(v)
		return nil
	case orderbilling.FieldNormalTimeUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalTimeUnit(v)
		return nil
	case orderbilling.FieldCumulativeSecond:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeSecond(v)
		return nil
	case orderbilling.FieldCumulativeMeter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMeter(v)
		return nil
	case orderbilling.FieldTicketCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTicketCount(v)
		return nil
	case orderbilling.FieldCumulativeStop:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeStop(v)
		return nil
	case orderbilling.FieldStartStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartStopPrice(v)
		return nil
	case orderbilling.FieldStartStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartStopUnit(v)
		return nil
	case orderbilling.FieldNormalStopPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalStopPrice(v)
		return nil
	case orderbilling.FieldNormalStopUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalStopUnit(v)
		return nil
	case orderbilling.FieldCouponID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponID(v)
		return nil
	case orderbilling.FieldCouponLimitAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponLimitAmount(v)
		return nil
	case orderbilling.FieldCouponDeductionAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponDeductionAmount(v)
		return nil
	case orderbilling.FieldCappedAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCappedAmount(v)
		return nil
	case orderbilling.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown OrderBilling numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderBillingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderbilling.FieldStartTime) {
		fields = append(fields, orderbilling.FieldStartTime)
	}
	if m.FieldCleared(orderbilling.FieldFinishTime) {
		fields = append(fields, orderbilling.FieldFinishTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderBillingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderBillingMutation) ClearField(name string) error {
	switch name {
	case orderbilling.FieldStartTime:
		m.ClearStartTime()
		return nil
	case orderbilling.FieldFinishTime:
		m.ClearFinishTime()
		return nil
	}
	return fmt.Errorf("unknown OrderBilling nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderBillingMutation) ResetField(name string) error {
	switch name {
	case orderbilling.FieldType:
		m.ResetType()
		return nil
	case orderbilling.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderbilling.FieldStartTimePrice:
		m.ResetStartTimePrice()
		return nil
	case orderbilling.FieldStartTimeUnit:
		m.ResetStartTimeUnit()
		return nil
	case orderbilling.FieldNormalTimePrice:
		m.ResetNormalTimePrice()
		return nil
	case orderbilling.FieldNormalTimeUnit:
		m.ResetNormalTimeUnit()
		return nil
	case orderbilling.FieldCumulativeSecond:
		m.ResetCumulativeSecond()
		return nil
	case orderbilling.FieldCumulativeMeter:
		m.ResetCumulativeMeter()
		return nil
	case orderbilling.FieldTicketCount:
		m.ResetTicketCount()
		return nil
	case orderbilling.FieldCumulativeStop:
		m.ResetCumulativeStop()
		return nil
	case orderbilling.FieldStartStopPrice:
		m.ResetStartStopPrice()
		return nil
	case orderbilling.FieldStartStopUnit:
		m.ResetStartStopUnit()
		return nil
	case orderbilling.FieldNormalStopPrice:
		m.ResetNormalStopPrice()
		return nil
	case orderbilling.FieldNormalStopUnit:
		m.ResetNormalStopUnit()
		return nil
	case orderbilling.FieldCouponID:
		m.ResetCouponID()
		return nil
	case orderbilling.FieldCouponLimitAmount:
		m.ResetCouponLimitAmount()
		return nil
	case orderbilling.FieldCouponDeductionAmount:
		m.ResetCouponDeductionAmount()
		return nil
	case orderbilling.FieldCappedAmount:
		m.ResetCappedAmount()
		return nil
	case orderbilling.FieldState:
		m.ResetState()
		return nil
	case orderbilling.FieldStartTime:
		m.ResetStartTime()
		return nil
	case orderbilling.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	case orderbilling.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderbilling.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderBilling field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderBillingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderbilling.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderBillingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderbilling.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderBillingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderBillingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderBillingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderbilling.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderBillingMutation) EdgeCleared(name string) bool {
	switch name {
	case orderbilling.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderBillingMutation) ClearEdge(name string) error {
	switch name {
	case orderbilling.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderBilling unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderBillingMutation) ResetEdge(name string) error {
	switch name {
	case orderbilling.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderBilling edge %s", name)
}

// OrderExtendFlightMutation represents an operation that mutates the OrderExtendFlight nodes in the graph.
type OrderExtendFlightMutation struct {
	config
	op               Op
	typ              string
	id               *int
	order_id         *int
	addorder_id      *int
	flight_id        *int
	addflight_id     *int
	flight_no        *string
	route_id         *int
	addroute_id      *int
	route_name       *string
	start_stop_id    *int
	addstart_stop_id *int
	end_stop_id      *int
	addend_stop_id   *int
	ticket_count     *int
	addticket_count  *int
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*OrderExtendFlight, error)
	predicates       []predicate.OrderExtendFlight
}

var _ ent.Mutation = (*OrderExtendFlightMutation)(nil)

// orderextendflightOption allows management of the mutation configuration using functional options.
type orderextendflightOption func(*OrderExtendFlightMutation)

// newOrderExtendFlightMutation creates new mutation for the OrderExtendFlight entity.
func newOrderExtendFlightMutation(c config, op Op, opts ...orderextendflightOption) *OrderExtendFlightMutation {
	m := &OrderExtendFlightMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderExtendFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderExtendFlightID sets the ID field of the mutation.
func withOrderExtendFlightID(id int) orderextendflightOption {
	return func(m *OrderExtendFlightMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderExtendFlight
		)
		m.oldValue = func(ctx context.Context) (*OrderExtendFlight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderExtendFlight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderExtendFlight sets the old OrderExtendFlight of the mutation.
func withOrderExtendFlight(node *OrderExtendFlight) orderextendflightOption {
	return func(m *OrderExtendFlightMutation) {
		m.oldValue = func(context.Context) (*OrderExtendFlight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderExtendFlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderExtendFlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderExtendFlight entities.
func (m *OrderExtendFlightMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderExtendFlightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderExtendFlightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderExtendFlight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderExtendFlightMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderExtendFlightMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *OrderExtendFlightMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderExtendFlightMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderExtendFlightMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetFlightID sets the "flight_id" field.
func (m *OrderExtendFlightMutation) SetFlightID(i int) {
	m.flight_id = &i
	m.addflight_id = nil
}

// FlightID returns the value of the "flight_id" field in the mutation.
func (m *OrderExtendFlightMutation) FlightID() (r int, exists bool) {
	v := m.flight_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightID returns the old "flight_id" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldFlightID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightID: %w", err)
	}
	return oldValue.FlightID, nil
}

// AddFlightID adds i to the "flight_id" field.
func (m *OrderExtendFlightMutation) AddFlightID(i int) {
	if m.addflight_id != nil {
		*m.addflight_id += i
	} else {
		m.addflight_id = &i
	}
}

// AddedFlightID returns the value that was added to the "flight_id" field in this mutation.
func (m *OrderExtendFlightMutation) AddedFlightID() (r int, exists bool) {
	v := m.addflight_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlightID resets all changes to the "flight_id" field.
func (m *OrderExtendFlightMutation) ResetFlightID() {
	m.flight_id = nil
	m.addflight_id = nil
}

// SetFlightNo sets the "flight_no" field.
func (m *OrderExtendFlightMutation) SetFlightNo(s string) {
	m.flight_no = &s
}

// FlightNo returns the value of the "flight_no" field in the mutation.
func (m *OrderExtendFlightMutation) FlightNo() (r string, exists bool) {
	v := m.flight_no
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightNo returns the old "flight_no" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldFlightNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightNo: %w", err)
	}
	return oldValue.FlightNo, nil
}

// ResetFlightNo resets all changes to the "flight_no" field.
func (m *OrderExtendFlightMutation) ResetFlightNo() {
	m.flight_no = nil
}

// SetRouteID sets the "route_id" field.
func (m *OrderExtendFlightMutation) SetRouteID(i int) {
	m.route_id = &i
	m.addroute_id = nil
}

// RouteID returns the value of the "route_id" field in the mutation.
func (m *OrderExtendFlightMutation) RouteID() (r int, exists bool) {
	v := m.route_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteID returns the old "route_id" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldRouteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteID: %w", err)
	}
	return oldValue.RouteID, nil
}

// AddRouteID adds i to the "route_id" field.
func (m *OrderExtendFlightMutation) AddRouteID(i int) {
	if m.addroute_id != nil {
		*m.addroute_id += i
	} else {
		m.addroute_id = &i
	}
}

// AddedRouteID returns the value that was added to the "route_id" field in this mutation.
func (m *OrderExtendFlightMutation) AddedRouteID() (r int, exists bool) {
	v := m.addroute_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRouteID resets all changes to the "route_id" field.
func (m *OrderExtendFlightMutation) ResetRouteID() {
	m.route_id = nil
	m.addroute_id = nil
}

// SetRouteName sets the "route_name" field.
func (m *OrderExtendFlightMutation) SetRouteName(s string) {
	m.route_name = &s
}

// RouteName returns the value of the "route_name" field in the mutation.
func (m *OrderExtendFlightMutation) RouteName() (r string, exists bool) {
	v := m.route_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRouteName returns the old "route_name" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldRouteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRouteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRouteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRouteName: %w", err)
	}
	return oldValue.RouteName, nil
}

// ResetRouteName resets all changes to the "route_name" field.
func (m *OrderExtendFlightMutation) ResetRouteName() {
	m.route_name = nil
}

// SetStartStopID sets the "start_stop_id" field.
func (m *OrderExtendFlightMutation) SetStartStopID(i int) {
	m.start_stop_id = &i
	m.addstart_stop_id = nil
}

// StartStopID returns the value of the "start_stop_id" field in the mutation.
func (m *OrderExtendFlightMutation) StartStopID() (r int, exists bool) {
	v := m.start_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStopID returns the old "start_stop_id" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldStartStopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStopID: %w", err)
	}
	return oldValue.StartStopID, nil
}

// AddStartStopID adds i to the "start_stop_id" field.
func (m *OrderExtendFlightMutation) AddStartStopID(i int) {
	if m.addstart_stop_id != nil {
		*m.addstart_stop_id += i
	} else {
		m.addstart_stop_id = &i
	}
}

// AddedStartStopID returns the value that was added to the "start_stop_id" field in this mutation.
func (m *OrderExtendFlightMutation) AddedStartStopID() (r int, exists bool) {
	v := m.addstart_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartStopID resets all changes to the "start_stop_id" field.
func (m *OrderExtendFlightMutation) ResetStartStopID() {
	m.start_stop_id = nil
	m.addstart_stop_id = nil
}

// SetEndStopID sets the "end_stop_id" field.
func (m *OrderExtendFlightMutation) SetEndStopID(i int) {
	m.end_stop_id = &i
	m.addend_stop_id = nil
}

// EndStopID returns the value of the "end_stop_id" field in the mutation.
func (m *OrderExtendFlightMutation) EndStopID() (r int, exists bool) {
	v := m.end_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStopID returns the old "end_stop_id" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldEndStopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStopID: %w", err)
	}
	return oldValue.EndStopID, nil
}

// AddEndStopID adds i to the "end_stop_id" field.
func (m *OrderExtendFlightMutation) AddEndStopID(i int) {
	if m.addend_stop_id != nil {
		*m.addend_stop_id += i
	} else {
		m.addend_stop_id = &i
	}
}

// AddedEndStopID returns the value that was added to the "end_stop_id" field in this mutation.
func (m *OrderExtendFlightMutation) AddedEndStopID() (r int, exists bool) {
	v := m.addend_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndStopID resets all changes to the "end_stop_id" field.
func (m *OrderExtendFlightMutation) ResetEndStopID() {
	m.end_stop_id = nil
	m.addend_stop_id = nil
}

// SetTicketCount sets the "ticket_count" field.
func (m *OrderExtendFlightMutation) SetTicketCount(i int) {
	m.ticket_count = &i
	m.addticket_count = nil
}

// TicketCount returns the value of the "ticket_count" field in the mutation.
func (m *OrderExtendFlightMutation) TicketCount() (r int, exists bool) {
	v := m.ticket_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketCount returns the old "ticket_count" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldTicketCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketCount: %w", err)
	}
	return oldValue.TicketCount, nil
}

// AddTicketCount adds i to the "ticket_count" field.
func (m *OrderExtendFlightMutation) AddTicketCount(i int) {
	if m.addticket_count != nil {
		*m.addticket_count += i
	} else {
		m.addticket_count = &i
	}
}

// AddedTicketCount returns the value that was added to the "ticket_count" field in this mutation.
func (m *OrderExtendFlightMutation) AddedTicketCount() (r int, exists bool) {
	v := m.addticket_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTicketCount resets all changes to the "ticket_count" field.
func (m *OrderExtendFlightMutation) ResetTicketCount() {
	m.ticket_count = nil
	m.addticket_count = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OrderExtendFlightMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderExtendFlightMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderExtendFlightMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderExtendFlightMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderExtendFlightMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderExtendFlight entity.
// If the OrderExtendFlight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderExtendFlightMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderExtendFlightMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrderExtendFlightMutation builder.
func (m *OrderExtendFlightMutation) Where(ps ...predicate.OrderExtendFlight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderExtendFlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderExtendFlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderExtendFlight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderExtendFlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderExtendFlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderExtendFlight).
func (m *OrderExtendFlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderExtendFlightMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.order_id != nil {
		fields = append(fields, orderextendflight.FieldOrderID)
	}
	if m.flight_id != nil {
		fields = append(fields, orderextendflight.FieldFlightID)
	}
	if m.flight_no != nil {
		fields = append(fields, orderextendflight.FieldFlightNo)
	}
	if m.route_id != nil {
		fields = append(fields, orderextendflight.FieldRouteID)
	}
	if m.route_name != nil {
		fields = append(fields, orderextendflight.FieldRouteName)
	}
	if m.start_stop_id != nil {
		fields = append(fields, orderextendflight.FieldStartStopID)
	}
	if m.end_stop_id != nil {
		fields = append(fields, orderextendflight.FieldEndStopID)
	}
	if m.ticket_count != nil {
		fields = append(fields, orderextendflight.FieldTicketCount)
	}
	if m.create_time != nil {
		fields = append(fields, orderextendflight.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderextendflight.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderExtendFlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderextendflight.FieldOrderID:
		return m.OrderID()
	case orderextendflight.FieldFlightID:
		return m.FlightID()
	case orderextendflight.FieldFlightNo:
		return m.FlightNo()
	case orderextendflight.FieldRouteID:
		return m.RouteID()
	case orderextendflight.FieldRouteName:
		return m.RouteName()
	case orderextendflight.FieldStartStopID:
		return m.StartStopID()
	case orderextendflight.FieldEndStopID:
		return m.EndStopID()
	case orderextendflight.FieldTicketCount:
		return m.TicketCount()
	case orderextendflight.FieldCreateTime:
		return m.CreateTime()
	case orderextendflight.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderExtendFlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderextendflight.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderextendflight.FieldFlightID:
		return m.OldFlightID(ctx)
	case orderextendflight.FieldFlightNo:
		return m.OldFlightNo(ctx)
	case orderextendflight.FieldRouteID:
		return m.OldRouteID(ctx)
	case orderextendflight.FieldRouteName:
		return m.OldRouteName(ctx)
	case orderextendflight.FieldStartStopID:
		return m.OldStartStopID(ctx)
	case orderextendflight.FieldEndStopID:
		return m.OldEndStopID(ctx)
	case orderextendflight.FieldTicketCount:
		return m.OldTicketCount(ctx)
	case orderextendflight.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderextendflight.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderExtendFlight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderExtendFlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderextendflight.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderextendflight.FieldFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightID(v)
		return nil
	case orderextendflight.FieldFlightNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightNo(v)
		return nil
	case orderextendflight.FieldRouteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteID(v)
		return nil
	case orderextendflight.FieldRouteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRouteName(v)
		return nil
	case orderextendflight.FieldStartStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStopID(v)
		return nil
	case orderextendflight.FieldEndStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStopID(v)
		return nil
	case orderextendflight.FieldTicketCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketCount(v)
		return nil
	case orderextendflight.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderextendflight.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderExtendFlight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderExtendFlightMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, orderextendflight.FieldOrderID)
	}
	if m.addflight_id != nil {
		fields = append(fields, orderextendflight.FieldFlightID)
	}
	if m.addroute_id != nil {
		fields = append(fields, orderextendflight.FieldRouteID)
	}
	if m.addstart_stop_id != nil {
		fields = append(fields, orderextendflight.FieldStartStopID)
	}
	if m.addend_stop_id != nil {
		fields = append(fields, orderextendflight.FieldEndStopID)
	}
	if m.addticket_count != nil {
		fields = append(fields, orderextendflight.FieldTicketCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderExtendFlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderextendflight.FieldOrderID:
		return m.AddedOrderID()
	case orderextendflight.FieldFlightID:
		return m.AddedFlightID()
	case orderextendflight.FieldRouteID:
		return m.AddedRouteID()
	case orderextendflight.FieldStartStopID:
		return m.AddedStartStopID()
	case orderextendflight.FieldEndStopID:
		return m.AddedEndStopID()
	case orderextendflight.FieldTicketCount:
		return m.AddedTicketCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderExtendFlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderextendflight.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderextendflight.FieldFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlightID(v)
		return nil
	case orderextendflight.FieldRouteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRouteID(v)
		return nil
	case orderextendflight.FieldStartStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartStopID(v)
		return nil
	case orderextendflight.FieldEndStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndStopID(v)
		return nil
	case orderextendflight.FieldTicketCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTicketCount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderExtendFlight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderExtendFlightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderExtendFlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderExtendFlightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderExtendFlight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderExtendFlightMutation) ResetField(name string) error {
	switch name {
	case orderextendflight.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderextendflight.FieldFlightID:
		m.ResetFlightID()
		return nil
	case orderextendflight.FieldFlightNo:
		m.ResetFlightNo()
		return nil
	case orderextendflight.FieldRouteID:
		m.ResetRouteID()
		return nil
	case orderextendflight.FieldRouteName:
		m.ResetRouteName()
		return nil
	case orderextendflight.FieldStartStopID:
		m.ResetStartStopID()
		return nil
	case orderextendflight.FieldEndStopID:
		m.ResetEndStopID()
		return nil
	case orderextendflight.FieldTicketCount:
		m.ResetTicketCount()
		return nil
	case orderextendflight.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderextendflight.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderExtendFlight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderExtendFlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderExtendFlightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderExtendFlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderExtendFlightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderExtendFlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderExtendFlightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderExtendFlightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderExtendFlight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderExtendFlightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderExtendFlight edge %s", name)
}

// OrderRefundMutation represents an operation that mutates the OrderRefund nodes in the graph.
type OrderRefundMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_type              *int
	add_type           *int
	initiator_id       *int
	addinitiator_id    *int
	scenic_area_id     *int
	addscenic_area_id  *int
	order_appeal_id    *int
	addorder_appeal_id *int
	order_no           *string
	refund_no          *string
	wx_refund_id       *string
	refund_amount      *int
	addrefund_amount   *int
	state              *int
	addstate           *int
	remark             *string
	errmsg             *string
	finish_time        *time.Time
	create_time        *time.Time
	update_time        *time.Time
	clearedFields      map[string]struct{}
	_order             *int
	cleared_order      bool
	done               bool
	oldValue           func(context.Context) (*OrderRefund, error)
	predicates         []predicate.OrderRefund
}

var _ ent.Mutation = (*OrderRefundMutation)(nil)

// orderrefundOption allows management of the mutation configuration using functional options.
type orderrefundOption func(*OrderRefundMutation)

// newOrderRefundMutation creates new mutation for the OrderRefund entity.
func newOrderRefundMutation(c config, op Op, opts ...orderrefundOption) *OrderRefundMutation {
	m := &OrderRefundMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderRefundID sets the ID field of the mutation.
func withOrderRefundID(id int) orderrefundOption {
	return func(m *OrderRefundMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderRefund
		)
		m.oldValue = func(ctx context.Context) (*OrderRefund, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderRefund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderRefund sets the old OrderRefund of the mutation.
func withOrderRefund(node *OrderRefund) orderrefundOption {
	return func(m *OrderRefundMutation) {
		m.oldValue = func(context.Context) (*OrderRefund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderRefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderRefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderRefund entities.
func (m *OrderRefundMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderRefundMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderRefundMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderRefund.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *OrderRefundMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderRefundMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderRefundMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderRefundMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderRefundMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetInitiatorID sets the "initiator_id" field.
func (m *OrderRefundMutation) SetInitiatorID(i int) {
	m.initiator_id = &i
	m.addinitiator_id = nil
}

// InitiatorID returns the value of the "initiator_id" field in the mutation.
func (m *OrderRefundMutation) InitiatorID() (r int, exists bool) {
	v := m.initiator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiatorID returns the old "initiator_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldInitiatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiatorID: %w", err)
	}
	return oldValue.InitiatorID, nil
}

// AddInitiatorID adds i to the "initiator_id" field.
func (m *OrderRefundMutation) AddInitiatorID(i int) {
	if m.addinitiator_id != nil {
		*m.addinitiator_id += i
	} else {
		m.addinitiator_id = &i
	}
}

// AddedInitiatorID returns the value that was added to the "initiator_id" field in this mutation.
func (m *OrderRefundMutation) AddedInitiatorID() (r int, exists bool) {
	v := m.addinitiator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetInitiatorID resets all changes to the "initiator_id" field.
func (m *OrderRefundMutation) ResetInitiatorID() {
	m.initiator_id = nil
	m.addinitiator_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *OrderRefundMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *OrderRefundMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *OrderRefundMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *OrderRefundMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *OrderRefundMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderRefundMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderRefundMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderRefundMutation) ResetOrderID() {
	m._order = nil
}

// SetOrderAppealID sets the "order_appeal_id" field.
func (m *OrderRefundMutation) SetOrderAppealID(i int) {
	m.order_appeal_id = &i
	m.addorder_appeal_id = nil
}

// OrderAppealID returns the value of the "order_appeal_id" field in the mutation.
func (m *OrderRefundMutation) OrderAppealID() (r int, exists bool) {
	v := m.order_appeal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAppealID returns the old "order_appeal_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOrderAppealID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAppealID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAppealID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAppealID: %w", err)
	}
	return oldValue.OrderAppealID, nil
}

// AddOrderAppealID adds i to the "order_appeal_id" field.
func (m *OrderRefundMutation) AddOrderAppealID(i int) {
	if m.addorder_appeal_id != nil {
		*m.addorder_appeal_id += i
	} else {
		m.addorder_appeal_id = &i
	}
}

// AddedOrderAppealID returns the value that was added to the "order_appeal_id" field in this mutation.
func (m *OrderRefundMutation) AddedOrderAppealID() (r int, exists bool) {
	v := m.addorder_appeal_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderAppealID clears the value of the "order_appeal_id" field.
func (m *OrderRefundMutation) ClearOrderAppealID() {
	m.order_appeal_id = nil
	m.addorder_appeal_id = nil
	m.clearedFields[orderrefund.FieldOrderAppealID] = struct{}{}
}

// OrderAppealIDCleared returns if the "order_appeal_id" field was cleared in this mutation.
func (m *OrderRefundMutation) OrderAppealIDCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldOrderAppealID]
	return ok
}

// ResetOrderAppealID resets all changes to the "order_appeal_id" field.
func (m *OrderRefundMutation) ResetOrderAppealID() {
	m.order_appeal_id = nil
	m.addorder_appeal_id = nil
	delete(m.clearedFields, orderrefund.FieldOrderAppealID)
}

// SetOrderNo sets the "order_no" field.
func (m *OrderRefundMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderRefundMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderRefundMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetRefundNo sets the "refund_no" field.
func (m *OrderRefundMutation) SetRefundNo(s string) {
	m.refund_no = &s
}

// RefundNo returns the value of the "refund_no" field in the mutation.
func (m *OrderRefundMutation) RefundNo() (r string, exists bool) {
	v := m.refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundNo returns the old "refund_no" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundNo: %w", err)
	}
	return oldValue.RefundNo, nil
}

// ResetRefundNo resets all changes to the "refund_no" field.
func (m *OrderRefundMutation) ResetRefundNo() {
	m.refund_no = nil
}

// SetWxRefundID sets the "wx_refund_id" field.
func (m *OrderRefundMutation) SetWxRefundID(s string) {
	m.wx_refund_id = &s
}

// WxRefundID returns the value of the "wx_refund_id" field in the mutation.
func (m *OrderRefundMutation) WxRefundID() (r string, exists bool) {
	v := m.wx_refund_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWxRefundID returns the old "wx_refund_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldWxRefundID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWxRefundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWxRefundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxRefundID: %w", err)
	}
	return oldValue.WxRefundID, nil
}

// ResetWxRefundID resets all changes to the "wx_refund_id" field.
func (m *OrderRefundMutation) ResetWxRefundID() {
	m.wx_refund_id = nil
}

// SetRefundAmount sets the "refund_amount" field.
func (m *OrderRefundMutation) SetRefundAmount(i int) {
	m.refund_amount = &i
	m.addrefund_amount = nil
}

// RefundAmount returns the value of the "refund_amount" field in the mutation.
func (m *OrderRefundMutation) RefundAmount() (r int, exists bool) {
	v := m.refund_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAmount returns the old "refund_amount" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRefundAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAmount: %w", err)
	}
	return oldValue.RefundAmount, nil
}

// AddRefundAmount adds i to the "refund_amount" field.
func (m *OrderRefundMutation) AddRefundAmount(i int) {
	if m.addrefund_amount != nil {
		*m.addrefund_amount += i
	} else {
		m.addrefund_amount = &i
	}
}

// AddedRefundAmount returns the value that was added to the "refund_amount" field in this mutation.
func (m *OrderRefundMutation) AddedRefundAmount() (r int, exists bool) {
	v := m.addrefund_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefundAmount resets all changes to the "refund_amount" field.
func (m *OrderRefundMutation) ResetRefundAmount() {
	m.refund_amount = nil
	m.addrefund_amount = nil
}

// SetState sets the "state" field.
func (m *OrderRefundMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OrderRefundMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OrderRefundMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OrderRefundMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OrderRefundMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetRemark sets the "remark" field.
func (m *OrderRefundMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderRefundMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderRefundMutation) ResetRemark() {
	m.remark = nil
}

// SetErrmsg sets the "errmsg" field.
func (m *OrderRefundMutation) SetErrmsg(s string) {
	m.errmsg = &s
}

// Errmsg returns the value of the "errmsg" field in the mutation.
func (m *OrderRefundMutation) Errmsg() (r string, exists bool) {
	v := m.errmsg
	if v == nil {
		return
	}
	return *v, true
}

// OldErrmsg returns the old "errmsg" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldErrmsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrmsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrmsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrmsg: %w", err)
	}
	return oldValue.Errmsg, nil
}

// ResetErrmsg resets all changes to the "errmsg" field.
func (m *OrderRefundMutation) ResetErrmsg() {
	m.errmsg = nil
}

// SetFinishTime sets the "finish_time" field.
func (m *OrderRefundMutation) SetFinishTime(t time.Time) {
	m.finish_time = &t
}

// FinishTime returns the value of the "finish_time" field in the mutation.
func (m *OrderRefundMutation) FinishTime() (r time.Time, exists bool) {
	v := m.finish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishTime returns the old "finish_time" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldFinishTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishTime: %w", err)
	}
	return oldValue.FinishTime, nil
}

// ClearFinishTime clears the value of the "finish_time" field.
func (m *OrderRefundMutation) ClearFinishTime() {
	m.finish_time = nil
	m.clearedFields[orderrefund.FieldFinishTime] = struct{}{}
}

// FinishTimeCleared returns if the "finish_time" field was cleared in this mutation.
func (m *OrderRefundMutation) FinishTimeCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldFinishTime]
	return ok
}

// ResetFinishTime resets all changes to the "finish_time" field.
func (m *OrderRefundMutation) ResetFinishTime() {
	m.finish_time = nil
	delete(m.clearedFields, orderrefund.FieldFinishTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrderRefundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderRefundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderRefundMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderRefundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderRefundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderRefundMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderRefundMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderrefund.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderRefundMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderRefundMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderRefundMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderRefundMutation builder.
func (m *OrderRefundMutation) Where(ps ...predicate.OrderRefund) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderRefundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderRefundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderRefund, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderRefundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderRefundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderRefund).
func (m *OrderRefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderRefundMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m._type != nil {
		fields = append(fields, orderrefund.FieldType)
	}
	if m.initiator_id != nil {
		fields = append(fields, orderrefund.FieldInitiatorID)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, orderrefund.FieldScenicAreaID)
	}
	if m._order != nil {
		fields = append(fields, orderrefund.FieldOrderID)
	}
	if m.order_appeal_id != nil {
		fields = append(fields, orderrefund.FieldOrderAppealID)
	}
	if m.order_no != nil {
		fields = append(fields, orderrefund.FieldOrderNo)
	}
	if m.refund_no != nil {
		fields = append(fields, orderrefund.FieldRefundNo)
	}
	if m.wx_refund_id != nil {
		fields = append(fields, orderrefund.FieldWxRefundID)
	}
	if m.refund_amount != nil {
		fields = append(fields, orderrefund.FieldRefundAmount)
	}
	if m.state != nil {
		fields = append(fields, orderrefund.FieldState)
	}
	if m.remark != nil {
		fields = append(fields, orderrefund.FieldRemark)
	}
	if m.errmsg != nil {
		fields = append(fields, orderrefund.FieldErrmsg)
	}
	if m.finish_time != nil {
		fields = append(fields, orderrefund.FieldFinishTime)
	}
	if m.create_time != nil {
		fields = append(fields, orderrefund.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderrefund.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderRefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldType:
		return m.GetType()
	case orderrefund.FieldInitiatorID:
		return m.InitiatorID()
	case orderrefund.FieldScenicAreaID:
		return m.ScenicAreaID()
	case orderrefund.FieldOrderID:
		return m.OrderID()
	case orderrefund.FieldOrderAppealID:
		return m.OrderAppealID()
	case orderrefund.FieldOrderNo:
		return m.OrderNo()
	case orderrefund.FieldRefundNo:
		return m.RefundNo()
	case orderrefund.FieldWxRefundID:
		return m.WxRefundID()
	case orderrefund.FieldRefundAmount:
		return m.RefundAmount()
	case orderrefund.FieldState:
		return m.State()
	case orderrefund.FieldRemark:
		return m.Remark()
	case orderrefund.FieldErrmsg:
		return m.Errmsg()
	case orderrefund.FieldFinishTime:
		return m.FinishTime()
	case orderrefund.FieldCreateTime:
		return m.CreateTime()
	case orderrefund.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderRefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderrefund.FieldType:
		return m.OldType(ctx)
	case orderrefund.FieldInitiatorID:
		return m.OldInitiatorID(ctx)
	case orderrefund.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case orderrefund.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderrefund.FieldOrderAppealID:
		return m.OldOrderAppealID(ctx)
	case orderrefund.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case orderrefund.FieldRefundNo:
		return m.OldRefundNo(ctx)
	case orderrefund.FieldWxRefundID:
		return m.OldWxRefundID(ctx)
	case orderrefund.FieldRefundAmount:
		return m.OldRefundAmount(ctx)
	case orderrefund.FieldState:
		return m.OldState(ctx)
	case orderrefund.FieldRemark:
		return m.OldRemark(ctx)
	case orderrefund.FieldErrmsg:
		return m.OldErrmsg(ctx)
	case orderrefund.FieldFinishTime:
		return m.OldFinishTime(ctx)
	case orderrefund.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderrefund.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderRefund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderrefund.FieldInitiatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiatorID(v)
		return nil
	case orderrefund.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case orderrefund.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderrefund.FieldOrderAppealID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAppealID(v)
		return nil
	case orderrefund.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case orderrefund.FieldRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundNo(v)
		return nil
	case orderrefund.FieldWxRefundID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxRefundID(v)
		return nil
	case orderrefund.FieldRefundAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAmount(v)
		return nil
	case orderrefund.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case orderrefund.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orderrefund.FieldErrmsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrmsg(v)
		return nil
	case orderrefund.FieldFinishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishTime(v)
		return nil
	case orderrefund.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderrefund.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderRefundMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, orderrefund.FieldType)
	}
	if m.addinitiator_id != nil {
		fields = append(fields, orderrefund.FieldInitiatorID)
	}
	if m.addscenic_area_id != nil {
		fields = append(fields, orderrefund.FieldScenicAreaID)
	}
	if m.addorder_appeal_id != nil {
		fields = append(fields, orderrefund.FieldOrderAppealID)
	}
	if m.addrefund_amount != nil {
		fields = append(fields, orderrefund.FieldRefundAmount)
	}
	if m.addstate != nil {
		fields = append(fields, orderrefund.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderRefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldType:
		return m.AddedType()
	case orderrefund.FieldInitiatorID:
		return m.AddedInitiatorID()
	case orderrefund.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case orderrefund.FieldOrderAppealID:
		return m.AddedOrderAppealID()
	case orderrefund.FieldRefundAmount:
		return m.AddedRefundAmount()
	case orderrefund.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case orderrefund.FieldInitiatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitiatorID(v)
		return nil
	case orderrefund.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case orderrefund.FieldOrderAppealID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAppealID(v)
		return nil
	case orderrefund.FieldRefundAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefundAmount(v)
		return nil
	case orderrefund.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderRefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderrefund.FieldOrderAppealID) {
		fields = append(fields, orderrefund.FieldOrderAppealID)
	}
	if m.FieldCleared(orderrefund.FieldFinishTime) {
		fields = append(fields, orderrefund.FieldFinishTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderRefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderRefundMutation) ClearField(name string) error {
	switch name {
	case orderrefund.FieldOrderAppealID:
		m.ClearOrderAppealID()
		return nil
	case orderrefund.FieldFinishTime:
		m.ClearFinishTime()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderRefundMutation) ResetField(name string) error {
	switch name {
	case orderrefund.FieldType:
		m.ResetType()
		return nil
	case orderrefund.FieldInitiatorID:
		m.ResetInitiatorID()
		return nil
	case orderrefund.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case orderrefund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderrefund.FieldOrderAppealID:
		m.ResetOrderAppealID()
		return nil
	case orderrefund.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case orderrefund.FieldRefundNo:
		m.ResetRefundNo()
		return nil
	case orderrefund.FieldWxRefundID:
		m.ResetWxRefundID()
		return nil
	case orderrefund.FieldRefundAmount:
		m.ResetRefundAmount()
		return nil
	case orderrefund.FieldState:
		m.ResetState()
		return nil
	case orderrefund.FieldRemark:
		m.ResetRemark()
		return nil
	case orderrefund.FieldErrmsg:
		m.ResetErrmsg()
		return nil
	case orderrefund.FieldFinishTime:
		m.ResetFinishTime()
		return nil
	case orderrefund.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderrefund.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderRefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderRefundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderrefund.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderRefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderRefundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderRefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderRefundMutation) EdgeCleared(name string) bool {
	switch name {
	case orderrefund.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderRefundMutation) ClearEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderRefundMutation) ResetEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund edge %s", name)
}

// OrderSharingMutation represents an operation that mutates the OrderSharing nodes in the graph.
type OrderSharingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	sharing_no        *string
	wx_sharing_id     *string
	sharing_amount    *int
	addsharing_amount *int
	receivers         *[]types.OrderSharingReceiver
	appendreceivers   []types.OrderSharingReceiver
	state             *int
	addstate          *int
	remark            *string
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	_order            *int
	cleared_order     bool
	done              bool
	oldValue          func(context.Context) (*OrderSharing, error)
	predicates        []predicate.OrderSharing
}

var _ ent.Mutation = (*OrderSharingMutation)(nil)

// ordersharingOption allows management of the mutation configuration using functional options.
type ordersharingOption func(*OrderSharingMutation)

// newOrderSharingMutation creates new mutation for the OrderSharing entity.
func newOrderSharingMutation(c config, op Op, opts ...ordersharingOption) *OrderSharingMutation {
	m := &OrderSharingMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSharing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSharingID sets the ID field of the mutation.
func withOrderSharingID(id int) ordersharingOption {
	return func(m *OrderSharingMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSharing
		)
		m.oldValue = func(ctx context.Context) (*OrderSharing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSharing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSharing sets the old OrderSharing of the mutation.
func withOrderSharing(node *OrderSharing) ordersharingOption {
	return func(m *OrderSharingMutation) {
		m.oldValue = func(context.Context) (*OrderSharing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSharingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSharingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSharing entities.
func (m *OrderSharingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSharingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSharingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSharing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderSharingMutation) SetOrderID(i int) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSharingMutation) OrderID() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSharingMutation) ResetOrderID() {
	m._order = nil
}

// SetSharingNo sets the "sharing_no" field.
func (m *OrderSharingMutation) SetSharingNo(s string) {
	m.sharing_no = &s
}

// SharingNo returns the value of the "sharing_no" field in the mutation.
func (m *OrderSharingMutation) SharingNo() (r string, exists bool) {
	v := m.sharing_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSharingNo returns the old "sharing_no" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldSharingNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharingNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharingNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharingNo: %w", err)
	}
	return oldValue.SharingNo, nil
}

// ResetSharingNo resets all changes to the "sharing_no" field.
func (m *OrderSharingMutation) ResetSharingNo() {
	m.sharing_no = nil
}

// SetWxSharingID sets the "wx_sharing_id" field.
func (m *OrderSharingMutation) SetWxSharingID(s string) {
	m.wx_sharing_id = &s
}

// WxSharingID returns the value of the "wx_sharing_id" field in the mutation.
func (m *OrderSharingMutation) WxSharingID() (r string, exists bool) {
	v := m.wx_sharing_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWxSharingID returns the old "wx_sharing_id" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldWxSharingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWxSharingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWxSharingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxSharingID: %w", err)
	}
	return oldValue.WxSharingID, nil
}

// ResetWxSharingID resets all changes to the "wx_sharing_id" field.
func (m *OrderSharingMutation) ResetWxSharingID() {
	m.wx_sharing_id = nil
}

// SetSharingAmount sets the "sharing_amount" field.
func (m *OrderSharingMutation) SetSharingAmount(i int) {
	m.sharing_amount = &i
	m.addsharing_amount = nil
}

// SharingAmount returns the value of the "sharing_amount" field in the mutation.
func (m *OrderSharingMutation) SharingAmount() (r int, exists bool) {
	v := m.sharing_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSharingAmount returns the old "sharing_amount" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldSharingAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharingAmount: %w", err)
	}
	return oldValue.SharingAmount, nil
}

// AddSharingAmount adds i to the "sharing_amount" field.
func (m *OrderSharingMutation) AddSharingAmount(i int) {
	if m.addsharing_amount != nil {
		*m.addsharing_amount += i
	} else {
		m.addsharing_amount = &i
	}
}

// AddedSharingAmount returns the value that was added to the "sharing_amount" field in this mutation.
func (m *OrderSharingMutation) AddedSharingAmount() (r int, exists bool) {
	v := m.addsharing_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetSharingAmount resets all changes to the "sharing_amount" field.
func (m *OrderSharingMutation) ResetSharingAmount() {
	m.sharing_amount = nil
	m.addsharing_amount = nil
}

// SetReceivers sets the "receivers" field.
func (m *OrderSharingMutation) SetReceivers(tsr []types.OrderSharingReceiver) {
	m.receivers = &tsr
	m.appendreceivers = nil
}

// Receivers returns the value of the "receivers" field in the mutation.
func (m *OrderSharingMutation) Receivers() (r []types.OrderSharingReceiver, exists bool) {
	v := m.receivers
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivers returns the old "receivers" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldReceivers(ctx context.Context) (v []types.OrderSharingReceiver, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivers: %w", err)
	}
	return oldValue.Receivers, nil
}

// AppendReceivers adds tsr to the "receivers" field.
func (m *OrderSharingMutation) AppendReceivers(tsr []types.OrderSharingReceiver) {
	m.appendreceivers = append(m.appendreceivers, tsr...)
}

// AppendedReceivers returns the list of values that were appended to the "receivers" field in this mutation.
func (m *OrderSharingMutation) AppendedReceivers() ([]types.OrderSharingReceiver, bool) {
	if len(m.appendreceivers) == 0 {
		return nil, false
	}
	return m.appendreceivers, true
}

// ClearReceivers clears the value of the "receivers" field.
func (m *OrderSharingMutation) ClearReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
	m.clearedFields[ordersharing.FieldReceivers] = struct{}{}
}

// ReceiversCleared returns if the "receivers" field was cleared in this mutation.
func (m *OrderSharingMutation) ReceiversCleared() bool {
	_, ok := m.clearedFields[ordersharing.FieldReceivers]
	return ok
}

// ResetReceivers resets all changes to the "receivers" field.
func (m *OrderSharingMutation) ResetReceivers() {
	m.receivers = nil
	m.appendreceivers = nil
	delete(m.clearedFields, ordersharing.FieldReceivers)
}

// SetState sets the "state" field.
func (m *OrderSharingMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OrderSharingMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OrderSharingMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OrderSharingMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OrderSharingMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetRemark sets the "remark" field.
func (m *OrderSharingMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderSharingMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderSharingMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OrderSharingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderSharingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderSharingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderSharingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderSharingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderSharing entity.
// If the OrderSharing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSharingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderSharingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSharingMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[ordersharing.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSharingMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSharingMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSharingMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSharingMutation builder.
func (m *OrderSharingMutation) Where(ps ...predicate.OrderSharing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSharingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSharingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSharing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSharingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSharingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSharing).
func (m *OrderSharingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSharingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._order != nil {
		fields = append(fields, ordersharing.FieldOrderID)
	}
	if m.sharing_no != nil {
		fields = append(fields, ordersharing.FieldSharingNo)
	}
	if m.wx_sharing_id != nil {
		fields = append(fields, ordersharing.FieldWxSharingID)
	}
	if m.sharing_amount != nil {
		fields = append(fields, ordersharing.FieldSharingAmount)
	}
	if m.receivers != nil {
		fields = append(fields, ordersharing.FieldReceivers)
	}
	if m.state != nil {
		fields = append(fields, ordersharing.FieldState)
	}
	if m.remark != nil {
		fields = append(fields, ordersharing.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, ordersharing.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ordersharing.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSharingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersharing.FieldOrderID:
		return m.OrderID()
	case ordersharing.FieldSharingNo:
		return m.SharingNo()
	case ordersharing.FieldWxSharingID:
		return m.WxSharingID()
	case ordersharing.FieldSharingAmount:
		return m.SharingAmount()
	case ordersharing.FieldReceivers:
		return m.Receivers()
	case ordersharing.FieldState:
		return m.State()
	case ordersharing.FieldRemark:
		return m.Remark()
	case ordersharing.FieldCreateTime:
		return m.CreateTime()
	case ordersharing.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSharingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersharing.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordersharing.FieldSharingNo:
		return m.OldSharingNo(ctx)
	case ordersharing.FieldWxSharingID:
		return m.OldWxSharingID(ctx)
	case ordersharing.FieldSharingAmount:
		return m.OldSharingAmount(ctx)
	case ordersharing.FieldReceivers:
		return m.OldReceivers(ctx)
	case ordersharing.FieldState:
		return m.OldState(ctx)
	case ordersharing.FieldRemark:
		return m.OldRemark(ctx)
	case ordersharing.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ordersharing.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSharing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSharingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersharing.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordersharing.FieldSharingNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharingNo(v)
		return nil
	case ordersharing.FieldWxSharingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxSharingID(v)
		return nil
	case ordersharing.FieldSharingAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharingAmount(v)
		return nil
	case ordersharing.FieldReceivers:
		v, ok := value.([]types.OrderSharingReceiver)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivers(v)
		return nil
	case ordersharing.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case ordersharing.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case ordersharing.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ordersharing.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSharing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSharingMutation) AddedFields() []string {
	var fields []string
	if m.addsharing_amount != nil {
		fields = append(fields, ordersharing.FieldSharingAmount)
	}
	if m.addstate != nil {
		fields = append(fields, ordersharing.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSharingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersharing.FieldSharingAmount:
		return m.AddedSharingAmount()
	case ordersharing.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSharingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersharing.FieldSharingAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSharingAmount(v)
		return nil
	case ordersharing.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSharing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSharingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersharing.FieldReceivers) {
		fields = append(fields, ordersharing.FieldReceivers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSharingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSharingMutation) ClearField(name string) error {
	switch name {
	case ordersharing.FieldReceivers:
		m.ClearReceivers()
		return nil
	}
	return fmt.Errorf("unknown OrderSharing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSharingMutation) ResetField(name string) error {
	switch name {
	case ordersharing.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordersharing.FieldSharingNo:
		m.ResetSharingNo()
		return nil
	case ordersharing.FieldWxSharingID:
		m.ResetWxSharingID()
		return nil
	case ordersharing.FieldSharingAmount:
		m.ResetSharingAmount()
		return nil
	case ordersharing.FieldReceivers:
		m.ResetReceivers()
		return nil
	case ordersharing.FieldState:
		m.ResetState()
		return nil
	case ordersharing.FieldRemark:
		m.ResetRemark()
		return nil
	case ordersharing.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ordersharing.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderSharing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSharingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersharing.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSharingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersharing.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSharingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSharingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSharingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersharing.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSharingMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersharing.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSharingMutation) ClearEdge(name string) error {
	switch name {
	case ordersharing.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSharing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSharingMutation) ResetEdge(name string) error {
	switch name {
	case ordersharing.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSharing edge %s", name)
}

// OtaBtreeMutation represents an operation that mutates the OtaBtree nodes in the graph.
type OtaBtreeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	delete_time   *time.Time
	file_id       *int
	addfile_id    *int
	name          *string
	remark        *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OtaBtree, error)
	predicates    []predicate.OtaBtree
}

var _ ent.Mutation = (*OtaBtreeMutation)(nil)

// otabtreeOption allows management of the mutation configuration using functional options.
type otabtreeOption func(*OtaBtreeMutation)

// newOtaBtreeMutation creates new mutation for the OtaBtree entity.
func newOtaBtreeMutation(c config, op Op, opts ...otabtreeOption) *OtaBtreeMutation {
	m := &OtaBtreeMutation{
		config:        c,
		op:            op,
		typ:           TypeOtaBtree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOtaBtreeID sets the ID field of the mutation.
func withOtaBtreeID(id int) otabtreeOption {
	return func(m *OtaBtreeMutation) {
		var (
			err   error
			once  sync.Once
			value *OtaBtree
		)
		m.oldValue = func(ctx context.Context) (*OtaBtree, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OtaBtree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOtaBtree sets the old OtaBtree of the mutation.
func withOtaBtree(node *OtaBtree) otabtreeOption {
	return func(m *OtaBtreeMutation) {
		m.oldValue = func(context.Context) (*OtaBtree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OtaBtreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OtaBtreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OtaBtree entities.
func (m *OtaBtreeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OtaBtreeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OtaBtreeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OtaBtree.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *OtaBtreeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OtaBtreeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OtaBtreeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[otabtree.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OtaBtreeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[otabtree.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OtaBtreeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, otabtree.FieldDeleteTime)
}

// SetFileID sets the "file_id" field.
func (m *OtaBtreeMutation) SetFileID(i int) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *OtaBtreeMutation) FileID() (r int, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *OtaBtreeMutation) AddFileID(i int) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *OtaBtreeMutation) AddedFileID() (r int, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *OtaBtreeMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetName sets the "name" field.
func (m *OtaBtreeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OtaBtreeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OtaBtreeMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *OtaBtreeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OtaBtreeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *OtaBtreeMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OtaBtreeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OtaBtreeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OtaBtreeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OtaBtreeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OtaBtreeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OtaBtree entity.
// If the OtaBtree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaBtreeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OtaBtreeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OtaBtreeMutation builder.
func (m *OtaBtreeMutation) Where(ps ...predicate.OtaBtree) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OtaBtreeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OtaBtreeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OtaBtree, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OtaBtreeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OtaBtreeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OtaBtree).
func (m *OtaBtreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OtaBtreeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.delete_time != nil {
		fields = append(fields, otabtree.FieldDeleteTime)
	}
	if m.file_id != nil {
		fields = append(fields, otabtree.FieldFileID)
	}
	if m.name != nil {
		fields = append(fields, otabtree.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, otabtree.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, otabtree.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, otabtree.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OtaBtreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otabtree.FieldDeleteTime:
		return m.DeleteTime()
	case otabtree.FieldFileID:
		return m.FileID()
	case otabtree.FieldName:
		return m.Name()
	case otabtree.FieldRemark:
		return m.Remark()
	case otabtree.FieldCreateTime:
		return m.CreateTime()
	case otabtree.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OtaBtreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otabtree.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case otabtree.FieldFileID:
		return m.OldFileID(ctx)
	case otabtree.FieldName:
		return m.OldName(ctx)
	case otabtree.FieldRemark:
		return m.OldRemark(ctx)
	case otabtree.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case otabtree.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OtaBtree field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaBtreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otabtree.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case otabtree.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case otabtree.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case otabtree.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case otabtree.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case otabtree.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OtaBtree field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OtaBtreeMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, otabtree.FieldFileID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OtaBtreeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case otabtree.FieldFileID:
		return m.AddedFileID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaBtreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case otabtree.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	}
	return fmt.Errorf("unknown OtaBtree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OtaBtreeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(otabtree.FieldDeleteTime) {
		fields = append(fields, otabtree.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OtaBtreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OtaBtreeMutation) ClearField(name string) error {
	switch name {
	case otabtree.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown OtaBtree nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OtaBtreeMutation) ResetField(name string) error {
	switch name {
	case otabtree.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case otabtree.FieldFileID:
		m.ResetFileID()
		return nil
	case otabtree.FieldName:
		m.ResetName()
		return nil
	case otabtree.FieldRemark:
		m.ResetRemark()
		return nil
	case otabtree.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case otabtree.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OtaBtree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OtaBtreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OtaBtreeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OtaBtreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OtaBtreeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OtaBtreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OtaBtreeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OtaBtreeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OtaBtree unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OtaBtreeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OtaBtree edge %s", name)
}

// OtaDeployMutation represents an operation that mutates the OtaDeploy nodes in the graph.
type OtaDeployMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	delete_time        *time.Time
	uuid               *int64
	adduuid            *int64
	car_id             *int
	addcar_id          *int
	car_name           *string
	device_id          *string
	ota_version_id     *int
	addota_version_id  *int
	ota_version_name   *string
	ota_version_number *string
	state              *int
	addstate           *int
	errmsg             *string
	process            *types.OtaProcess
	create_time        *time.Time
	update_time        *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*OtaDeploy, error)
	predicates         []predicate.OtaDeploy
}

var _ ent.Mutation = (*OtaDeployMutation)(nil)

// otadeployOption allows management of the mutation configuration using functional options.
type otadeployOption func(*OtaDeployMutation)

// newOtaDeployMutation creates new mutation for the OtaDeploy entity.
func newOtaDeployMutation(c config, op Op, opts ...otadeployOption) *OtaDeployMutation {
	m := &OtaDeployMutation{
		config:        c,
		op:            op,
		typ:           TypeOtaDeploy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOtaDeployID sets the ID field of the mutation.
func withOtaDeployID(id int) otadeployOption {
	return func(m *OtaDeployMutation) {
		var (
			err   error
			once  sync.Once
			value *OtaDeploy
		)
		m.oldValue = func(ctx context.Context) (*OtaDeploy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OtaDeploy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOtaDeploy sets the old OtaDeploy of the mutation.
func withOtaDeploy(node *OtaDeploy) otadeployOption {
	return func(m *OtaDeployMutation) {
		m.oldValue = func(context.Context) (*OtaDeploy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OtaDeployMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OtaDeployMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OtaDeploy entities.
func (m *OtaDeployMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OtaDeployMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OtaDeployMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OtaDeploy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *OtaDeployMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OtaDeployMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OtaDeployMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[otadeploy.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OtaDeployMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[otadeploy.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OtaDeployMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, otadeploy.FieldDeleteTime)
}

// SetUUID sets the "uuid" field.
func (m *OtaDeployMutation) SetUUID(i int64) {
	m.uuid = &i
	m.adduuid = nil
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *OtaDeployMutation) UUID() (r int64, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldUUID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// AddUUID adds i to the "uuid" field.
func (m *OtaDeployMutation) AddUUID(i int64) {
	if m.adduuid != nil {
		*m.adduuid += i
	} else {
		m.adduuid = &i
	}
}

// AddedUUID returns the value that was added to the "uuid" field in this mutation.
func (m *OtaDeployMutation) AddedUUID() (r int64, exists bool) {
	v := m.adduuid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUUID resets all changes to the "uuid" field.
func (m *OtaDeployMutation) ResetUUID() {
	m.uuid = nil
	m.adduuid = nil
}

// SetCarID sets the "car_id" field.
func (m *OtaDeployMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *OtaDeployMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *OtaDeployMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *OtaDeployMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *OtaDeployMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetCarName sets the "car_name" field.
func (m *OtaDeployMutation) SetCarName(s string) {
	m.car_name = &s
}

// CarName returns the value of the "car_name" field in the mutation.
func (m *OtaDeployMutation) CarName() (r string, exists bool) {
	v := m.car_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCarName returns the old "car_name" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldCarName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarName: %w", err)
	}
	return oldValue.CarName, nil
}

// ResetCarName resets all changes to the "car_name" field.
func (m *OtaDeployMutation) ResetCarName() {
	m.car_name = nil
}

// SetDeviceID sets the "device_id" field.
func (m *OtaDeployMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *OtaDeployMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *OtaDeployMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetOtaVersionID sets the "ota_version_id" field.
func (m *OtaDeployMutation) SetOtaVersionID(i int) {
	m.ota_version_id = &i
	m.addota_version_id = nil
}

// OtaVersionID returns the value of the "ota_version_id" field in the mutation.
func (m *OtaDeployMutation) OtaVersionID() (r int, exists bool) {
	v := m.ota_version_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOtaVersionID returns the old "ota_version_id" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldOtaVersionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtaVersionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtaVersionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtaVersionID: %w", err)
	}
	return oldValue.OtaVersionID, nil
}

// AddOtaVersionID adds i to the "ota_version_id" field.
func (m *OtaDeployMutation) AddOtaVersionID(i int) {
	if m.addota_version_id != nil {
		*m.addota_version_id += i
	} else {
		m.addota_version_id = &i
	}
}

// AddedOtaVersionID returns the value that was added to the "ota_version_id" field in this mutation.
func (m *OtaDeployMutation) AddedOtaVersionID() (r int, exists bool) {
	v := m.addota_version_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOtaVersionID resets all changes to the "ota_version_id" field.
func (m *OtaDeployMutation) ResetOtaVersionID() {
	m.ota_version_id = nil
	m.addota_version_id = nil
}

// SetOtaVersionName sets the "ota_version_name" field.
func (m *OtaDeployMutation) SetOtaVersionName(s string) {
	m.ota_version_name = &s
}

// OtaVersionName returns the value of the "ota_version_name" field in the mutation.
func (m *OtaDeployMutation) OtaVersionName() (r string, exists bool) {
	v := m.ota_version_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtaVersionName returns the old "ota_version_name" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldOtaVersionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtaVersionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtaVersionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtaVersionName: %w", err)
	}
	return oldValue.OtaVersionName, nil
}

// ResetOtaVersionName resets all changes to the "ota_version_name" field.
func (m *OtaDeployMutation) ResetOtaVersionName() {
	m.ota_version_name = nil
}

// SetOtaVersionNumber sets the "ota_version_number" field.
func (m *OtaDeployMutation) SetOtaVersionNumber(s string) {
	m.ota_version_number = &s
}

// OtaVersionNumber returns the value of the "ota_version_number" field in the mutation.
func (m *OtaDeployMutation) OtaVersionNumber() (r string, exists bool) {
	v := m.ota_version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOtaVersionNumber returns the old "ota_version_number" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldOtaVersionNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtaVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtaVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtaVersionNumber: %w", err)
	}
	return oldValue.OtaVersionNumber, nil
}

// ResetOtaVersionNumber resets all changes to the "ota_version_number" field.
func (m *OtaDeployMutation) ResetOtaVersionNumber() {
	m.ota_version_number = nil
}

// SetState sets the "state" field.
func (m *OtaDeployMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OtaDeployMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OtaDeployMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OtaDeployMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OtaDeployMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetErrmsg sets the "errmsg" field.
func (m *OtaDeployMutation) SetErrmsg(s string) {
	m.errmsg = &s
}

// Errmsg returns the value of the "errmsg" field in the mutation.
func (m *OtaDeployMutation) Errmsg() (r string, exists bool) {
	v := m.errmsg
	if v == nil {
		return
	}
	return *v, true
}

// OldErrmsg returns the old "errmsg" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldErrmsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrmsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrmsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrmsg: %w", err)
	}
	return oldValue.Errmsg, nil
}

// ResetErrmsg resets all changes to the "errmsg" field.
func (m *OtaDeployMutation) ResetErrmsg() {
	m.errmsg = nil
}

// SetProcess sets the "process" field.
func (m *OtaDeployMutation) SetProcess(tp types.OtaProcess) {
	m.process = &tp
}

// Process returns the value of the "process" field in the mutation.
func (m *OtaDeployMutation) Process() (r types.OtaProcess, exists bool) {
	v := m.process
	if v == nil {
		return
	}
	return *v, true
}

// OldProcess returns the old "process" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldProcess(ctx context.Context) (v types.OtaProcess, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcess: %w", err)
	}
	return oldValue.Process, nil
}

// ClearProcess clears the value of the "process" field.
func (m *OtaDeployMutation) ClearProcess() {
	m.process = nil
	m.clearedFields[otadeploy.FieldProcess] = struct{}{}
}

// ProcessCleared returns if the "process" field was cleared in this mutation.
func (m *OtaDeployMutation) ProcessCleared() bool {
	_, ok := m.clearedFields[otadeploy.FieldProcess]
	return ok
}

// ResetProcess resets all changes to the "process" field.
func (m *OtaDeployMutation) ResetProcess() {
	m.process = nil
	delete(m.clearedFields, otadeploy.FieldProcess)
}

// SetCreateTime sets the "create_time" field.
func (m *OtaDeployMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OtaDeployMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OtaDeployMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OtaDeployMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OtaDeployMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OtaDeploy entity.
// If the OtaDeploy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaDeployMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OtaDeployMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OtaDeployMutation builder.
func (m *OtaDeployMutation) Where(ps ...predicate.OtaDeploy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OtaDeployMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OtaDeployMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OtaDeploy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OtaDeployMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OtaDeployMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OtaDeploy).
func (m *OtaDeployMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OtaDeployMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.delete_time != nil {
		fields = append(fields, otadeploy.FieldDeleteTime)
	}
	if m.uuid != nil {
		fields = append(fields, otadeploy.FieldUUID)
	}
	if m.car_id != nil {
		fields = append(fields, otadeploy.FieldCarID)
	}
	if m.car_name != nil {
		fields = append(fields, otadeploy.FieldCarName)
	}
	if m.device_id != nil {
		fields = append(fields, otadeploy.FieldDeviceID)
	}
	if m.ota_version_id != nil {
		fields = append(fields, otadeploy.FieldOtaVersionID)
	}
	if m.ota_version_name != nil {
		fields = append(fields, otadeploy.FieldOtaVersionName)
	}
	if m.ota_version_number != nil {
		fields = append(fields, otadeploy.FieldOtaVersionNumber)
	}
	if m.state != nil {
		fields = append(fields, otadeploy.FieldState)
	}
	if m.errmsg != nil {
		fields = append(fields, otadeploy.FieldErrmsg)
	}
	if m.process != nil {
		fields = append(fields, otadeploy.FieldProcess)
	}
	if m.create_time != nil {
		fields = append(fields, otadeploy.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, otadeploy.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OtaDeployMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otadeploy.FieldDeleteTime:
		return m.DeleteTime()
	case otadeploy.FieldUUID:
		return m.UUID()
	case otadeploy.FieldCarID:
		return m.CarID()
	case otadeploy.FieldCarName:
		return m.CarName()
	case otadeploy.FieldDeviceID:
		return m.DeviceID()
	case otadeploy.FieldOtaVersionID:
		return m.OtaVersionID()
	case otadeploy.FieldOtaVersionName:
		return m.OtaVersionName()
	case otadeploy.FieldOtaVersionNumber:
		return m.OtaVersionNumber()
	case otadeploy.FieldState:
		return m.State()
	case otadeploy.FieldErrmsg:
		return m.Errmsg()
	case otadeploy.FieldProcess:
		return m.Process()
	case otadeploy.FieldCreateTime:
		return m.CreateTime()
	case otadeploy.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OtaDeployMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otadeploy.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case otadeploy.FieldUUID:
		return m.OldUUID(ctx)
	case otadeploy.FieldCarID:
		return m.OldCarID(ctx)
	case otadeploy.FieldCarName:
		return m.OldCarName(ctx)
	case otadeploy.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case otadeploy.FieldOtaVersionID:
		return m.OldOtaVersionID(ctx)
	case otadeploy.FieldOtaVersionName:
		return m.OldOtaVersionName(ctx)
	case otadeploy.FieldOtaVersionNumber:
		return m.OldOtaVersionNumber(ctx)
	case otadeploy.FieldState:
		return m.OldState(ctx)
	case otadeploy.FieldErrmsg:
		return m.OldErrmsg(ctx)
	case otadeploy.FieldProcess:
		return m.OldProcess(ctx)
	case otadeploy.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case otadeploy.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OtaDeploy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaDeployMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otadeploy.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case otadeploy.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case otadeploy.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case otadeploy.FieldCarName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarName(v)
		return nil
	case otadeploy.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case otadeploy.FieldOtaVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtaVersionID(v)
		return nil
	case otadeploy.FieldOtaVersionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtaVersionName(v)
		return nil
	case otadeploy.FieldOtaVersionNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtaVersionNumber(v)
		return nil
	case otadeploy.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case otadeploy.FieldErrmsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrmsg(v)
		return nil
	case otadeploy.FieldProcess:
		v, ok := value.(types.OtaProcess)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcess(v)
		return nil
	case otadeploy.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case otadeploy.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OtaDeploy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OtaDeployMutation) AddedFields() []string {
	var fields []string
	if m.adduuid != nil {
		fields = append(fields, otadeploy.FieldUUID)
	}
	if m.addcar_id != nil {
		fields = append(fields, otadeploy.FieldCarID)
	}
	if m.addota_version_id != nil {
		fields = append(fields, otadeploy.FieldOtaVersionID)
	}
	if m.addstate != nil {
		fields = append(fields, otadeploy.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OtaDeployMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case otadeploy.FieldUUID:
		return m.AddedUUID()
	case otadeploy.FieldCarID:
		return m.AddedCarID()
	case otadeploy.FieldOtaVersionID:
		return m.AddedOtaVersionID()
	case otadeploy.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaDeployMutation) AddField(name string, value ent.Value) error {
	switch name {
	case otadeploy.FieldUUID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUUID(v)
		return nil
	case otadeploy.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case otadeploy.FieldOtaVersionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtaVersionID(v)
		return nil
	case otadeploy.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown OtaDeploy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OtaDeployMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(otadeploy.FieldDeleteTime) {
		fields = append(fields, otadeploy.FieldDeleteTime)
	}
	if m.FieldCleared(otadeploy.FieldProcess) {
		fields = append(fields, otadeploy.FieldProcess)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OtaDeployMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OtaDeployMutation) ClearField(name string) error {
	switch name {
	case otadeploy.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case otadeploy.FieldProcess:
		m.ClearProcess()
		return nil
	}
	return fmt.Errorf("unknown OtaDeploy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OtaDeployMutation) ResetField(name string) error {
	switch name {
	case otadeploy.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case otadeploy.FieldUUID:
		m.ResetUUID()
		return nil
	case otadeploy.FieldCarID:
		m.ResetCarID()
		return nil
	case otadeploy.FieldCarName:
		m.ResetCarName()
		return nil
	case otadeploy.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case otadeploy.FieldOtaVersionID:
		m.ResetOtaVersionID()
		return nil
	case otadeploy.FieldOtaVersionName:
		m.ResetOtaVersionName()
		return nil
	case otadeploy.FieldOtaVersionNumber:
		m.ResetOtaVersionNumber()
		return nil
	case otadeploy.FieldState:
		m.ResetState()
		return nil
	case otadeploy.FieldErrmsg:
		m.ResetErrmsg()
		return nil
	case otadeploy.FieldProcess:
		m.ResetProcess()
		return nil
	case otadeploy.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case otadeploy.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OtaDeploy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OtaDeployMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OtaDeployMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OtaDeployMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OtaDeployMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OtaDeployMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OtaDeployMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OtaDeployMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OtaDeploy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OtaDeployMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OtaDeploy edge %s", name)
}

// OtaVersionMutation represents an operation that mutates the OtaVersion nodes in the graph.
type OtaVersionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	delete_time       *time.Time
	scenic_area_id    *int
	addscenic_area_id *int
	model_id          *int
	addmodel_id       *int
	name              *string
	version           *string
	content           *types.OtaContent
	state             *int
	addstate          *int
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*OtaVersion, error)
	predicates        []predicate.OtaVersion
}

var _ ent.Mutation = (*OtaVersionMutation)(nil)

// otaversionOption allows management of the mutation configuration using functional options.
type otaversionOption func(*OtaVersionMutation)

// newOtaVersionMutation creates new mutation for the OtaVersion entity.
func newOtaVersionMutation(c config, op Op, opts ...otaversionOption) *OtaVersionMutation {
	m := &OtaVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeOtaVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOtaVersionID sets the ID field of the mutation.
func withOtaVersionID(id int) otaversionOption {
	return func(m *OtaVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *OtaVersion
		)
		m.oldValue = func(ctx context.Context) (*OtaVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OtaVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOtaVersion sets the old OtaVersion of the mutation.
func withOtaVersion(node *OtaVersion) otaversionOption {
	return func(m *OtaVersionMutation) {
		m.oldValue = func(context.Context) (*OtaVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OtaVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OtaVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OtaVersion entities.
func (m *OtaVersionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OtaVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OtaVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OtaVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *OtaVersionMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OtaVersionMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OtaVersionMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[otaversion.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OtaVersionMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[otaversion.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OtaVersionMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, otaversion.FieldDeleteTime)
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *OtaVersionMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *OtaVersionMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *OtaVersionMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *OtaVersionMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *OtaVersionMutation) ClearScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	m.clearedFields[otaversion.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *OtaVersionMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[otaversion.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *OtaVersionMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	delete(m.clearedFields, otaversion.FieldScenicAreaID)
}

// SetModelID sets the "model_id" field.
func (m *OtaVersionMutation) SetModelID(i int) {
	m.model_id = &i
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *OtaVersionMutation) ModelID() (r int, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldModelID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds i to the "model_id" field.
func (m *OtaVersionMutation) AddModelID(i int) {
	if m.addmodel_id != nil {
		*m.addmodel_id += i
	} else {
		m.addmodel_id = &i
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *OtaVersionMutation) AddedModelID() (r int, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearModelID clears the value of the "model_id" field.
func (m *OtaVersionMutation) ClearModelID() {
	m.model_id = nil
	m.addmodel_id = nil
	m.clearedFields[otaversion.FieldModelID] = struct{}{}
}

// ModelIDCleared returns if the "model_id" field was cleared in this mutation.
func (m *OtaVersionMutation) ModelIDCleared() bool {
	_, ok := m.clearedFields[otaversion.FieldModelID]
	return ok
}

// ResetModelID resets all changes to the "model_id" field.
func (m *OtaVersionMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
	delete(m.clearedFields, otaversion.FieldModelID)
}

// SetName sets the "name" field.
func (m *OtaVersionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OtaVersionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OtaVersionMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *OtaVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *OtaVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *OtaVersionMutation) ResetVersion() {
	m.version = nil
}

// SetContent sets the "content" field.
func (m *OtaVersionMutation) SetContent(tc types.OtaContent) {
	m.content = &tc
}

// Content returns the value of the "content" field in the mutation.
func (m *OtaVersionMutation) Content() (r types.OtaContent, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldContent(ctx context.Context) (v types.OtaContent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *OtaVersionMutation) ResetContent() {
	m.content = nil
}

// SetState sets the "state" field.
func (m *OtaVersionMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *OtaVersionMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *OtaVersionMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *OtaVersionMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *OtaVersionMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OtaVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OtaVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OtaVersionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OtaVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OtaVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OtaVersion entity.
// If the OtaVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtaVersionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OtaVersionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OtaVersionMutation builder.
func (m *OtaVersionMutation) Where(ps ...predicate.OtaVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OtaVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OtaVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OtaVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OtaVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OtaVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OtaVersion).
func (m *OtaVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OtaVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.delete_time != nil {
		fields = append(fields, otaversion.FieldDeleteTime)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, otaversion.FieldScenicAreaID)
	}
	if m.model_id != nil {
		fields = append(fields, otaversion.FieldModelID)
	}
	if m.name != nil {
		fields = append(fields, otaversion.FieldName)
	}
	if m.version != nil {
		fields = append(fields, otaversion.FieldVersion)
	}
	if m.content != nil {
		fields = append(fields, otaversion.FieldContent)
	}
	if m.state != nil {
		fields = append(fields, otaversion.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, otaversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, otaversion.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OtaVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otaversion.FieldDeleteTime:
		return m.DeleteTime()
	case otaversion.FieldScenicAreaID:
		return m.ScenicAreaID()
	case otaversion.FieldModelID:
		return m.ModelID()
	case otaversion.FieldName:
		return m.Name()
	case otaversion.FieldVersion:
		return m.Version()
	case otaversion.FieldContent:
		return m.Content()
	case otaversion.FieldState:
		return m.State()
	case otaversion.FieldCreateTime:
		return m.CreateTime()
	case otaversion.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OtaVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otaversion.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case otaversion.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case otaversion.FieldModelID:
		return m.OldModelID(ctx)
	case otaversion.FieldName:
		return m.OldName(ctx)
	case otaversion.FieldVersion:
		return m.OldVersion(ctx)
	case otaversion.FieldContent:
		return m.OldContent(ctx)
	case otaversion.FieldState:
		return m.OldState(ctx)
	case otaversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case otaversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OtaVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otaversion.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case otaversion.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case otaversion.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case otaversion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case otaversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case otaversion.FieldContent:
		v, ok := value.(types.OtaContent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case otaversion.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case otaversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case otaversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OtaVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OtaVersionMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, otaversion.FieldScenicAreaID)
	}
	if m.addmodel_id != nil {
		fields = append(fields, otaversion.FieldModelID)
	}
	if m.addstate != nil {
		fields = append(fields, otaversion.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OtaVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case otaversion.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case otaversion.FieldModelID:
		return m.AddedModelID()
	case otaversion.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtaVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case otaversion.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case otaversion.FieldModelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case otaversion.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown OtaVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OtaVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(otaversion.FieldDeleteTime) {
		fields = append(fields, otaversion.FieldDeleteTime)
	}
	if m.FieldCleared(otaversion.FieldScenicAreaID) {
		fields = append(fields, otaversion.FieldScenicAreaID)
	}
	if m.FieldCleared(otaversion.FieldModelID) {
		fields = append(fields, otaversion.FieldModelID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OtaVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OtaVersionMutation) ClearField(name string) error {
	switch name {
	case otaversion.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case otaversion.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case otaversion.FieldModelID:
		m.ClearModelID()
		return nil
	}
	return fmt.Errorf("unknown OtaVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OtaVersionMutation) ResetField(name string) error {
	switch name {
	case otaversion.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case otaversion.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case otaversion.FieldModelID:
		m.ResetModelID()
		return nil
	case otaversion.FieldName:
		m.ResetName()
		return nil
	case otaversion.FieldVersion:
		m.ResetVersion()
		return nil
	case otaversion.FieldContent:
		m.ResetContent()
		return nil
	case otaversion.FieldState:
		m.ResetState()
		return nil
	case otaversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case otaversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OtaVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OtaVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OtaVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OtaVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OtaVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OtaVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OtaVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OtaVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OtaVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OtaVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OtaVersion edge %s", name)
}

// PayTxBillMutation represents an operation that mutates the PayTxBill nodes in the graph.
type PayTxBillMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	tx_id                         *string
	order_id                      *int
	addorder_id                   *int
	order_no                      *string
	scenic_area_name              *string
	tx_type                       *int
	addtx_type                    *int
	tx_channel                    *int
	addtx_channel                 *int
	tx_account                    *string
	tx_account_name               *string
	tx_amount                     *int
	addtx_amount                  *int
	tx_time                       *time.Time
	remark                        *string
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*PayTxBill, error)
	predicates                    []predicate.PayTxBill
}

var _ ent.Mutation = (*PayTxBillMutation)(nil)

// paytxbillOption allows management of the mutation configuration using functional options.
type paytxbillOption func(*PayTxBillMutation)

// newPayTxBillMutation creates new mutation for the PayTxBill entity.
func newPayTxBillMutation(c config, op Op, opts ...paytxbillOption) *PayTxBillMutation {
	m := &PayTxBillMutation{
		config:        c,
		op:            op,
		typ:           TypePayTxBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayTxBillID sets the ID field of the mutation.
func withPayTxBillID(id int) paytxbillOption {
	return func(m *PayTxBillMutation) {
		var (
			err   error
			once  sync.Once
			value *PayTxBill
		)
		m.oldValue = func(ctx context.Context) (*PayTxBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayTxBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayTxBill sets the old PayTxBill of the mutation.
func withPayTxBill(node *PayTxBill) paytxbillOption {
	return func(m *PayTxBillMutation) {
		m.oldValue = func(context.Context) (*PayTxBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayTxBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayTxBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PayTxBill entities.
func (m *PayTxBillMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayTxBillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayTxBillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PayTxBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTxID sets the "tx_id" field.
func (m *PayTxBillMutation) SetTxID(s string) {
	m.tx_id = &s
}

// TxID returns the value of the "tx_id" field in the mutation.
func (m *PayTxBillMutation) TxID() (r string, exists bool) {
	v := m.tx_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTxID returns the old "tx_id" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxID: %w", err)
	}
	return oldValue.TxID, nil
}

// ResetTxID resets all changes to the "tx_id" field.
func (m *PayTxBillMutation) ResetTxID() {
	m.tx_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *PayTxBillMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PayTxBillMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *PayTxBillMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *PayTxBillMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PayTxBillMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetOrderNo sets the "order_no" field.
func (m *PayTxBillMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *PayTxBillMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *PayTxBillMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *PayTxBillMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *PayTxBillMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *PayTxBillMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetScenicAreaName sets the "scenic_area_name" field.
func (m *PayTxBillMutation) SetScenicAreaName(s string) {
	m.scenic_area_name = &s
}

// ScenicAreaName returns the value of the "scenic_area_name" field in the mutation.
func (m *PayTxBillMutation) ScenicAreaName() (r string, exists bool) {
	v := m.scenic_area_name
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaName returns the old "scenic_area_name" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldScenicAreaName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaName: %w", err)
	}
	return oldValue.ScenicAreaName, nil
}

// ResetScenicAreaName resets all changes to the "scenic_area_name" field.
func (m *PayTxBillMutation) ResetScenicAreaName() {
	m.scenic_area_name = nil
}

// SetTxType sets the "tx_type" field.
func (m *PayTxBillMutation) SetTxType(i int) {
	m.tx_type = &i
	m.addtx_type = nil
}

// TxType returns the value of the "tx_type" field in the mutation.
func (m *PayTxBillMutation) TxType() (r int, exists bool) {
	v := m.tx_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTxType returns the old "tx_type" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxType: %w", err)
	}
	return oldValue.TxType, nil
}

// AddTxType adds i to the "tx_type" field.
func (m *PayTxBillMutation) AddTxType(i int) {
	if m.addtx_type != nil {
		*m.addtx_type += i
	} else {
		m.addtx_type = &i
	}
}

// AddedTxType returns the value that was added to the "tx_type" field in this mutation.
func (m *PayTxBillMutation) AddedTxType() (r int, exists bool) {
	v := m.addtx_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetTxType resets all changes to the "tx_type" field.
func (m *PayTxBillMutation) ResetTxType() {
	m.tx_type = nil
	m.addtx_type = nil
}

// SetTxChannel sets the "tx_channel" field.
func (m *PayTxBillMutation) SetTxChannel(i int) {
	m.tx_channel = &i
	m.addtx_channel = nil
}

// TxChannel returns the value of the "tx_channel" field in the mutation.
func (m *PayTxBillMutation) TxChannel() (r int, exists bool) {
	v := m.tx_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldTxChannel returns the old "tx_channel" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxChannel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxChannel: %w", err)
	}
	return oldValue.TxChannel, nil
}

// AddTxChannel adds i to the "tx_channel" field.
func (m *PayTxBillMutation) AddTxChannel(i int) {
	if m.addtx_channel != nil {
		*m.addtx_channel += i
	} else {
		m.addtx_channel = &i
	}
}

// AddedTxChannel returns the value that was added to the "tx_channel" field in this mutation.
func (m *PayTxBillMutation) AddedTxChannel() (r int, exists bool) {
	v := m.addtx_channel
	if v == nil {
		return
	}
	return *v, true
}

// ResetTxChannel resets all changes to the "tx_channel" field.
func (m *PayTxBillMutation) ResetTxChannel() {
	m.tx_channel = nil
	m.addtx_channel = nil
}

// SetTxAccount sets the "tx_account" field.
func (m *PayTxBillMutation) SetTxAccount(s string) {
	m.tx_account = &s
}

// TxAccount returns the value of the "tx_account" field in the mutation.
func (m *PayTxBillMutation) TxAccount() (r string, exists bool) {
	v := m.tx_account
	if v == nil {
		return
	}
	return *v, true
}

// OldTxAccount returns the old "tx_account" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxAccount: %w", err)
	}
	return oldValue.TxAccount, nil
}

// ResetTxAccount resets all changes to the "tx_account" field.
func (m *PayTxBillMutation) ResetTxAccount() {
	m.tx_account = nil
}

// SetTxAccountName sets the "tx_account_name" field.
func (m *PayTxBillMutation) SetTxAccountName(s string) {
	m.tx_account_name = &s
}

// TxAccountName returns the value of the "tx_account_name" field in the mutation.
func (m *PayTxBillMutation) TxAccountName() (r string, exists bool) {
	v := m.tx_account_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTxAccountName returns the old "tx_account_name" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxAccountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxAccountName: %w", err)
	}
	return oldValue.TxAccountName, nil
}

// ResetTxAccountName resets all changes to the "tx_account_name" field.
func (m *PayTxBillMutation) ResetTxAccountName() {
	m.tx_account_name = nil
}

// SetTxAmount sets the "tx_amount" field.
func (m *PayTxBillMutation) SetTxAmount(i int) {
	m.tx_amount = &i
	m.addtx_amount = nil
}

// TxAmount returns the value of the "tx_amount" field in the mutation.
func (m *PayTxBillMutation) TxAmount() (r int, exists bool) {
	v := m.tx_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTxAmount returns the old "tx_amount" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxAmount: %w", err)
	}
	return oldValue.TxAmount, nil
}

// AddTxAmount adds i to the "tx_amount" field.
func (m *PayTxBillMutation) AddTxAmount(i int) {
	if m.addtx_amount != nil {
		*m.addtx_amount += i
	} else {
		m.addtx_amount = &i
	}
}

// AddedTxAmount returns the value that was added to the "tx_amount" field in this mutation.
func (m *PayTxBillMutation) AddedTxAmount() (r int, exists bool) {
	v := m.addtx_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTxAmount resets all changes to the "tx_amount" field.
func (m *PayTxBillMutation) ResetTxAmount() {
	m.tx_amount = nil
	m.addtx_amount = nil
}

// SetTxTime sets the "tx_time" field.
func (m *PayTxBillMutation) SetTxTime(t time.Time) {
	m.tx_time = &t
}

// TxTime returns the value of the "tx_time" field in the mutation.
func (m *PayTxBillMutation) TxTime() (r time.Time, exists bool) {
	v := m.tx_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTxTime returns the old "tx_time" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldTxTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxTime: %w", err)
	}
	return oldValue.TxTime, nil
}

// ResetTxTime resets all changes to the "tx_time" field.
func (m *PayTxBillMutation) ResetTxTime() {
	m.tx_time = nil
}

// SetRemark sets the "remark" field.
func (m *PayTxBillMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PayTxBillMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *PayTxBillMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *PayTxBillMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PayTxBillMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PayTxBillMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PayTxBillMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PayTxBillMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PayTxBill entity.
// If the PayTxBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayTxBillMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PayTxBillMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *PayTxBillMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *PayTxBillMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[paytxbill.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *PayTxBillMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *PayTxBillMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *PayTxBillMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *PayTxBillMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the PayTxBillMutation builder.
func (m *PayTxBillMutation) Where(ps ...predicate.PayTxBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayTxBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayTxBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PayTxBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayTxBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayTxBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PayTxBill).
func (m *PayTxBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayTxBillMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.tx_id != nil {
		fields = append(fields, paytxbill.FieldTxID)
	}
	if m.order_id != nil {
		fields = append(fields, paytxbill.FieldOrderID)
	}
	if m.order_no != nil {
		fields = append(fields, paytxbill.FieldOrderNo)
	}
	if m.background_scenic_area != nil {
		fields = append(fields, paytxbill.FieldScenicAreaID)
	}
	if m.scenic_area_name != nil {
		fields = append(fields, paytxbill.FieldScenicAreaName)
	}
	if m.tx_type != nil {
		fields = append(fields, paytxbill.FieldTxType)
	}
	if m.tx_channel != nil {
		fields = append(fields, paytxbill.FieldTxChannel)
	}
	if m.tx_account != nil {
		fields = append(fields, paytxbill.FieldTxAccount)
	}
	if m.tx_account_name != nil {
		fields = append(fields, paytxbill.FieldTxAccountName)
	}
	if m.tx_amount != nil {
		fields = append(fields, paytxbill.FieldTxAmount)
	}
	if m.tx_time != nil {
		fields = append(fields, paytxbill.FieldTxTime)
	}
	if m.remark != nil {
		fields = append(fields, paytxbill.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, paytxbill.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, paytxbill.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayTxBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paytxbill.FieldTxID:
		return m.TxID()
	case paytxbill.FieldOrderID:
		return m.OrderID()
	case paytxbill.FieldOrderNo:
		return m.OrderNo()
	case paytxbill.FieldScenicAreaID:
		return m.ScenicAreaID()
	case paytxbill.FieldScenicAreaName:
		return m.ScenicAreaName()
	case paytxbill.FieldTxType:
		return m.TxType()
	case paytxbill.FieldTxChannel:
		return m.TxChannel()
	case paytxbill.FieldTxAccount:
		return m.TxAccount()
	case paytxbill.FieldTxAccountName:
		return m.TxAccountName()
	case paytxbill.FieldTxAmount:
		return m.TxAmount()
	case paytxbill.FieldTxTime:
		return m.TxTime()
	case paytxbill.FieldRemark:
		return m.Remark()
	case paytxbill.FieldCreateTime:
		return m.CreateTime()
	case paytxbill.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayTxBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paytxbill.FieldTxID:
		return m.OldTxID(ctx)
	case paytxbill.FieldOrderID:
		return m.OldOrderID(ctx)
	case paytxbill.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case paytxbill.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case paytxbill.FieldScenicAreaName:
		return m.OldScenicAreaName(ctx)
	case paytxbill.FieldTxType:
		return m.OldTxType(ctx)
	case paytxbill.FieldTxChannel:
		return m.OldTxChannel(ctx)
	case paytxbill.FieldTxAccount:
		return m.OldTxAccount(ctx)
	case paytxbill.FieldTxAccountName:
		return m.OldTxAccountName(ctx)
	case paytxbill.FieldTxAmount:
		return m.OldTxAmount(ctx)
	case paytxbill.FieldTxTime:
		return m.OldTxTime(ctx)
	case paytxbill.FieldRemark:
		return m.OldRemark(ctx)
	case paytxbill.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case paytxbill.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PayTxBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayTxBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paytxbill.FieldTxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxID(v)
		return nil
	case paytxbill.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case paytxbill.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case paytxbill.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case paytxbill.FieldScenicAreaName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaName(v)
		return nil
	case paytxbill.FieldTxType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxType(v)
		return nil
	case paytxbill.FieldTxChannel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxChannel(v)
		return nil
	case paytxbill.FieldTxAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxAccount(v)
		return nil
	case paytxbill.FieldTxAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxAccountName(v)
		return nil
	case paytxbill.FieldTxAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxAmount(v)
		return nil
	case paytxbill.FieldTxTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxTime(v)
		return nil
	case paytxbill.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case paytxbill.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case paytxbill.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PayTxBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayTxBillMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, paytxbill.FieldOrderID)
	}
	if m.addtx_type != nil {
		fields = append(fields, paytxbill.FieldTxType)
	}
	if m.addtx_channel != nil {
		fields = append(fields, paytxbill.FieldTxChannel)
	}
	if m.addtx_amount != nil {
		fields = append(fields, paytxbill.FieldTxAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayTxBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paytxbill.FieldOrderID:
		return m.AddedOrderID()
	case paytxbill.FieldTxType:
		return m.AddedTxType()
	case paytxbill.FieldTxChannel:
		return m.AddedTxChannel()
	case paytxbill.FieldTxAmount:
		return m.AddedTxAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayTxBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paytxbill.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case paytxbill.FieldTxType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxType(v)
		return nil
	case paytxbill.FieldTxChannel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxChannel(v)
		return nil
	case paytxbill.FieldTxAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTxAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PayTxBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayTxBillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayTxBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayTxBillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PayTxBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayTxBillMutation) ResetField(name string) error {
	switch name {
	case paytxbill.FieldTxID:
		m.ResetTxID()
		return nil
	case paytxbill.FieldOrderID:
		m.ResetOrderID()
		return nil
	case paytxbill.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case paytxbill.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case paytxbill.FieldScenicAreaName:
		m.ResetScenicAreaName()
		return nil
	case paytxbill.FieldTxType:
		m.ResetTxType()
		return nil
	case paytxbill.FieldTxChannel:
		m.ResetTxChannel()
		return nil
	case paytxbill.FieldTxAccount:
		m.ResetTxAccount()
		return nil
	case paytxbill.FieldTxAccountName:
		m.ResetTxAccountName()
		return nil
	case paytxbill.FieldTxAmount:
		m.ResetTxAmount()
		return nil
	case paytxbill.FieldTxTime:
		m.ResetTxTime()
		return nil
	case paytxbill.FieldRemark:
		m.ResetRemark()
		return nil
	case paytxbill.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case paytxbill.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PayTxBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayTxBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, paytxbill.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayTxBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paytxbill.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayTxBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayTxBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayTxBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, paytxbill.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayTxBillMutation) EdgeCleared(name string) bool {
	switch name {
	case paytxbill.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayTxBillMutation) ClearEdge(name string) error {
	switch name {
	case paytxbill.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown PayTxBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayTxBillMutation) ResetEdge(name string) error {
	switch name {
	case paytxbill.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown PayTxBill edge %s", name)
}

// PaymentAccountMutation represents an operation that mutates the PaymentAccount nodes in the graph.
type PaymentAccountMutation struct {
	config
	op              Op
	typ             string
	id              *int
	mch_name        *string
	mch_id          *string
	mch_cert_sn     *string
	mch_apiv3_key   *string
	mch_private_key *string
	create_time     *time.Time
	update_time     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PaymentAccount, error)
	predicates      []predicate.PaymentAccount
}

var _ ent.Mutation = (*PaymentAccountMutation)(nil)

// paymentaccountOption allows management of the mutation configuration using functional options.
type paymentaccountOption func(*PaymentAccountMutation)

// newPaymentAccountMutation creates new mutation for the PaymentAccount entity.
func newPaymentAccountMutation(c config, op Op, opts ...paymentaccountOption) *PaymentAccountMutation {
	m := &PaymentAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentAccountID sets the ID field of the mutation.
func withPaymentAccountID(id int) paymentaccountOption {
	return func(m *PaymentAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentAccount
		)
		m.oldValue = func(ctx context.Context) (*PaymentAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentAccount sets the old PaymentAccount of the mutation.
func withPaymentAccount(node *PaymentAccount) paymentaccountOption {
	return func(m *PaymentAccountMutation) {
		m.oldValue = func(context.Context) (*PaymentAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentAccount entities.
func (m *PaymentAccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMchName sets the "mch_name" field.
func (m *PaymentAccountMutation) SetMchName(s string) {
	m.mch_name = &s
}

// MchName returns the value of the "mch_name" field in the mutation.
func (m *PaymentAccountMutation) MchName() (r string, exists bool) {
	v := m.mch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMchName returns the old "mch_name" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldMchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchName: %w", err)
	}
	return oldValue.MchName, nil
}

// ResetMchName resets all changes to the "mch_name" field.
func (m *PaymentAccountMutation) ResetMchName() {
	m.mch_name = nil
}

// SetMchID sets the "mch_id" field.
func (m *PaymentAccountMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *PaymentAccountMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *PaymentAccountMutation) ResetMchID() {
	m.mch_id = nil
}

// SetMchCertSn sets the "mch_cert_sn" field.
func (m *PaymentAccountMutation) SetMchCertSn(s string) {
	m.mch_cert_sn = &s
}

// MchCertSn returns the value of the "mch_cert_sn" field in the mutation.
func (m *PaymentAccountMutation) MchCertSn() (r string, exists bool) {
	v := m.mch_cert_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldMchCertSn returns the old "mch_cert_sn" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldMchCertSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchCertSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchCertSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchCertSn: %w", err)
	}
	return oldValue.MchCertSn, nil
}

// ResetMchCertSn resets all changes to the "mch_cert_sn" field.
func (m *PaymentAccountMutation) ResetMchCertSn() {
	m.mch_cert_sn = nil
}

// SetMchApiv3Key sets the "mch_apiv3_key" field.
func (m *PaymentAccountMutation) SetMchApiv3Key(s string) {
	m.mch_apiv3_key = &s
}

// MchApiv3Key returns the value of the "mch_apiv3_key" field in the mutation.
func (m *PaymentAccountMutation) MchApiv3Key() (r string, exists bool) {
	v := m.mch_apiv3_key
	if v == nil {
		return
	}
	return *v, true
}

// OldMchApiv3Key returns the old "mch_apiv3_key" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldMchApiv3Key(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchApiv3Key is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchApiv3Key requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchApiv3Key: %w", err)
	}
	return oldValue.MchApiv3Key, nil
}

// ResetMchApiv3Key resets all changes to the "mch_apiv3_key" field.
func (m *PaymentAccountMutation) ResetMchApiv3Key() {
	m.mch_apiv3_key = nil
}

// SetMchPrivateKey sets the "mch_private_key" field.
func (m *PaymentAccountMutation) SetMchPrivateKey(s string) {
	m.mch_private_key = &s
}

// MchPrivateKey returns the value of the "mch_private_key" field in the mutation.
func (m *PaymentAccountMutation) MchPrivateKey() (r string, exists bool) {
	v := m.mch_private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldMchPrivateKey returns the old "mch_private_key" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldMchPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchPrivateKey: %w", err)
	}
	return oldValue.MchPrivateKey, nil
}

// ResetMchPrivateKey resets all changes to the "mch_private_key" field.
func (m *PaymentAccountMutation) ResetMchPrivateKey() {
	m.mch_private_key = nil
}

// SetCreateTime sets the "create_time" field.
func (m *PaymentAccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PaymentAccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PaymentAccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PaymentAccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PaymentAccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PaymentAccount entity.
// If the PaymentAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentAccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PaymentAccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the PaymentAccountMutation builder.
func (m *PaymentAccountMutation) Where(ps ...predicate.PaymentAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentAccount).
func (m *PaymentAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentAccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.mch_name != nil {
		fields = append(fields, paymentaccount.FieldMchName)
	}
	if m.mch_id != nil {
		fields = append(fields, paymentaccount.FieldMchID)
	}
	if m.mch_cert_sn != nil {
		fields = append(fields, paymentaccount.FieldMchCertSn)
	}
	if m.mch_apiv3_key != nil {
		fields = append(fields, paymentaccount.FieldMchApiv3Key)
	}
	if m.mch_private_key != nil {
		fields = append(fields, paymentaccount.FieldMchPrivateKey)
	}
	if m.create_time != nil {
		fields = append(fields, paymentaccount.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, paymentaccount.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentaccount.FieldMchName:
		return m.MchName()
	case paymentaccount.FieldMchID:
		return m.MchID()
	case paymentaccount.FieldMchCertSn:
		return m.MchCertSn()
	case paymentaccount.FieldMchApiv3Key:
		return m.MchApiv3Key()
	case paymentaccount.FieldMchPrivateKey:
		return m.MchPrivateKey()
	case paymentaccount.FieldCreateTime:
		return m.CreateTime()
	case paymentaccount.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentaccount.FieldMchName:
		return m.OldMchName(ctx)
	case paymentaccount.FieldMchID:
		return m.OldMchID(ctx)
	case paymentaccount.FieldMchCertSn:
		return m.OldMchCertSn(ctx)
	case paymentaccount.FieldMchApiv3Key:
		return m.OldMchApiv3Key(ctx)
	case paymentaccount.FieldMchPrivateKey:
		return m.OldMchPrivateKey(ctx)
	case paymentaccount.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case paymentaccount.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentaccount.FieldMchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchName(v)
		return nil
	case paymentaccount.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case paymentaccount.FieldMchCertSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchCertSn(v)
		return nil
	case paymentaccount.FieldMchApiv3Key:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchApiv3Key(v)
		return nil
	case paymentaccount.FieldMchPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchPrivateKey(v)
		return nil
	case paymentaccount.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case paymentaccount.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentAccountMutation) ResetField(name string) error {
	switch name {
	case paymentaccount.FieldMchName:
		m.ResetMchName()
		return nil
	case paymentaccount.FieldMchID:
		m.ResetMchID()
		return nil
	case paymentaccount.FieldMchCertSn:
		m.ResetMchCertSn()
		return nil
	case paymentaccount.FieldMchApiv3Key:
		m.ResetMchApiv3Key()
		return nil
	case paymentaccount.FieldMchPrivateKey:
		m.ResetMchPrivateKey()
		return nil
	case paymentaccount.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case paymentaccount.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PaymentAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentAccount edge %s", name)
}

// PoiMutation represents an operation that mutates the Poi nodes in the graph.
type PoiMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	name                          *string
	alias                         *string
	_type                         *int
	add_type                      *int
	wgs_lon                       *float64
	addwgs_lon                    *float64
	wgs_lat                       *float64
	addwgs_lat                    *float64
	gcj_lon                       *float64
	addgcj_lon                    *float64
	gcj_lat                       *float64
	addgcj_lat                    *float64
	bd_lon                        *float64
	addbd_lon                     *float64
	bd_lat                        *float64
	addbd_lat                     *float64
	stop_heading                  *float64
	addstop_heading               *float64
	intro_text                    *string
	image_ids                     *[]int
	appendimage_ids               []int
	audio_id                      *int
	addaudio_id                   *int
	video_id                      *int
	addvideo_id                   *int
	broadcast_radius              *int
	addbroadcast_radius           *int
	parking_radius                *int
	addparking_radius             *int
	level                         *int
	addlevel                      *int
	extend_yokee_id               *int
	addextend_yokee_id            *int
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*Poi, error)
	predicates                    []predicate.Poi
}

var _ ent.Mutation = (*PoiMutation)(nil)

// poiOption allows management of the mutation configuration using functional options.
type poiOption func(*PoiMutation)

// newPoiMutation creates new mutation for the Poi entity.
func newPoiMutation(c config, op Op, opts ...poiOption) *PoiMutation {
	m := &PoiMutation{
		config:        c,
		op:            op,
		typ:           TypePoi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPoiID sets the ID field of the mutation.
func withPoiID(id int) poiOption {
	return func(m *PoiMutation) {
		var (
			err   error
			once  sync.Once
			value *Poi
		)
		m.oldValue = func(ctx context.Context) (*Poi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Poi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPoi sets the old Poi of the mutation.
func withPoi(node *Poi) poiOption {
	return func(m *PoiMutation) {
		m.oldValue = func(context.Context) (*Poi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PoiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PoiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Poi entities.
func (m *PoiMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PoiMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PoiMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Poi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PoiMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PoiMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PoiMutation) ResetName() {
	m.name = nil
}

// SetAlias sets the "alias" field.
func (m *PoiMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *PoiMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *PoiMutation) ResetAlias() {
	m.alias = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *PoiMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *PoiMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *PoiMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetType sets the "type" field.
func (m *PoiMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PoiMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *PoiMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PoiMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PoiMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetWgsLon sets the "wgs_lon" field.
func (m *PoiMutation) SetWgsLon(f float64) {
	m.wgs_lon = &f
	m.addwgs_lon = nil
}

// WgsLon returns the value of the "wgs_lon" field in the mutation.
func (m *PoiMutation) WgsLon() (r float64, exists bool) {
	v := m.wgs_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldWgsLon returns the old "wgs_lon" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldWgsLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWgsLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWgsLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWgsLon: %w", err)
	}
	return oldValue.WgsLon, nil
}

// AddWgsLon adds f to the "wgs_lon" field.
func (m *PoiMutation) AddWgsLon(f float64) {
	if m.addwgs_lon != nil {
		*m.addwgs_lon += f
	} else {
		m.addwgs_lon = &f
	}
}

// AddedWgsLon returns the value that was added to the "wgs_lon" field in this mutation.
func (m *PoiMutation) AddedWgsLon() (r float64, exists bool) {
	v := m.addwgs_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetWgsLon resets all changes to the "wgs_lon" field.
func (m *PoiMutation) ResetWgsLon() {
	m.wgs_lon = nil
	m.addwgs_lon = nil
}

// SetWgsLat sets the "wgs_lat" field.
func (m *PoiMutation) SetWgsLat(f float64) {
	m.wgs_lat = &f
	m.addwgs_lat = nil
}

// WgsLat returns the value of the "wgs_lat" field in the mutation.
func (m *PoiMutation) WgsLat() (r float64, exists bool) {
	v := m.wgs_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldWgsLat returns the old "wgs_lat" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldWgsLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWgsLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWgsLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWgsLat: %w", err)
	}
	return oldValue.WgsLat, nil
}

// AddWgsLat adds f to the "wgs_lat" field.
func (m *PoiMutation) AddWgsLat(f float64) {
	if m.addwgs_lat != nil {
		*m.addwgs_lat += f
	} else {
		m.addwgs_lat = &f
	}
}

// AddedWgsLat returns the value that was added to the "wgs_lat" field in this mutation.
func (m *PoiMutation) AddedWgsLat() (r float64, exists bool) {
	v := m.addwgs_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetWgsLat resets all changes to the "wgs_lat" field.
func (m *PoiMutation) ResetWgsLat() {
	m.wgs_lat = nil
	m.addwgs_lat = nil
}

// SetGcjLon sets the "gcj_lon" field.
func (m *PoiMutation) SetGcjLon(f float64) {
	m.gcj_lon = &f
	m.addgcj_lon = nil
}

// GcjLon returns the value of the "gcj_lon" field in the mutation.
func (m *PoiMutation) GcjLon() (r float64, exists bool) {
	v := m.gcj_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldGcjLon returns the old "gcj_lon" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldGcjLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGcjLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGcjLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGcjLon: %w", err)
	}
	return oldValue.GcjLon, nil
}

// AddGcjLon adds f to the "gcj_lon" field.
func (m *PoiMutation) AddGcjLon(f float64) {
	if m.addgcj_lon != nil {
		*m.addgcj_lon += f
	} else {
		m.addgcj_lon = &f
	}
}

// AddedGcjLon returns the value that was added to the "gcj_lon" field in this mutation.
func (m *PoiMutation) AddedGcjLon() (r float64, exists bool) {
	v := m.addgcj_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetGcjLon resets all changes to the "gcj_lon" field.
func (m *PoiMutation) ResetGcjLon() {
	m.gcj_lon = nil
	m.addgcj_lon = nil
}

// SetGcjLat sets the "gcj_lat" field.
func (m *PoiMutation) SetGcjLat(f float64) {
	m.gcj_lat = &f
	m.addgcj_lat = nil
}

// GcjLat returns the value of the "gcj_lat" field in the mutation.
func (m *PoiMutation) GcjLat() (r float64, exists bool) {
	v := m.gcj_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldGcjLat returns the old "gcj_lat" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldGcjLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGcjLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGcjLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGcjLat: %w", err)
	}
	return oldValue.GcjLat, nil
}

// AddGcjLat adds f to the "gcj_lat" field.
func (m *PoiMutation) AddGcjLat(f float64) {
	if m.addgcj_lat != nil {
		*m.addgcj_lat += f
	} else {
		m.addgcj_lat = &f
	}
}

// AddedGcjLat returns the value that was added to the "gcj_lat" field in this mutation.
func (m *PoiMutation) AddedGcjLat() (r float64, exists bool) {
	v := m.addgcj_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetGcjLat resets all changes to the "gcj_lat" field.
func (m *PoiMutation) ResetGcjLat() {
	m.gcj_lat = nil
	m.addgcj_lat = nil
}

// SetBdLon sets the "bd_lon" field.
func (m *PoiMutation) SetBdLon(f float64) {
	m.bd_lon = &f
	m.addbd_lon = nil
}

// BdLon returns the value of the "bd_lon" field in the mutation.
func (m *PoiMutation) BdLon() (r float64, exists bool) {
	v := m.bd_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldBdLon returns the old "bd_lon" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldBdLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBdLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBdLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBdLon: %w", err)
	}
	return oldValue.BdLon, nil
}

// AddBdLon adds f to the "bd_lon" field.
func (m *PoiMutation) AddBdLon(f float64) {
	if m.addbd_lon != nil {
		*m.addbd_lon += f
	} else {
		m.addbd_lon = &f
	}
}

// AddedBdLon returns the value that was added to the "bd_lon" field in this mutation.
func (m *PoiMutation) AddedBdLon() (r float64, exists bool) {
	v := m.addbd_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetBdLon resets all changes to the "bd_lon" field.
func (m *PoiMutation) ResetBdLon() {
	m.bd_lon = nil
	m.addbd_lon = nil
}

// SetBdLat sets the "bd_lat" field.
func (m *PoiMutation) SetBdLat(f float64) {
	m.bd_lat = &f
	m.addbd_lat = nil
}

// BdLat returns the value of the "bd_lat" field in the mutation.
func (m *PoiMutation) BdLat() (r float64, exists bool) {
	v := m.bd_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldBdLat returns the old "bd_lat" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldBdLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBdLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBdLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBdLat: %w", err)
	}
	return oldValue.BdLat, nil
}

// AddBdLat adds f to the "bd_lat" field.
func (m *PoiMutation) AddBdLat(f float64) {
	if m.addbd_lat != nil {
		*m.addbd_lat += f
	} else {
		m.addbd_lat = &f
	}
}

// AddedBdLat returns the value that was added to the "bd_lat" field in this mutation.
func (m *PoiMutation) AddedBdLat() (r float64, exists bool) {
	v := m.addbd_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetBdLat resets all changes to the "bd_lat" field.
func (m *PoiMutation) ResetBdLat() {
	m.bd_lat = nil
	m.addbd_lat = nil
}

// SetStopHeading sets the "stop_heading" field.
func (m *PoiMutation) SetStopHeading(f float64) {
	m.stop_heading = &f
	m.addstop_heading = nil
}

// StopHeading returns the value of the "stop_heading" field in the mutation.
func (m *PoiMutation) StopHeading() (r float64, exists bool) {
	v := m.stop_heading
	if v == nil {
		return
	}
	return *v, true
}

// OldStopHeading returns the old "stop_heading" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldStopHeading(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopHeading is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopHeading requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopHeading: %w", err)
	}
	return oldValue.StopHeading, nil
}

// AddStopHeading adds f to the "stop_heading" field.
func (m *PoiMutation) AddStopHeading(f float64) {
	if m.addstop_heading != nil {
		*m.addstop_heading += f
	} else {
		m.addstop_heading = &f
	}
}

// AddedStopHeading returns the value that was added to the "stop_heading" field in this mutation.
func (m *PoiMutation) AddedStopHeading() (r float64, exists bool) {
	v := m.addstop_heading
	if v == nil {
		return
	}
	return *v, true
}

// ResetStopHeading resets all changes to the "stop_heading" field.
func (m *PoiMutation) ResetStopHeading() {
	m.stop_heading = nil
	m.addstop_heading = nil
}

// SetIntroText sets the "intro_text" field.
func (m *PoiMutation) SetIntroText(s string) {
	m.intro_text = &s
}

// IntroText returns the value of the "intro_text" field in the mutation.
func (m *PoiMutation) IntroText() (r string, exists bool) {
	v := m.intro_text
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroText returns the old "intro_text" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldIntroText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroText: %w", err)
	}
	return oldValue.IntroText, nil
}

// ResetIntroText resets all changes to the "intro_text" field.
func (m *PoiMutation) ResetIntroText() {
	m.intro_text = nil
}

// SetImageIds sets the "image_ids" field.
func (m *PoiMutation) SetImageIds(i []int) {
	m.image_ids = &i
	m.appendimage_ids = nil
}

// ImageIds returns the value of the "image_ids" field in the mutation.
func (m *PoiMutation) ImageIds() (r []int, exists bool) {
	v := m.image_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldImageIds returns the old "image_ids" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldImageIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageIds: %w", err)
	}
	return oldValue.ImageIds, nil
}

// AppendImageIds adds i to the "image_ids" field.
func (m *PoiMutation) AppendImageIds(i []int) {
	m.appendimage_ids = append(m.appendimage_ids, i...)
}

// AppendedImageIds returns the list of values that were appended to the "image_ids" field in this mutation.
func (m *PoiMutation) AppendedImageIds() ([]int, bool) {
	if len(m.appendimage_ids) == 0 {
		return nil, false
	}
	return m.appendimage_ids, true
}

// ResetImageIds resets all changes to the "image_ids" field.
func (m *PoiMutation) ResetImageIds() {
	m.image_ids = nil
	m.appendimage_ids = nil
}

// SetAudioID sets the "audio_id" field.
func (m *PoiMutation) SetAudioID(i int) {
	m.audio_id = &i
	m.addaudio_id = nil
}

// AudioID returns the value of the "audio_id" field in the mutation.
func (m *PoiMutation) AudioID() (r int, exists bool) {
	v := m.audio_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioID returns the old "audio_id" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldAudioID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioID: %w", err)
	}
	return oldValue.AudioID, nil
}

// AddAudioID adds i to the "audio_id" field.
func (m *PoiMutation) AddAudioID(i int) {
	if m.addaudio_id != nil {
		*m.addaudio_id += i
	} else {
		m.addaudio_id = &i
	}
}

// AddedAudioID returns the value that was added to the "audio_id" field in this mutation.
func (m *PoiMutation) AddedAudioID() (r int, exists bool) {
	v := m.addaudio_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAudioID resets all changes to the "audio_id" field.
func (m *PoiMutation) ResetAudioID() {
	m.audio_id = nil
	m.addaudio_id = nil
}

// SetVideoID sets the "video_id" field.
func (m *PoiMutation) SetVideoID(i int) {
	m.video_id = &i
	m.addvideo_id = nil
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *PoiMutation) VideoID() (r int, exists bool) {
	v := m.video_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// AddVideoID adds i to the "video_id" field.
func (m *PoiMutation) AddVideoID(i int) {
	if m.addvideo_id != nil {
		*m.addvideo_id += i
	} else {
		m.addvideo_id = &i
	}
}

// AddedVideoID returns the value that was added to the "video_id" field in this mutation.
func (m *PoiMutation) AddedVideoID() (r int, exists bool) {
	v := m.addvideo_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *PoiMutation) ResetVideoID() {
	m.video_id = nil
	m.addvideo_id = nil
}

// SetBroadcastRadius sets the "broadcast_radius" field.
func (m *PoiMutation) SetBroadcastRadius(i int) {
	m.broadcast_radius = &i
	m.addbroadcast_radius = nil
}

// BroadcastRadius returns the value of the "broadcast_radius" field in the mutation.
func (m *PoiMutation) BroadcastRadius() (r int, exists bool) {
	v := m.broadcast_radius
	if v == nil {
		return
	}
	return *v, true
}

// OldBroadcastRadius returns the old "broadcast_radius" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldBroadcastRadius(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBroadcastRadius is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBroadcastRadius requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBroadcastRadius: %w", err)
	}
	return oldValue.BroadcastRadius, nil
}

// AddBroadcastRadius adds i to the "broadcast_radius" field.
func (m *PoiMutation) AddBroadcastRadius(i int) {
	if m.addbroadcast_radius != nil {
		*m.addbroadcast_radius += i
	} else {
		m.addbroadcast_radius = &i
	}
}

// AddedBroadcastRadius returns the value that was added to the "broadcast_radius" field in this mutation.
func (m *PoiMutation) AddedBroadcastRadius() (r int, exists bool) {
	v := m.addbroadcast_radius
	if v == nil {
		return
	}
	return *v, true
}

// ResetBroadcastRadius resets all changes to the "broadcast_radius" field.
func (m *PoiMutation) ResetBroadcastRadius() {
	m.broadcast_radius = nil
	m.addbroadcast_radius = nil
}

// SetParkingRadius sets the "parking_radius" field.
func (m *PoiMutation) SetParkingRadius(i int) {
	m.parking_radius = &i
	m.addparking_radius = nil
}

// ParkingRadius returns the value of the "parking_radius" field in the mutation.
func (m *PoiMutation) ParkingRadius() (r int, exists bool) {
	v := m.parking_radius
	if v == nil {
		return
	}
	return *v, true
}

// OldParkingRadius returns the old "parking_radius" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldParkingRadius(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParkingRadius is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParkingRadius requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParkingRadius: %w", err)
	}
	return oldValue.ParkingRadius, nil
}

// AddParkingRadius adds i to the "parking_radius" field.
func (m *PoiMutation) AddParkingRadius(i int) {
	if m.addparking_radius != nil {
		*m.addparking_radius += i
	} else {
		m.addparking_radius = &i
	}
}

// AddedParkingRadius returns the value that was added to the "parking_radius" field in this mutation.
func (m *PoiMutation) AddedParkingRadius() (r int, exists bool) {
	v := m.addparking_radius
	if v == nil {
		return
	}
	return *v, true
}

// ResetParkingRadius resets all changes to the "parking_radius" field.
func (m *PoiMutation) ResetParkingRadius() {
	m.parking_radius = nil
	m.addparking_radius = nil
}

// SetLevel sets the "level" field.
func (m *PoiMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *PoiMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *PoiMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *PoiMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *PoiMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetExtendYokeeID sets the "extend_yokee_id" field.
func (m *PoiMutation) SetExtendYokeeID(i int) {
	m.extend_yokee_id = &i
	m.addextend_yokee_id = nil
}

// ExtendYokeeID returns the value of the "extend_yokee_id" field in the mutation.
func (m *PoiMutation) ExtendYokeeID() (r int, exists bool) {
	v := m.extend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendYokeeID returns the old "extend_yokee_id" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldExtendYokeeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendYokeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendYokeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendYokeeID: %w", err)
	}
	return oldValue.ExtendYokeeID, nil
}

// AddExtendYokeeID adds i to the "extend_yokee_id" field.
func (m *PoiMutation) AddExtendYokeeID(i int) {
	if m.addextend_yokee_id != nil {
		*m.addextend_yokee_id += i
	} else {
		m.addextend_yokee_id = &i
	}
}

// AddedExtendYokeeID returns the value that was added to the "extend_yokee_id" field in this mutation.
func (m *PoiMutation) AddedExtendYokeeID() (r int, exists bool) {
	v := m.addextend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtendYokeeID clears the value of the "extend_yokee_id" field.
func (m *PoiMutation) ClearExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	m.clearedFields[poi.FieldExtendYokeeID] = struct{}{}
}

// ExtendYokeeIDCleared returns if the "extend_yokee_id" field was cleared in this mutation.
func (m *PoiMutation) ExtendYokeeIDCleared() bool {
	_, ok := m.clearedFields[poi.FieldExtendYokeeID]
	return ok
}

// ResetExtendYokeeID resets all changes to the "extend_yokee_id" field.
func (m *PoiMutation) ResetExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	delete(m.clearedFields, poi.FieldExtendYokeeID)
}

// SetCreateTime sets the "create_time" field.
func (m *PoiMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PoiMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PoiMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PoiMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PoiMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Poi entity.
// If the Poi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PoiMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *PoiMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *PoiMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[poi.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *PoiMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *PoiMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *PoiMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *PoiMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the PoiMutation builder.
func (m *PoiMutation) Where(ps ...predicate.Poi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PoiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PoiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Poi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PoiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PoiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Poi).
func (m *PoiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PoiMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.name != nil {
		fields = append(fields, poi.FieldName)
	}
	if m.alias != nil {
		fields = append(fields, poi.FieldAlias)
	}
	if m.background_scenic_area != nil {
		fields = append(fields, poi.FieldScenicAreaID)
	}
	if m._type != nil {
		fields = append(fields, poi.FieldType)
	}
	if m.wgs_lon != nil {
		fields = append(fields, poi.FieldWgsLon)
	}
	if m.wgs_lat != nil {
		fields = append(fields, poi.FieldWgsLat)
	}
	if m.gcj_lon != nil {
		fields = append(fields, poi.FieldGcjLon)
	}
	if m.gcj_lat != nil {
		fields = append(fields, poi.FieldGcjLat)
	}
	if m.bd_lon != nil {
		fields = append(fields, poi.FieldBdLon)
	}
	if m.bd_lat != nil {
		fields = append(fields, poi.FieldBdLat)
	}
	if m.stop_heading != nil {
		fields = append(fields, poi.FieldStopHeading)
	}
	if m.intro_text != nil {
		fields = append(fields, poi.FieldIntroText)
	}
	if m.image_ids != nil {
		fields = append(fields, poi.FieldImageIds)
	}
	if m.audio_id != nil {
		fields = append(fields, poi.FieldAudioID)
	}
	if m.video_id != nil {
		fields = append(fields, poi.FieldVideoID)
	}
	if m.broadcast_radius != nil {
		fields = append(fields, poi.FieldBroadcastRadius)
	}
	if m.parking_radius != nil {
		fields = append(fields, poi.FieldParkingRadius)
	}
	if m.level != nil {
		fields = append(fields, poi.FieldLevel)
	}
	if m.extend_yokee_id != nil {
		fields = append(fields, poi.FieldExtendYokeeID)
	}
	if m.create_time != nil {
		fields = append(fields, poi.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, poi.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PoiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case poi.FieldName:
		return m.Name()
	case poi.FieldAlias:
		return m.Alias()
	case poi.FieldScenicAreaID:
		return m.ScenicAreaID()
	case poi.FieldType:
		return m.GetType()
	case poi.FieldWgsLon:
		return m.WgsLon()
	case poi.FieldWgsLat:
		return m.WgsLat()
	case poi.FieldGcjLon:
		return m.GcjLon()
	case poi.FieldGcjLat:
		return m.GcjLat()
	case poi.FieldBdLon:
		return m.BdLon()
	case poi.FieldBdLat:
		return m.BdLat()
	case poi.FieldStopHeading:
		return m.StopHeading()
	case poi.FieldIntroText:
		return m.IntroText()
	case poi.FieldImageIds:
		return m.ImageIds()
	case poi.FieldAudioID:
		return m.AudioID()
	case poi.FieldVideoID:
		return m.VideoID()
	case poi.FieldBroadcastRadius:
		return m.BroadcastRadius()
	case poi.FieldParkingRadius:
		return m.ParkingRadius()
	case poi.FieldLevel:
		return m.Level()
	case poi.FieldExtendYokeeID:
		return m.ExtendYokeeID()
	case poi.FieldCreateTime:
		return m.CreateTime()
	case poi.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PoiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case poi.FieldName:
		return m.OldName(ctx)
	case poi.FieldAlias:
		return m.OldAlias(ctx)
	case poi.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case poi.FieldType:
		return m.OldType(ctx)
	case poi.FieldWgsLon:
		return m.OldWgsLon(ctx)
	case poi.FieldWgsLat:
		return m.OldWgsLat(ctx)
	case poi.FieldGcjLon:
		return m.OldGcjLon(ctx)
	case poi.FieldGcjLat:
		return m.OldGcjLat(ctx)
	case poi.FieldBdLon:
		return m.OldBdLon(ctx)
	case poi.FieldBdLat:
		return m.OldBdLat(ctx)
	case poi.FieldStopHeading:
		return m.OldStopHeading(ctx)
	case poi.FieldIntroText:
		return m.OldIntroText(ctx)
	case poi.FieldImageIds:
		return m.OldImageIds(ctx)
	case poi.FieldAudioID:
		return m.OldAudioID(ctx)
	case poi.FieldVideoID:
		return m.OldVideoID(ctx)
	case poi.FieldBroadcastRadius:
		return m.OldBroadcastRadius(ctx)
	case poi.FieldParkingRadius:
		return m.OldParkingRadius(ctx)
	case poi.FieldLevel:
		return m.OldLevel(ctx)
	case poi.FieldExtendYokeeID:
		return m.OldExtendYokeeID(ctx)
	case poi.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case poi.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Poi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case poi.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case poi.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case poi.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case poi.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case poi.FieldWgsLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWgsLon(v)
		return nil
	case poi.FieldWgsLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWgsLat(v)
		return nil
	case poi.FieldGcjLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGcjLon(v)
		return nil
	case poi.FieldGcjLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGcjLat(v)
		return nil
	case poi.FieldBdLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBdLon(v)
		return nil
	case poi.FieldBdLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBdLat(v)
		return nil
	case poi.FieldStopHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopHeading(v)
		return nil
	case poi.FieldIntroText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroText(v)
		return nil
	case poi.FieldImageIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageIds(v)
		return nil
	case poi.FieldAudioID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioID(v)
		return nil
	case poi.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case poi.FieldBroadcastRadius:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBroadcastRadius(v)
		return nil
	case poi.FieldParkingRadius:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParkingRadius(v)
		return nil
	case poi.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case poi.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendYokeeID(v)
		return nil
	case poi.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case poi.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Poi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PoiMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, poi.FieldType)
	}
	if m.addwgs_lon != nil {
		fields = append(fields, poi.FieldWgsLon)
	}
	if m.addwgs_lat != nil {
		fields = append(fields, poi.FieldWgsLat)
	}
	if m.addgcj_lon != nil {
		fields = append(fields, poi.FieldGcjLon)
	}
	if m.addgcj_lat != nil {
		fields = append(fields, poi.FieldGcjLat)
	}
	if m.addbd_lon != nil {
		fields = append(fields, poi.FieldBdLon)
	}
	if m.addbd_lat != nil {
		fields = append(fields, poi.FieldBdLat)
	}
	if m.addstop_heading != nil {
		fields = append(fields, poi.FieldStopHeading)
	}
	if m.addaudio_id != nil {
		fields = append(fields, poi.FieldAudioID)
	}
	if m.addvideo_id != nil {
		fields = append(fields, poi.FieldVideoID)
	}
	if m.addbroadcast_radius != nil {
		fields = append(fields, poi.FieldBroadcastRadius)
	}
	if m.addparking_radius != nil {
		fields = append(fields, poi.FieldParkingRadius)
	}
	if m.addlevel != nil {
		fields = append(fields, poi.FieldLevel)
	}
	if m.addextend_yokee_id != nil {
		fields = append(fields, poi.FieldExtendYokeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PoiMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case poi.FieldType:
		return m.AddedType()
	case poi.FieldWgsLon:
		return m.AddedWgsLon()
	case poi.FieldWgsLat:
		return m.AddedWgsLat()
	case poi.FieldGcjLon:
		return m.AddedGcjLon()
	case poi.FieldGcjLat:
		return m.AddedGcjLat()
	case poi.FieldBdLon:
		return m.AddedBdLon()
	case poi.FieldBdLat:
		return m.AddedBdLat()
	case poi.FieldStopHeading:
		return m.AddedStopHeading()
	case poi.FieldAudioID:
		return m.AddedAudioID()
	case poi.FieldVideoID:
		return m.AddedVideoID()
	case poi.FieldBroadcastRadius:
		return m.AddedBroadcastRadius()
	case poi.FieldParkingRadius:
		return m.AddedParkingRadius()
	case poi.FieldLevel:
		return m.AddedLevel()
	case poi.FieldExtendYokeeID:
		return m.AddedExtendYokeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoiMutation) AddField(name string, value ent.Value) error {
	switch name {
	case poi.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case poi.FieldWgsLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWgsLon(v)
		return nil
	case poi.FieldWgsLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWgsLat(v)
		return nil
	case poi.FieldGcjLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGcjLon(v)
		return nil
	case poi.FieldGcjLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGcjLat(v)
		return nil
	case poi.FieldBdLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBdLon(v)
		return nil
	case poi.FieldBdLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBdLat(v)
		return nil
	case poi.FieldStopHeading:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStopHeading(v)
		return nil
	case poi.FieldAudioID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAudioID(v)
		return nil
	case poi.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVideoID(v)
		return nil
	case poi.FieldBroadcastRadius:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBroadcastRadius(v)
		return nil
	case poi.FieldParkingRadius:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParkingRadius(v)
		return nil
	case poi.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case poi.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtendYokeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Poi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PoiMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(poi.FieldExtendYokeeID) {
		fields = append(fields, poi.FieldExtendYokeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PoiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PoiMutation) ClearField(name string) error {
	switch name {
	case poi.FieldExtendYokeeID:
		m.ClearExtendYokeeID()
		return nil
	}
	return fmt.Errorf("unknown Poi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PoiMutation) ResetField(name string) error {
	switch name {
	case poi.FieldName:
		m.ResetName()
		return nil
	case poi.FieldAlias:
		m.ResetAlias()
		return nil
	case poi.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case poi.FieldType:
		m.ResetType()
		return nil
	case poi.FieldWgsLon:
		m.ResetWgsLon()
		return nil
	case poi.FieldWgsLat:
		m.ResetWgsLat()
		return nil
	case poi.FieldGcjLon:
		m.ResetGcjLon()
		return nil
	case poi.FieldGcjLat:
		m.ResetGcjLat()
		return nil
	case poi.FieldBdLon:
		m.ResetBdLon()
		return nil
	case poi.FieldBdLat:
		m.ResetBdLat()
		return nil
	case poi.FieldStopHeading:
		m.ResetStopHeading()
		return nil
	case poi.FieldIntroText:
		m.ResetIntroText()
		return nil
	case poi.FieldImageIds:
		m.ResetImageIds()
		return nil
	case poi.FieldAudioID:
		m.ResetAudioID()
		return nil
	case poi.FieldVideoID:
		m.ResetVideoID()
		return nil
	case poi.FieldBroadcastRadius:
		m.ResetBroadcastRadius()
		return nil
	case poi.FieldParkingRadius:
		m.ResetParkingRadius()
		return nil
	case poi.FieldLevel:
		m.ResetLevel()
		return nil
	case poi.FieldExtendYokeeID:
		m.ResetExtendYokeeID()
		return nil
	case poi.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case poi.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Poi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PoiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, poi.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PoiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case poi.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PoiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PoiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PoiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, poi.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PoiMutation) EdgeCleared(name string) bool {
	switch name {
	case poi.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PoiMutation) ClearEdge(name string) error {
	switch name {
	case poi.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown Poi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PoiMutation) ResetEdge(name string) error {
	switch name {
	case poi.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown Poi edge %s", name)
}

// PoiExtendYokeeMutation represents an operation that mutates the PoiExtendYokee nodes in the graph.
type PoiExtendYokeeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	poi_id              *int
	addpoi_id           *int
	yokee_station_id    *int
	addyokee_station_id *int
	yokee_station_name  *string
	yokee_stop_id       *int
	addyokee_stop_id    *int
	yokee_stop_name     *string
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PoiExtendYokee, error)
	predicates          []predicate.PoiExtendYokee
}

var _ ent.Mutation = (*PoiExtendYokeeMutation)(nil)

// poiextendyokeeOption allows management of the mutation configuration using functional options.
type poiextendyokeeOption func(*PoiExtendYokeeMutation)

// newPoiExtendYokeeMutation creates new mutation for the PoiExtendYokee entity.
func newPoiExtendYokeeMutation(c config, op Op, opts ...poiextendyokeeOption) *PoiExtendYokeeMutation {
	m := &PoiExtendYokeeMutation{
		config:        c,
		op:            op,
		typ:           TypePoiExtendYokee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPoiExtendYokeeID sets the ID field of the mutation.
func withPoiExtendYokeeID(id int) poiextendyokeeOption {
	return func(m *PoiExtendYokeeMutation) {
		var (
			err   error
			once  sync.Once
			value *PoiExtendYokee
		)
		m.oldValue = func(ctx context.Context) (*PoiExtendYokee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PoiExtendYokee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPoiExtendYokee sets the old PoiExtendYokee of the mutation.
func withPoiExtendYokee(node *PoiExtendYokee) poiextendyokeeOption {
	return func(m *PoiExtendYokeeMutation) {
		m.oldValue = func(context.Context) (*PoiExtendYokee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PoiExtendYokeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PoiExtendYokeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PoiExtendYokee entities.
func (m *PoiExtendYokeeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PoiExtendYokeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PoiExtendYokeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PoiExtendYokee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPoiID sets the "poi_id" field.
func (m *PoiExtendYokeeMutation) SetPoiID(i int) {
	m.poi_id = &i
	m.addpoi_id = nil
}

// PoiID returns the value of the "poi_id" field in the mutation.
func (m *PoiExtendYokeeMutation) PoiID() (r int, exists bool) {
	v := m.poi_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoiID returns the old "poi_id" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldPoiID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoiID: %w", err)
	}
	return oldValue.PoiID, nil
}

// AddPoiID adds i to the "poi_id" field.
func (m *PoiExtendYokeeMutation) AddPoiID(i int) {
	if m.addpoi_id != nil {
		*m.addpoi_id += i
	} else {
		m.addpoi_id = &i
	}
}

// AddedPoiID returns the value that was added to the "poi_id" field in this mutation.
func (m *PoiExtendYokeeMutation) AddedPoiID() (r int, exists bool) {
	v := m.addpoi_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoiID resets all changes to the "poi_id" field.
func (m *PoiExtendYokeeMutation) ResetPoiID() {
	m.poi_id = nil
	m.addpoi_id = nil
}

// SetYokeeStationID sets the "yokee_station_id" field.
func (m *PoiExtendYokeeMutation) SetYokeeStationID(i int) {
	m.yokee_station_id = &i
	m.addyokee_station_id = nil
}

// YokeeStationID returns the value of the "yokee_station_id" field in the mutation.
func (m *PoiExtendYokeeMutation) YokeeStationID() (r int, exists bool) {
	v := m.yokee_station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStationID returns the old "yokee_station_id" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldYokeeStationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStationID: %w", err)
	}
	return oldValue.YokeeStationID, nil
}

// AddYokeeStationID adds i to the "yokee_station_id" field.
func (m *PoiExtendYokeeMutation) AddYokeeStationID(i int) {
	if m.addyokee_station_id != nil {
		*m.addyokee_station_id += i
	} else {
		m.addyokee_station_id = &i
	}
}

// AddedYokeeStationID returns the value that was added to the "yokee_station_id" field in this mutation.
func (m *PoiExtendYokeeMutation) AddedYokeeStationID() (r int, exists bool) {
	v := m.addyokee_station_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeStationID resets all changes to the "yokee_station_id" field.
func (m *PoiExtendYokeeMutation) ResetYokeeStationID() {
	m.yokee_station_id = nil
	m.addyokee_station_id = nil
}

// SetYokeeStationName sets the "yokee_station_name" field.
func (m *PoiExtendYokeeMutation) SetYokeeStationName(s string) {
	m.yokee_station_name = &s
}

// YokeeStationName returns the value of the "yokee_station_name" field in the mutation.
func (m *PoiExtendYokeeMutation) YokeeStationName() (r string, exists bool) {
	v := m.yokee_station_name
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStationName returns the old "yokee_station_name" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldYokeeStationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStationName: %w", err)
	}
	return oldValue.YokeeStationName, nil
}

// ResetYokeeStationName resets all changes to the "yokee_station_name" field.
func (m *PoiExtendYokeeMutation) ResetYokeeStationName() {
	m.yokee_station_name = nil
}

// SetYokeeStopID sets the "yokee_stop_id" field.
func (m *PoiExtendYokeeMutation) SetYokeeStopID(i int) {
	m.yokee_stop_id = &i
	m.addyokee_stop_id = nil
}

// YokeeStopID returns the value of the "yokee_stop_id" field in the mutation.
func (m *PoiExtendYokeeMutation) YokeeStopID() (r int, exists bool) {
	v := m.yokee_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStopID returns the old "yokee_stop_id" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldYokeeStopID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStopID: %w", err)
	}
	return oldValue.YokeeStopID, nil
}

// AddYokeeStopID adds i to the "yokee_stop_id" field.
func (m *PoiExtendYokeeMutation) AddYokeeStopID(i int) {
	if m.addyokee_stop_id != nil {
		*m.addyokee_stop_id += i
	} else {
		m.addyokee_stop_id = &i
	}
}

// AddedYokeeStopID returns the value that was added to the "yokee_stop_id" field in this mutation.
func (m *PoiExtendYokeeMutation) AddedYokeeStopID() (r int, exists bool) {
	v := m.addyokee_stop_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeStopID resets all changes to the "yokee_stop_id" field.
func (m *PoiExtendYokeeMutation) ResetYokeeStopID() {
	m.yokee_stop_id = nil
	m.addyokee_stop_id = nil
}

// SetYokeeStopName sets the "yokee_stop_name" field.
func (m *PoiExtendYokeeMutation) SetYokeeStopName(s string) {
	m.yokee_stop_name = &s
}

// YokeeStopName returns the value of the "yokee_stop_name" field in the mutation.
func (m *PoiExtendYokeeMutation) YokeeStopName() (r string, exists bool) {
	v := m.yokee_stop_name
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStopName returns the old "yokee_stop_name" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldYokeeStopName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStopName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStopName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStopName: %w", err)
	}
	return oldValue.YokeeStopName, nil
}

// ResetYokeeStopName resets all changes to the "yokee_stop_name" field.
func (m *PoiExtendYokeeMutation) ResetYokeeStopName() {
	m.yokee_stop_name = nil
}

// SetCreateTime sets the "create_time" field.
func (m *PoiExtendYokeeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PoiExtendYokeeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PoiExtendYokeeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PoiExtendYokeeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PoiExtendYokeeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PoiExtendYokee entity.
// If the PoiExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoiExtendYokeeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PoiExtendYokeeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the PoiExtendYokeeMutation builder.
func (m *PoiExtendYokeeMutation) Where(ps ...predicate.PoiExtendYokee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PoiExtendYokeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PoiExtendYokeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PoiExtendYokee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PoiExtendYokeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PoiExtendYokeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PoiExtendYokee).
func (m *PoiExtendYokeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PoiExtendYokeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.poi_id != nil {
		fields = append(fields, poiextendyokee.FieldPoiID)
	}
	if m.yokee_station_id != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStationID)
	}
	if m.yokee_station_name != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStationName)
	}
	if m.yokee_stop_id != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStopID)
	}
	if m.yokee_stop_name != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStopName)
	}
	if m.create_time != nil {
		fields = append(fields, poiextendyokee.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, poiextendyokee.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PoiExtendYokeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case poiextendyokee.FieldPoiID:
		return m.PoiID()
	case poiextendyokee.FieldYokeeStationID:
		return m.YokeeStationID()
	case poiextendyokee.FieldYokeeStationName:
		return m.YokeeStationName()
	case poiextendyokee.FieldYokeeStopID:
		return m.YokeeStopID()
	case poiextendyokee.FieldYokeeStopName:
		return m.YokeeStopName()
	case poiextendyokee.FieldCreateTime:
		return m.CreateTime()
	case poiextendyokee.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PoiExtendYokeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case poiextendyokee.FieldPoiID:
		return m.OldPoiID(ctx)
	case poiextendyokee.FieldYokeeStationID:
		return m.OldYokeeStationID(ctx)
	case poiextendyokee.FieldYokeeStationName:
		return m.OldYokeeStationName(ctx)
	case poiextendyokee.FieldYokeeStopID:
		return m.OldYokeeStopID(ctx)
	case poiextendyokee.FieldYokeeStopName:
		return m.OldYokeeStopName(ctx)
	case poiextendyokee.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case poiextendyokee.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PoiExtendYokee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoiExtendYokeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case poiextendyokee.FieldPoiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoiID(v)
		return nil
	case poiextendyokee.FieldYokeeStationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStationID(v)
		return nil
	case poiextendyokee.FieldYokeeStationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStationName(v)
		return nil
	case poiextendyokee.FieldYokeeStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStopID(v)
		return nil
	case poiextendyokee.FieldYokeeStopName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStopName(v)
		return nil
	case poiextendyokee.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case poiextendyokee.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PoiExtendYokee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PoiExtendYokeeMutation) AddedFields() []string {
	var fields []string
	if m.addpoi_id != nil {
		fields = append(fields, poiextendyokee.FieldPoiID)
	}
	if m.addyokee_station_id != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStationID)
	}
	if m.addyokee_stop_id != nil {
		fields = append(fields, poiextendyokee.FieldYokeeStopID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PoiExtendYokeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case poiextendyokee.FieldPoiID:
		return m.AddedPoiID()
	case poiextendyokee.FieldYokeeStationID:
		return m.AddedYokeeStationID()
	case poiextendyokee.FieldYokeeStopID:
		return m.AddedYokeeStopID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoiExtendYokeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case poiextendyokee.FieldPoiID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoiID(v)
		return nil
	case poiextendyokee.FieldYokeeStationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeStationID(v)
		return nil
	case poiextendyokee.FieldYokeeStopID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeStopID(v)
		return nil
	}
	return fmt.Errorf("unknown PoiExtendYokee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PoiExtendYokeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PoiExtendYokeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PoiExtendYokeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PoiExtendYokee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PoiExtendYokeeMutation) ResetField(name string) error {
	switch name {
	case poiextendyokee.FieldPoiID:
		m.ResetPoiID()
		return nil
	case poiextendyokee.FieldYokeeStationID:
		m.ResetYokeeStationID()
		return nil
	case poiextendyokee.FieldYokeeStationName:
		m.ResetYokeeStationName()
		return nil
	case poiextendyokee.FieldYokeeStopID:
		m.ResetYokeeStopID()
		return nil
	case poiextendyokee.FieldYokeeStopName:
		m.ResetYokeeStopName()
		return nil
	case poiextendyokee.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case poiextendyokee.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PoiExtendYokee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PoiExtendYokeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PoiExtendYokeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PoiExtendYokeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PoiExtendYokeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PoiExtendYokeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PoiExtendYokeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PoiExtendYokeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PoiExtendYokee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PoiExtendYokeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PoiExtendYokee edge %s", name)
}

// ProfitReceiverMutation represents an operation that mutates the ProfitReceiver nodes in the graph.
type ProfitReceiverMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	mch_id                        *string
	phone                         *string
	receiver_type                 *int
	addreceiver_type              *int
	receiver_account              *string
	receiver_name                 *string
	sharing_ratio                 *float64
	addsharing_ratio              *float64
	state                         *int
	addstate                      *int
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*ProfitReceiver, error)
	predicates                    []predicate.ProfitReceiver
}

var _ ent.Mutation = (*ProfitReceiverMutation)(nil)

// profitreceiverOption allows management of the mutation configuration using functional options.
type profitreceiverOption func(*ProfitReceiverMutation)

// newProfitReceiverMutation creates new mutation for the ProfitReceiver entity.
func newProfitReceiverMutation(c config, op Op, opts ...profitreceiverOption) *ProfitReceiverMutation {
	m := &ProfitReceiverMutation{
		config:        c,
		op:            op,
		typ:           TypeProfitReceiver,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfitReceiverID sets the ID field of the mutation.
func withProfitReceiverID(id int) profitreceiverOption {
	return func(m *ProfitReceiverMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfitReceiver
		)
		m.oldValue = func(ctx context.Context) (*ProfitReceiver, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfitReceiver.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfitReceiver sets the old ProfitReceiver of the mutation.
func withProfitReceiver(node *ProfitReceiver) profitreceiverOption {
	return func(m *ProfitReceiverMutation) {
		m.oldValue = func(context.Context) (*ProfitReceiver, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfitReceiverMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfitReceiverMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfitReceiver entities.
func (m *ProfitReceiverMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfitReceiverMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfitReceiverMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfitReceiver.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *ProfitReceiverMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *ProfitReceiverMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *ProfitReceiverMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetMchID sets the "mch_id" field.
func (m *ProfitReceiverMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *ProfitReceiverMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *ProfitReceiverMutation) ResetMchID() {
	m.mch_id = nil
}

// SetPhone sets the "phone" field.
func (m *ProfitReceiverMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ProfitReceiverMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ProfitReceiverMutation) ResetPhone() {
	m.phone = nil
}

// SetReceiverType sets the "receiver_type" field.
func (m *ProfitReceiverMutation) SetReceiverType(i int) {
	m.receiver_type = &i
	m.addreceiver_type = nil
}

// ReceiverType returns the value of the "receiver_type" field in the mutation.
func (m *ProfitReceiverMutation) ReceiverType() (r int, exists bool) {
	v := m.receiver_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverType returns the old "receiver_type" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldReceiverType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverType: %w", err)
	}
	return oldValue.ReceiverType, nil
}

// AddReceiverType adds i to the "receiver_type" field.
func (m *ProfitReceiverMutation) AddReceiverType(i int) {
	if m.addreceiver_type != nil {
		*m.addreceiver_type += i
	} else {
		m.addreceiver_type = &i
	}
}

// AddedReceiverType returns the value that was added to the "receiver_type" field in this mutation.
func (m *ProfitReceiverMutation) AddedReceiverType() (r int, exists bool) {
	v := m.addreceiver_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceiverType resets all changes to the "receiver_type" field.
func (m *ProfitReceiverMutation) ResetReceiverType() {
	m.receiver_type = nil
	m.addreceiver_type = nil
}

// SetReceiverAccount sets the "receiver_account" field.
func (m *ProfitReceiverMutation) SetReceiverAccount(s string) {
	m.receiver_account = &s
}

// ReceiverAccount returns the value of the "receiver_account" field in the mutation.
func (m *ProfitReceiverMutation) ReceiverAccount() (r string, exists bool) {
	v := m.receiver_account
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverAccount returns the old "receiver_account" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldReceiverAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverAccount: %w", err)
	}
	return oldValue.ReceiverAccount, nil
}

// ResetReceiverAccount resets all changes to the "receiver_account" field.
func (m *ProfitReceiverMutation) ResetReceiverAccount() {
	m.receiver_account = nil
}

// SetReceiverName sets the "receiver_name" field.
func (m *ProfitReceiverMutation) SetReceiverName(s string) {
	m.receiver_name = &s
}

// ReceiverName returns the value of the "receiver_name" field in the mutation.
func (m *ProfitReceiverMutation) ReceiverName() (r string, exists bool) {
	v := m.receiver_name
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverName returns the old "receiver_name" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldReceiverName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverName: %w", err)
	}
	return oldValue.ReceiverName, nil
}

// ResetReceiverName resets all changes to the "receiver_name" field.
func (m *ProfitReceiverMutation) ResetReceiverName() {
	m.receiver_name = nil
}

// SetSharingRatio sets the "sharing_ratio" field.
func (m *ProfitReceiverMutation) SetSharingRatio(f float64) {
	m.sharing_ratio = &f
	m.addsharing_ratio = nil
}

// SharingRatio returns the value of the "sharing_ratio" field in the mutation.
func (m *ProfitReceiverMutation) SharingRatio() (r float64, exists bool) {
	v := m.sharing_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldSharingRatio returns the old "sharing_ratio" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldSharingRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharingRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharingRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharingRatio: %w", err)
	}
	return oldValue.SharingRatio, nil
}

// AddSharingRatio adds f to the "sharing_ratio" field.
func (m *ProfitReceiverMutation) AddSharingRatio(f float64) {
	if m.addsharing_ratio != nil {
		*m.addsharing_ratio += f
	} else {
		m.addsharing_ratio = &f
	}
}

// AddedSharingRatio returns the value that was added to the "sharing_ratio" field in this mutation.
func (m *ProfitReceiverMutation) AddedSharingRatio() (r float64, exists bool) {
	v := m.addsharing_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetSharingRatio resets all changes to the "sharing_ratio" field.
func (m *ProfitReceiverMutation) ResetSharingRatio() {
	m.sharing_ratio = nil
	m.addsharing_ratio = nil
}

// SetState sets the "state" field.
func (m *ProfitReceiverMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *ProfitReceiverMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *ProfitReceiverMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *ProfitReceiverMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *ProfitReceiverMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ProfitReceiverMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfitReceiverMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfitReceiverMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfitReceiverMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfitReceiverMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProfitReceiver entity.
// If the ProfitReceiver object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfitReceiverMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfitReceiverMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *ProfitReceiverMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *ProfitReceiverMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[profitreceiver.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *ProfitReceiverMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *ProfitReceiverMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *ProfitReceiverMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *ProfitReceiverMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the ProfitReceiverMutation builder.
func (m *ProfitReceiverMutation) Where(ps ...predicate.ProfitReceiver) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfitReceiverMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfitReceiverMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfitReceiver, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfitReceiverMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfitReceiverMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfitReceiver).
func (m *ProfitReceiverMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfitReceiverMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.background_scenic_area != nil {
		fields = append(fields, profitreceiver.FieldScenicAreaID)
	}
	if m.mch_id != nil {
		fields = append(fields, profitreceiver.FieldMchID)
	}
	if m.phone != nil {
		fields = append(fields, profitreceiver.FieldPhone)
	}
	if m.receiver_type != nil {
		fields = append(fields, profitreceiver.FieldReceiverType)
	}
	if m.receiver_account != nil {
		fields = append(fields, profitreceiver.FieldReceiverAccount)
	}
	if m.receiver_name != nil {
		fields = append(fields, profitreceiver.FieldReceiverName)
	}
	if m.sharing_ratio != nil {
		fields = append(fields, profitreceiver.FieldSharingRatio)
	}
	if m.state != nil {
		fields = append(fields, profitreceiver.FieldState)
	}
	if m.create_time != nil {
		fields = append(fields, profitreceiver.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profitreceiver.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfitReceiverMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profitreceiver.FieldScenicAreaID:
		return m.ScenicAreaID()
	case profitreceiver.FieldMchID:
		return m.MchID()
	case profitreceiver.FieldPhone:
		return m.Phone()
	case profitreceiver.FieldReceiverType:
		return m.ReceiverType()
	case profitreceiver.FieldReceiverAccount:
		return m.ReceiverAccount()
	case profitreceiver.FieldReceiverName:
		return m.ReceiverName()
	case profitreceiver.FieldSharingRatio:
		return m.SharingRatio()
	case profitreceiver.FieldState:
		return m.State()
	case profitreceiver.FieldCreateTime:
		return m.CreateTime()
	case profitreceiver.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfitReceiverMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profitreceiver.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case profitreceiver.FieldMchID:
		return m.OldMchID(ctx)
	case profitreceiver.FieldPhone:
		return m.OldPhone(ctx)
	case profitreceiver.FieldReceiverType:
		return m.OldReceiverType(ctx)
	case profitreceiver.FieldReceiverAccount:
		return m.OldReceiverAccount(ctx)
	case profitreceiver.FieldReceiverName:
		return m.OldReceiverName(ctx)
	case profitreceiver.FieldSharingRatio:
		return m.OldSharingRatio(ctx)
	case profitreceiver.FieldState:
		return m.OldState(ctx)
	case profitreceiver.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profitreceiver.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProfitReceiver field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitReceiverMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profitreceiver.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case profitreceiver.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case profitreceiver.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case profitreceiver.FieldReceiverType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverType(v)
		return nil
	case profitreceiver.FieldReceiverAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverAccount(v)
		return nil
	case profitreceiver.FieldReceiverName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverName(v)
		return nil
	case profitreceiver.FieldSharingRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharingRatio(v)
		return nil
	case profitreceiver.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case profitreceiver.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profitreceiver.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitReceiver field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfitReceiverMutation) AddedFields() []string {
	var fields []string
	if m.addreceiver_type != nil {
		fields = append(fields, profitreceiver.FieldReceiverType)
	}
	if m.addsharing_ratio != nil {
		fields = append(fields, profitreceiver.FieldSharingRatio)
	}
	if m.addstate != nil {
		fields = append(fields, profitreceiver.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfitReceiverMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case profitreceiver.FieldReceiverType:
		return m.AddedReceiverType()
	case profitreceiver.FieldSharingRatio:
		return m.AddedSharingRatio()
	case profitreceiver.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfitReceiverMutation) AddField(name string, value ent.Value) error {
	switch name {
	case profitreceiver.FieldReceiverType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceiverType(v)
		return nil
	case profitreceiver.FieldSharingRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSharingRatio(v)
		return nil
	case profitreceiver.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown ProfitReceiver numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfitReceiverMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfitReceiverMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfitReceiverMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfitReceiver nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfitReceiverMutation) ResetField(name string) error {
	switch name {
	case profitreceiver.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case profitreceiver.FieldMchID:
		m.ResetMchID()
		return nil
	case profitreceiver.FieldPhone:
		m.ResetPhone()
		return nil
	case profitreceiver.FieldReceiverType:
		m.ResetReceiverType()
		return nil
	case profitreceiver.FieldReceiverAccount:
		m.ResetReceiverAccount()
		return nil
	case profitreceiver.FieldReceiverName:
		m.ResetReceiverName()
		return nil
	case profitreceiver.FieldSharingRatio:
		m.ResetSharingRatio()
		return nil
	case profitreceiver.FieldState:
		m.ResetState()
		return nil
	case profitreceiver.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profitreceiver.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ProfitReceiver field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfitReceiverMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, profitreceiver.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfitReceiverMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profitreceiver.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfitReceiverMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfitReceiverMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfitReceiverMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, profitreceiver.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfitReceiverMutation) EdgeCleared(name string) bool {
	switch name {
	case profitreceiver.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfitReceiverMutation) ClearEdge(name string) error {
	switch name {
	case profitreceiver.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown ProfitReceiver unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfitReceiverMutation) ResetEdge(name string) error {
	switch name {
	case profitreceiver.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown ProfitReceiver edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	access_ids       *[]int
	appendaccess_ids []int
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Role, error)
	predicates       []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetAccessIds sets the "access_ids" field.
func (m *RoleMutation) SetAccessIds(i []int) {
	m.access_ids = &i
	m.appendaccess_ids = nil
}

// AccessIds returns the value of the "access_ids" field in the mutation.
func (m *RoleMutation) AccessIds() (r []int, exists bool) {
	v := m.access_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessIds returns the old "access_ids" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldAccessIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessIds: %w", err)
	}
	return oldValue.AccessIds, nil
}

// AppendAccessIds adds i to the "access_ids" field.
func (m *RoleMutation) AppendAccessIds(i []int) {
	m.appendaccess_ids = append(m.appendaccess_ids, i...)
}

// AppendedAccessIds returns the list of values that were appended to the "access_ids" field in this mutation.
func (m *RoleMutation) AppendedAccessIds() ([]int, bool) {
	if len(m.appendaccess_ids) == 0 {
		return nil, false
	}
	return m.appendaccess_ids, true
}

// ResetAccessIds resets all changes to the "access_ids" field.
func (m *RoleMutation) ResetAccessIds() {
	m.access_ids = nil
	m.appendaccess_ids = nil
}

// SetCreateTime sets the "create_time" field.
func (m *RoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.access_ids != nil {
		fields = append(fields, role.FieldAccessIds)
	}
	if m.create_time != nil {
		fields = append(fields, role.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, role.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldAccessIds:
		return m.AccessIds()
	case role.FieldCreateTime:
		return m.CreateTime()
	case role.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldAccessIds:
		return m.OldAccessIds(ctx)
	case role.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case role.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldAccessIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessIds(v)
		return nil
	case role.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case role.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldAccessIds:
		m.ResetAccessIds()
		return nil
	case role.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case role.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// RouteMutation represents an operation that mutates the Route nodes in the graph.
type RouteMutation struct {
	config
	op                Op
	typ               string
	id                *int
	delete_time       *time.Time
	scenic_area_id    *int
	addscenic_area_id *int
	_type             *int
	add_type          *int
	name              *string
	poi_ids           *[]int
	appendpoi_ids     []int
	routing_path      **types.RoutingPath
	remark            *string
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Route, error)
	predicates        []predicate.Route
}

var _ ent.Mutation = (*RouteMutation)(nil)

// routeOption allows management of the mutation configuration using functional options.
type routeOption func(*RouteMutation)

// newRouteMutation creates new mutation for the Route entity.
func newRouteMutation(c config, op Op, opts ...routeOption) *RouteMutation {
	m := &RouteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteID sets the ID field of the mutation.
func withRouteID(id int) routeOption {
	return func(m *RouteMutation) {
		var (
			err   error
			once  sync.Once
			value *Route
		)
		m.oldValue = func(ctx context.Context) (*Route, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Route.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoute sets the old Route of the mutation.
func withRoute(node *Route) routeOption {
	return func(m *RouteMutation) {
		m.oldValue = func(context.Context) (*Route, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Route entities.
func (m *RouteMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Route.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *RouteMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RouteMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RouteMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[route.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RouteMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[route.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RouteMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, route.FieldDeleteTime)
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *RouteMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *RouteMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *RouteMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *RouteMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *RouteMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetType sets the "type" field.
func (m *RouteMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *RouteMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *RouteMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *RouteMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *RouteMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *RouteMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RouteMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RouteMutation) ResetName() {
	m.name = nil
}

// SetPoiIds sets the "poi_ids" field.
func (m *RouteMutation) SetPoiIds(i []int) {
	m.poi_ids = &i
	m.appendpoi_ids = nil
}

// PoiIds returns the value of the "poi_ids" field in the mutation.
func (m *RouteMutation) PoiIds() (r []int, exists bool) {
	v := m.poi_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldPoiIds returns the old "poi_ids" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldPoiIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoiIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoiIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoiIds: %w", err)
	}
	return oldValue.PoiIds, nil
}

// AppendPoiIds adds i to the "poi_ids" field.
func (m *RouteMutation) AppendPoiIds(i []int) {
	m.appendpoi_ids = append(m.appendpoi_ids, i...)
}

// AppendedPoiIds returns the list of values that were appended to the "poi_ids" field in this mutation.
func (m *RouteMutation) AppendedPoiIds() ([]int, bool) {
	if len(m.appendpoi_ids) == 0 {
		return nil, false
	}
	return m.appendpoi_ids, true
}

// ResetPoiIds resets all changes to the "poi_ids" field.
func (m *RouteMutation) ResetPoiIds() {
	m.poi_ids = nil
	m.appendpoi_ids = nil
}

// SetRoutingPath sets the "routing_path" field.
func (m *RouteMutation) SetRoutingPath(tp *types.RoutingPath) {
	m.routing_path = &tp
}

// RoutingPath returns the value of the "routing_path" field in the mutation.
func (m *RouteMutation) RoutingPath() (r *types.RoutingPath, exists bool) {
	v := m.routing_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingPath returns the old "routing_path" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldRoutingPath(ctx context.Context) (v *types.RoutingPath, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingPath: %w", err)
	}
	return oldValue.RoutingPath, nil
}

// ClearRoutingPath clears the value of the "routing_path" field.
func (m *RouteMutation) ClearRoutingPath() {
	m.routing_path = nil
	m.clearedFields[route.FieldRoutingPath] = struct{}{}
}

// RoutingPathCleared returns if the "routing_path" field was cleared in this mutation.
func (m *RouteMutation) RoutingPathCleared() bool {
	_, ok := m.clearedFields[route.FieldRoutingPath]
	return ok
}

// ResetRoutingPath resets all changes to the "routing_path" field.
func (m *RouteMutation) ResetRoutingPath() {
	m.routing_path = nil
	delete(m.clearedFields, route.FieldRoutingPath)
}

// SetRemark sets the "remark" field.
func (m *RouteMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RouteMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *RouteMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *RouteMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RouteMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RouteMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RouteMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RouteMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RouteMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the RouteMutation builder.
func (m *RouteMutation) Where(ps ...predicate.Route) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Route, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Route).
func (m *RouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.delete_time != nil {
		fields = append(fields, route.FieldDeleteTime)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, route.FieldScenicAreaID)
	}
	if m._type != nil {
		fields = append(fields, route.FieldType)
	}
	if m.name != nil {
		fields = append(fields, route.FieldName)
	}
	if m.poi_ids != nil {
		fields = append(fields, route.FieldPoiIds)
	}
	if m.routing_path != nil {
		fields = append(fields, route.FieldRoutingPath)
	}
	if m.remark != nil {
		fields = append(fields, route.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, route.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, route.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case route.FieldDeleteTime:
		return m.DeleteTime()
	case route.FieldScenicAreaID:
		return m.ScenicAreaID()
	case route.FieldType:
		return m.GetType()
	case route.FieldName:
		return m.Name()
	case route.FieldPoiIds:
		return m.PoiIds()
	case route.FieldRoutingPath:
		return m.RoutingPath()
	case route.FieldRemark:
		return m.Remark()
	case route.FieldCreateTime:
		return m.CreateTime()
	case route.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case route.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case route.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case route.FieldType:
		return m.OldType(ctx)
	case route.FieldName:
		return m.OldName(ctx)
	case route.FieldPoiIds:
		return m.OldPoiIds(ctx)
	case route.FieldRoutingPath:
		return m.OldRoutingPath(ctx)
	case route.FieldRemark:
		return m.OldRemark(ctx)
	case route.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case route.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Route field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case route.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case route.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case route.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case route.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case route.FieldPoiIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoiIds(v)
		return nil
	case route.FieldRoutingPath:
		v, ok := value.(*types.RoutingPath)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingPath(v)
		return nil
	case route.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case route.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case route.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, route.FieldScenicAreaID)
	}
	if m.add_type != nil {
		fields = append(fields, route.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case route.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case route.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case route.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case route.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Route numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(route.FieldDeleteTime) {
		fields = append(fields, route.FieldDeleteTime)
	}
	if m.FieldCleared(route.FieldRoutingPath) {
		fields = append(fields, route.FieldRoutingPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteMutation) ClearField(name string) error {
	switch name {
	case route.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case route.FieldRoutingPath:
		m.ClearRoutingPath()
		return nil
	}
	return fmt.Errorf("unknown Route nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteMutation) ResetField(name string) error {
	switch name {
	case route.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case route.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case route.FieldType:
		m.ResetType()
		return nil
	case route.FieldName:
		m.ResetName()
		return nil
	case route.FieldPoiIds:
		m.ResetPoiIds()
		return nil
	case route.FieldRoutingPath:
		m.ResetRoutingPath()
		return nil
	case route.FieldRemark:
		m.ResetRemark()
		return nil
	case route.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case route.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Route unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Route edge %s", name)
}

// ScenicAreaMutation represents an operation that mutates the ScenicArea nodes in the graph.
type ScenicAreaMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	code                          *string
	name                          *string
	address                       *string
	manager                       *string
	phone                         *string
	mch_id                        *string
	mch_name                      *string
	timezone                      *int
	addtimezone                   *int
	wgs_lon                       *float64
	addwgs_lon                    *float64
	wgs_lat                       *float64
	addwgs_lat                    *float64
	gcj_lon                       *float64
	addgcj_lon                    *float64
	gcj_lat                       *float64
	addgcj_lat                    *float64
	bd_lon                        *float64
	addbd_lon                     *float64
	bd_lat                        *float64
	addbd_lat                     *float64
	status                        *int
	addstatus                     *int
	extend_yokee_id               *int
	addextend_yokee_id            *int
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	cars                          map[int]struct{}
	removedcars                   map[int]struct{}
	clearedcars                   bool
	accounts                      map[int]struct{}
	removedaccounts               map[int]struct{}
	clearedaccounts               bool
	pois                          map[int]struct{}
	removedpois                   map[int]struct{}
	clearedpois                   bool
	profit_receivers              map[int]struct{}
	removedprofit_receivers       map[int]struct{}
	clearedprofit_receivers       bool
	pay_tx_bills                  map[int]struct{}
	removedpay_tx_bills           map[int]struct{}
	clearedpay_tx_bills           bool
	car_billing_strategies        map[int]struct{}
	removedcar_billing_strategies map[int]struct{}
	clearedcar_billing_strategies bool
	_map                          *int
	cleared_map                   bool
	map_versions                  map[int]struct{}
	removedmap_versions           map[int]struct{}
	clearedmap_versions           bool
	users                         map[int]struct{}
	removedusers                  map[int]struct{}
	clearedusers                  bool
	orders                        map[int]struct{}
	removedorders                 map[int]struct{}
	clearedorders                 bool
	car_operate_logs              map[int]struct{}
	removedcar_operate_logs       map[int]struct{}
	clearedcar_operate_logs       bool
	stats_hourly_car              map[int]struct{}
	removedstats_hourly_car       map[int]struct{}
	clearedstats_hourly_car       bool
	config_files                  map[int]struct{}
	removedconfig_files           map[int]struct{}
	clearedconfig_files           bool
	done                          bool
	oldValue                      func(context.Context) (*ScenicArea, error)
	predicates                    []predicate.ScenicArea
}

var _ ent.Mutation = (*ScenicAreaMutation)(nil)

// scenicareaOption allows management of the mutation configuration using functional options.
type scenicareaOption func(*ScenicAreaMutation)

// newScenicAreaMutation creates new mutation for the ScenicArea entity.
func newScenicAreaMutation(c config, op Op, opts ...scenicareaOption) *ScenicAreaMutation {
	m := &ScenicAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeScenicArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScenicAreaID sets the ID field of the mutation.
func withScenicAreaID(id int) scenicareaOption {
	return func(m *ScenicAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *ScenicArea
		)
		m.oldValue = func(ctx context.Context) (*ScenicArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScenicArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScenicArea sets the old ScenicArea of the mutation.
func withScenicArea(node *ScenicArea) scenicareaOption {
	return func(m *ScenicAreaMutation) {
		m.oldValue = func(context.Context) (*ScenicArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScenicAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScenicAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScenicArea entities.
func (m *ScenicAreaMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScenicAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScenicAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScenicArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ScenicAreaMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ScenicAreaMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ScenicAreaMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ScenicAreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScenicAreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScenicAreaMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *ScenicAreaMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ScenicAreaMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *ScenicAreaMutation) ResetAddress() {
	m.address = nil
}

// SetManager sets the "manager" field.
func (m *ScenicAreaMutation) SetManager(s string) {
	m.manager = &s
}

// Manager returns the value of the "manager" field in the mutation.
func (m *ScenicAreaMutation) Manager() (r string, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManager returns the old "manager" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldManager(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManager is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManager requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManager: %w", err)
	}
	return oldValue.Manager, nil
}

// ResetManager resets all changes to the "manager" field.
func (m *ScenicAreaMutation) ResetManager() {
	m.manager = nil
}

// SetPhone sets the "phone" field.
func (m *ScenicAreaMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ScenicAreaMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ScenicAreaMutation) ResetPhone() {
	m.phone = nil
}

// SetMchID sets the "mch_id" field.
func (m *ScenicAreaMutation) SetMchID(s string) {
	m.mch_id = &s
}

// MchID returns the value of the "mch_id" field in the mutation.
func (m *ScenicAreaMutation) MchID() (r string, exists bool) {
	v := m.mch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMchID returns the old "mch_id" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldMchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchID: %w", err)
	}
	return oldValue.MchID, nil
}

// ResetMchID resets all changes to the "mch_id" field.
func (m *ScenicAreaMutation) ResetMchID() {
	m.mch_id = nil
}

// SetMchName sets the "mch_name" field.
func (m *ScenicAreaMutation) SetMchName(s string) {
	m.mch_name = &s
}

// MchName returns the value of the "mch_name" field in the mutation.
func (m *ScenicAreaMutation) MchName() (r string, exists bool) {
	v := m.mch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMchName returns the old "mch_name" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldMchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMchName: %w", err)
	}
	return oldValue.MchName, nil
}

// ResetMchName resets all changes to the "mch_name" field.
func (m *ScenicAreaMutation) ResetMchName() {
	m.mch_name = nil
}

// SetTimezone sets the "timezone" field.
func (m *ScenicAreaMutation) SetTimezone(i int) {
	m.timezone = &i
	m.addtimezone = nil
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *ScenicAreaMutation) Timezone() (r int, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldTimezone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// AddTimezone adds i to the "timezone" field.
func (m *ScenicAreaMutation) AddTimezone(i int) {
	if m.addtimezone != nil {
		*m.addtimezone += i
	} else {
		m.addtimezone = &i
	}
}

// AddedTimezone returns the value that was added to the "timezone" field in this mutation.
func (m *ScenicAreaMutation) AddedTimezone() (r int, exists bool) {
	v := m.addtimezone
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *ScenicAreaMutation) ResetTimezone() {
	m.timezone = nil
	m.addtimezone = nil
}

// SetWgsLon sets the "wgs_lon" field.
func (m *ScenicAreaMutation) SetWgsLon(f float64) {
	m.wgs_lon = &f
	m.addwgs_lon = nil
}

// WgsLon returns the value of the "wgs_lon" field in the mutation.
func (m *ScenicAreaMutation) WgsLon() (r float64, exists bool) {
	v := m.wgs_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldWgsLon returns the old "wgs_lon" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldWgsLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWgsLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWgsLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWgsLon: %w", err)
	}
	return oldValue.WgsLon, nil
}

// AddWgsLon adds f to the "wgs_lon" field.
func (m *ScenicAreaMutation) AddWgsLon(f float64) {
	if m.addwgs_lon != nil {
		*m.addwgs_lon += f
	} else {
		m.addwgs_lon = &f
	}
}

// AddedWgsLon returns the value that was added to the "wgs_lon" field in this mutation.
func (m *ScenicAreaMutation) AddedWgsLon() (r float64, exists bool) {
	v := m.addwgs_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetWgsLon resets all changes to the "wgs_lon" field.
func (m *ScenicAreaMutation) ResetWgsLon() {
	m.wgs_lon = nil
	m.addwgs_lon = nil
}

// SetWgsLat sets the "wgs_lat" field.
func (m *ScenicAreaMutation) SetWgsLat(f float64) {
	m.wgs_lat = &f
	m.addwgs_lat = nil
}

// WgsLat returns the value of the "wgs_lat" field in the mutation.
func (m *ScenicAreaMutation) WgsLat() (r float64, exists bool) {
	v := m.wgs_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldWgsLat returns the old "wgs_lat" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldWgsLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWgsLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWgsLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWgsLat: %w", err)
	}
	return oldValue.WgsLat, nil
}

// AddWgsLat adds f to the "wgs_lat" field.
func (m *ScenicAreaMutation) AddWgsLat(f float64) {
	if m.addwgs_lat != nil {
		*m.addwgs_lat += f
	} else {
		m.addwgs_lat = &f
	}
}

// AddedWgsLat returns the value that was added to the "wgs_lat" field in this mutation.
func (m *ScenicAreaMutation) AddedWgsLat() (r float64, exists bool) {
	v := m.addwgs_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetWgsLat resets all changes to the "wgs_lat" field.
func (m *ScenicAreaMutation) ResetWgsLat() {
	m.wgs_lat = nil
	m.addwgs_lat = nil
}

// SetGcjLon sets the "gcj_lon" field.
func (m *ScenicAreaMutation) SetGcjLon(f float64) {
	m.gcj_lon = &f
	m.addgcj_lon = nil
}

// GcjLon returns the value of the "gcj_lon" field in the mutation.
func (m *ScenicAreaMutation) GcjLon() (r float64, exists bool) {
	v := m.gcj_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldGcjLon returns the old "gcj_lon" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldGcjLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGcjLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGcjLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGcjLon: %w", err)
	}
	return oldValue.GcjLon, nil
}

// AddGcjLon adds f to the "gcj_lon" field.
func (m *ScenicAreaMutation) AddGcjLon(f float64) {
	if m.addgcj_lon != nil {
		*m.addgcj_lon += f
	} else {
		m.addgcj_lon = &f
	}
}

// AddedGcjLon returns the value that was added to the "gcj_lon" field in this mutation.
func (m *ScenicAreaMutation) AddedGcjLon() (r float64, exists bool) {
	v := m.addgcj_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetGcjLon resets all changes to the "gcj_lon" field.
func (m *ScenicAreaMutation) ResetGcjLon() {
	m.gcj_lon = nil
	m.addgcj_lon = nil
}

// SetGcjLat sets the "gcj_lat" field.
func (m *ScenicAreaMutation) SetGcjLat(f float64) {
	m.gcj_lat = &f
	m.addgcj_lat = nil
}

// GcjLat returns the value of the "gcj_lat" field in the mutation.
func (m *ScenicAreaMutation) GcjLat() (r float64, exists bool) {
	v := m.gcj_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldGcjLat returns the old "gcj_lat" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldGcjLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGcjLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGcjLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGcjLat: %w", err)
	}
	return oldValue.GcjLat, nil
}

// AddGcjLat adds f to the "gcj_lat" field.
func (m *ScenicAreaMutation) AddGcjLat(f float64) {
	if m.addgcj_lat != nil {
		*m.addgcj_lat += f
	} else {
		m.addgcj_lat = &f
	}
}

// AddedGcjLat returns the value that was added to the "gcj_lat" field in this mutation.
func (m *ScenicAreaMutation) AddedGcjLat() (r float64, exists bool) {
	v := m.addgcj_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetGcjLat resets all changes to the "gcj_lat" field.
func (m *ScenicAreaMutation) ResetGcjLat() {
	m.gcj_lat = nil
	m.addgcj_lat = nil
}

// SetBdLon sets the "bd_lon" field.
func (m *ScenicAreaMutation) SetBdLon(f float64) {
	m.bd_lon = &f
	m.addbd_lon = nil
}

// BdLon returns the value of the "bd_lon" field in the mutation.
func (m *ScenicAreaMutation) BdLon() (r float64, exists bool) {
	v := m.bd_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldBdLon returns the old "bd_lon" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldBdLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBdLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBdLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBdLon: %w", err)
	}
	return oldValue.BdLon, nil
}

// AddBdLon adds f to the "bd_lon" field.
func (m *ScenicAreaMutation) AddBdLon(f float64) {
	if m.addbd_lon != nil {
		*m.addbd_lon += f
	} else {
		m.addbd_lon = &f
	}
}

// AddedBdLon returns the value that was added to the "bd_lon" field in this mutation.
func (m *ScenicAreaMutation) AddedBdLon() (r float64, exists bool) {
	v := m.addbd_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetBdLon resets all changes to the "bd_lon" field.
func (m *ScenicAreaMutation) ResetBdLon() {
	m.bd_lon = nil
	m.addbd_lon = nil
}

// SetBdLat sets the "bd_lat" field.
func (m *ScenicAreaMutation) SetBdLat(f float64) {
	m.bd_lat = &f
	m.addbd_lat = nil
}

// BdLat returns the value of the "bd_lat" field in the mutation.
func (m *ScenicAreaMutation) BdLat() (r float64, exists bool) {
	v := m.bd_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldBdLat returns the old "bd_lat" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldBdLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBdLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBdLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBdLat: %w", err)
	}
	return oldValue.BdLat, nil
}

// AddBdLat adds f to the "bd_lat" field.
func (m *ScenicAreaMutation) AddBdLat(f float64) {
	if m.addbd_lat != nil {
		*m.addbd_lat += f
	} else {
		m.addbd_lat = &f
	}
}

// AddedBdLat returns the value that was added to the "bd_lat" field in this mutation.
func (m *ScenicAreaMutation) AddedBdLat() (r float64, exists bool) {
	v := m.addbd_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetBdLat resets all changes to the "bd_lat" field.
func (m *ScenicAreaMutation) ResetBdLat() {
	m.bd_lat = nil
	m.addbd_lat = nil
}

// SetStatus sets the "status" field.
func (m *ScenicAreaMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScenicAreaMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScenicAreaMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScenicAreaMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ScenicAreaMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetExtendYokeeID sets the "extend_yokee_id" field.
func (m *ScenicAreaMutation) SetExtendYokeeID(i int) {
	m.extend_yokee_id = &i
	m.addextend_yokee_id = nil
}

// ExtendYokeeID returns the value of the "extend_yokee_id" field in the mutation.
func (m *ScenicAreaMutation) ExtendYokeeID() (r int, exists bool) {
	v := m.extend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendYokeeID returns the old "extend_yokee_id" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldExtendYokeeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendYokeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendYokeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendYokeeID: %w", err)
	}
	return oldValue.ExtendYokeeID, nil
}

// AddExtendYokeeID adds i to the "extend_yokee_id" field.
func (m *ScenicAreaMutation) AddExtendYokeeID(i int) {
	if m.addextend_yokee_id != nil {
		*m.addextend_yokee_id += i
	} else {
		m.addextend_yokee_id = &i
	}
}

// AddedExtendYokeeID returns the value that was added to the "extend_yokee_id" field in this mutation.
func (m *ScenicAreaMutation) AddedExtendYokeeID() (r int, exists bool) {
	v := m.addextend_yokee_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtendYokeeID clears the value of the "extend_yokee_id" field.
func (m *ScenicAreaMutation) ClearExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	m.clearedFields[scenicarea.FieldExtendYokeeID] = struct{}{}
}

// ExtendYokeeIDCleared returns if the "extend_yokee_id" field was cleared in this mutation.
func (m *ScenicAreaMutation) ExtendYokeeIDCleared() bool {
	_, ok := m.clearedFields[scenicarea.FieldExtendYokeeID]
	return ok
}

// ResetExtendYokeeID resets all changes to the "extend_yokee_id" field.
func (m *ScenicAreaMutation) ResetExtendYokeeID() {
	m.extend_yokee_id = nil
	m.addextend_yokee_id = nil
	delete(m.clearedFields, scenicarea.FieldExtendYokeeID)
}

// SetCreateTime sets the "create_time" field.
func (m *ScenicAreaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScenicAreaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScenicAreaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScenicAreaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScenicAreaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScenicArea entity.
// If the ScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScenicAreaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddCarIDs adds the "cars" edge to the Car entity by ids.
func (m *ScenicAreaMutation) AddCarIDs(ids ...int) {
	if m.cars == nil {
		m.cars = make(map[int]struct{})
	}
	for i := range ids {
		m.cars[ids[i]] = struct{}{}
	}
}

// ClearCars clears the "cars" edge to the Car entity.
func (m *ScenicAreaMutation) ClearCars() {
	m.clearedcars = true
}

// CarsCleared reports if the "cars" edge to the Car entity was cleared.
func (m *ScenicAreaMutation) CarsCleared() bool {
	return m.clearedcars
}

// RemoveCarIDs removes the "cars" edge to the Car entity by IDs.
func (m *ScenicAreaMutation) RemoveCarIDs(ids ...int) {
	if m.removedcars == nil {
		m.removedcars = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cars, ids[i])
		m.removedcars[ids[i]] = struct{}{}
	}
}

// RemovedCars returns the removed IDs of the "cars" edge to the Car entity.
func (m *ScenicAreaMutation) RemovedCarsIDs() (ids []int) {
	for id := range m.removedcars {
		ids = append(ids, id)
	}
	return
}

// CarsIDs returns the "cars" edge IDs in the mutation.
func (m *ScenicAreaMutation) CarsIDs() (ids []int) {
	for id := range m.cars {
		ids = append(ids, id)
	}
	return
}

// ResetCars resets all changes to the "cars" edge.
func (m *ScenicAreaMutation) ResetCars() {
	m.cars = nil
	m.clearedcars = false
	m.removedcars = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *ScenicAreaMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *ScenicAreaMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *ScenicAreaMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *ScenicAreaMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *ScenicAreaMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *ScenicAreaMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *ScenicAreaMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddPoiIDs adds the "pois" edge to the Poi entity by ids.
func (m *ScenicAreaMutation) AddPoiIDs(ids ...int) {
	if m.pois == nil {
		m.pois = make(map[int]struct{})
	}
	for i := range ids {
		m.pois[ids[i]] = struct{}{}
	}
}

// ClearPois clears the "pois" edge to the Poi entity.
func (m *ScenicAreaMutation) ClearPois() {
	m.clearedpois = true
}

// PoisCleared reports if the "pois" edge to the Poi entity was cleared.
func (m *ScenicAreaMutation) PoisCleared() bool {
	return m.clearedpois
}

// RemovePoiIDs removes the "pois" edge to the Poi entity by IDs.
func (m *ScenicAreaMutation) RemovePoiIDs(ids ...int) {
	if m.removedpois == nil {
		m.removedpois = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pois, ids[i])
		m.removedpois[ids[i]] = struct{}{}
	}
}

// RemovedPois returns the removed IDs of the "pois" edge to the Poi entity.
func (m *ScenicAreaMutation) RemovedPoisIDs() (ids []int) {
	for id := range m.removedpois {
		ids = append(ids, id)
	}
	return
}

// PoisIDs returns the "pois" edge IDs in the mutation.
func (m *ScenicAreaMutation) PoisIDs() (ids []int) {
	for id := range m.pois {
		ids = append(ids, id)
	}
	return
}

// ResetPois resets all changes to the "pois" edge.
func (m *ScenicAreaMutation) ResetPois() {
	m.pois = nil
	m.clearedpois = false
	m.removedpois = nil
}

// AddProfitReceiverIDs adds the "profit_receivers" edge to the ProfitReceiver entity by ids.
func (m *ScenicAreaMutation) AddProfitReceiverIDs(ids ...int) {
	if m.profit_receivers == nil {
		m.profit_receivers = make(map[int]struct{})
	}
	for i := range ids {
		m.profit_receivers[ids[i]] = struct{}{}
	}
}

// ClearProfitReceivers clears the "profit_receivers" edge to the ProfitReceiver entity.
func (m *ScenicAreaMutation) ClearProfitReceivers() {
	m.clearedprofit_receivers = true
}

// ProfitReceiversCleared reports if the "profit_receivers" edge to the ProfitReceiver entity was cleared.
func (m *ScenicAreaMutation) ProfitReceiversCleared() bool {
	return m.clearedprofit_receivers
}

// RemoveProfitReceiverIDs removes the "profit_receivers" edge to the ProfitReceiver entity by IDs.
func (m *ScenicAreaMutation) RemoveProfitReceiverIDs(ids ...int) {
	if m.removedprofit_receivers == nil {
		m.removedprofit_receivers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profit_receivers, ids[i])
		m.removedprofit_receivers[ids[i]] = struct{}{}
	}
}

// RemovedProfitReceivers returns the removed IDs of the "profit_receivers" edge to the ProfitReceiver entity.
func (m *ScenicAreaMutation) RemovedProfitReceiversIDs() (ids []int) {
	for id := range m.removedprofit_receivers {
		ids = append(ids, id)
	}
	return
}

// ProfitReceiversIDs returns the "profit_receivers" edge IDs in the mutation.
func (m *ScenicAreaMutation) ProfitReceiversIDs() (ids []int) {
	for id := range m.profit_receivers {
		ids = append(ids, id)
	}
	return
}

// ResetProfitReceivers resets all changes to the "profit_receivers" edge.
func (m *ScenicAreaMutation) ResetProfitReceivers() {
	m.profit_receivers = nil
	m.clearedprofit_receivers = false
	m.removedprofit_receivers = nil
}

// AddPayTxBillIDs adds the "pay_tx_bills" edge to the PayTxBill entity by ids.
func (m *ScenicAreaMutation) AddPayTxBillIDs(ids ...int) {
	if m.pay_tx_bills == nil {
		m.pay_tx_bills = make(map[int]struct{})
	}
	for i := range ids {
		m.pay_tx_bills[ids[i]] = struct{}{}
	}
}

// ClearPayTxBills clears the "pay_tx_bills" edge to the PayTxBill entity.
func (m *ScenicAreaMutation) ClearPayTxBills() {
	m.clearedpay_tx_bills = true
}

// PayTxBillsCleared reports if the "pay_tx_bills" edge to the PayTxBill entity was cleared.
func (m *ScenicAreaMutation) PayTxBillsCleared() bool {
	return m.clearedpay_tx_bills
}

// RemovePayTxBillIDs removes the "pay_tx_bills" edge to the PayTxBill entity by IDs.
func (m *ScenicAreaMutation) RemovePayTxBillIDs(ids ...int) {
	if m.removedpay_tx_bills == nil {
		m.removedpay_tx_bills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.pay_tx_bills, ids[i])
		m.removedpay_tx_bills[ids[i]] = struct{}{}
	}
}

// RemovedPayTxBills returns the removed IDs of the "pay_tx_bills" edge to the PayTxBill entity.
func (m *ScenicAreaMutation) RemovedPayTxBillsIDs() (ids []int) {
	for id := range m.removedpay_tx_bills {
		ids = append(ids, id)
	}
	return
}

// PayTxBillsIDs returns the "pay_tx_bills" edge IDs in the mutation.
func (m *ScenicAreaMutation) PayTxBillsIDs() (ids []int) {
	for id := range m.pay_tx_bills {
		ids = append(ids, id)
	}
	return
}

// ResetPayTxBills resets all changes to the "pay_tx_bills" edge.
func (m *ScenicAreaMutation) ResetPayTxBills() {
	m.pay_tx_bills = nil
	m.clearedpay_tx_bills = false
	m.removedpay_tx_bills = nil
}

// AddCarBillingStrategyIDs adds the "car_billing_strategies" edge to the BillingStrategy entity by ids.
func (m *ScenicAreaMutation) AddCarBillingStrategyIDs(ids ...int) {
	if m.car_billing_strategies == nil {
		m.car_billing_strategies = make(map[int]struct{})
	}
	for i := range ids {
		m.car_billing_strategies[ids[i]] = struct{}{}
	}
}

// ClearCarBillingStrategies clears the "car_billing_strategies" edge to the BillingStrategy entity.
func (m *ScenicAreaMutation) ClearCarBillingStrategies() {
	m.clearedcar_billing_strategies = true
}

// CarBillingStrategiesCleared reports if the "car_billing_strategies" edge to the BillingStrategy entity was cleared.
func (m *ScenicAreaMutation) CarBillingStrategiesCleared() bool {
	return m.clearedcar_billing_strategies
}

// RemoveCarBillingStrategyIDs removes the "car_billing_strategies" edge to the BillingStrategy entity by IDs.
func (m *ScenicAreaMutation) RemoveCarBillingStrategyIDs(ids ...int) {
	if m.removedcar_billing_strategies == nil {
		m.removedcar_billing_strategies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.car_billing_strategies, ids[i])
		m.removedcar_billing_strategies[ids[i]] = struct{}{}
	}
}

// RemovedCarBillingStrategies returns the removed IDs of the "car_billing_strategies" edge to the BillingStrategy entity.
func (m *ScenicAreaMutation) RemovedCarBillingStrategiesIDs() (ids []int) {
	for id := range m.removedcar_billing_strategies {
		ids = append(ids, id)
	}
	return
}

// CarBillingStrategiesIDs returns the "car_billing_strategies" edge IDs in the mutation.
func (m *ScenicAreaMutation) CarBillingStrategiesIDs() (ids []int) {
	for id := range m.car_billing_strategies {
		ids = append(ids, id)
	}
	return
}

// ResetCarBillingStrategies resets all changes to the "car_billing_strategies" edge.
func (m *ScenicAreaMutation) ResetCarBillingStrategies() {
	m.car_billing_strategies = nil
	m.clearedcar_billing_strategies = false
	m.removedcar_billing_strategies = nil
}

// SetMapID sets the "map" edge to the ScenicAreaMap entity by id.
func (m *ScenicAreaMutation) SetMapID(id int) {
	m._map = &id
}

// ClearMap clears the "map" edge to the ScenicAreaMap entity.
func (m *ScenicAreaMutation) ClearMap() {
	m.cleared_map = true
}

// MapCleared reports if the "map" edge to the ScenicAreaMap entity was cleared.
func (m *ScenicAreaMutation) MapCleared() bool {
	return m.cleared_map
}

// MapID returns the "map" edge ID in the mutation.
func (m *ScenicAreaMutation) MapID() (id int, exists bool) {
	if m._map != nil {
		return *m._map, true
	}
	return
}

// MapIDs returns the "map" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MapID instead. It exists only for internal usage by the builders.
func (m *ScenicAreaMutation) MapIDs() (ids []int) {
	if id := m._map; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMap resets all changes to the "map" edge.
func (m *ScenicAreaMutation) ResetMap() {
	m._map = nil
	m.cleared_map = false
}

// AddMapVersionIDs adds the "map_versions" edge to the MapVersion entity by ids.
func (m *ScenicAreaMutation) AddMapVersionIDs(ids ...int) {
	if m.map_versions == nil {
		m.map_versions = make(map[int]struct{})
	}
	for i := range ids {
		m.map_versions[ids[i]] = struct{}{}
	}
}

// ClearMapVersions clears the "map_versions" edge to the MapVersion entity.
func (m *ScenicAreaMutation) ClearMapVersions() {
	m.clearedmap_versions = true
}

// MapVersionsCleared reports if the "map_versions" edge to the MapVersion entity was cleared.
func (m *ScenicAreaMutation) MapVersionsCleared() bool {
	return m.clearedmap_versions
}

// RemoveMapVersionIDs removes the "map_versions" edge to the MapVersion entity by IDs.
func (m *ScenicAreaMutation) RemoveMapVersionIDs(ids ...int) {
	if m.removedmap_versions == nil {
		m.removedmap_versions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.map_versions, ids[i])
		m.removedmap_versions[ids[i]] = struct{}{}
	}
}

// RemovedMapVersions returns the removed IDs of the "map_versions" edge to the MapVersion entity.
func (m *ScenicAreaMutation) RemovedMapVersionsIDs() (ids []int) {
	for id := range m.removedmap_versions {
		ids = append(ids, id)
	}
	return
}

// MapVersionsIDs returns the "map_versions" edge IDs in the mutation.
func (m *ScenicAreaMutation) MapVersionsIDs() (ids []int) {
	for id := range m.map_versions {
		ids = append(ids, id)
	}
	return
}

// ResetMapVersions resets all changes to the "map_versions" edge.
func (m *ScenicAreaMutation) ResetMapVersions() {
	m.map_versions = nil
	m.clearedmap_versions = false
	m.removedmap_versions = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ScenicAreaMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ScenicAreaMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ScenicAreaMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ScenicAreaMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ScenicAreaMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ScenicAreaMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ScenicAreaMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *ScenicAreaMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *ScenicAreaMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *ScenicAreaMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *ScenicAreaMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *ScenicAreaMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ScenicAreaMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ScenicAreaMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddCarOperateLogIDs adds the "car_operate_logs" edge to the CarsOperateLog entity by ids.
func (m *ScenicAreaMutation) AddCarOperateLogIDs(ids ...int) {
	if m.car_operate_logs == nil {
		m.car_operate_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.car_operate_logs[ids[i]] = struct{}{}
	}
}

// ClearCarOperateLogs clears the "car_operate_logs" edge to the CarsOperateLog entity.
func (m *ScenicAreaMutation) ClearCarOperateLogs() {
	m.clearedcar_operate_logs = true
}

// CarOperateLogsCleared reports if the "car_operate_logs" edge to the CarsOperateLog entity was cleared.
func (m *ScenicAreaMutation) CarOperateLogsCleared() bool {
	return m.clearedcar_operate_logs
}

// RemoveCarOperateLogIDs removes the "car_operate_logs" edge to the CarsOperateLog entity by IDs.
func (m *ScenicAreaMutation) RemoveCarOperateLogIDs(ids ...int) {
	if m.removedcar_operate_logs == nil {
		m.removedcar_operate_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.car_operate_logs, ids[i])
		m.removedcar_operate_logs[ids[i]] = struct{}{}
	}
}

// RemovedCarOperateLogs returns the removed IDs of the "car_operate_logs" edge to the CarsOperateLog entity.
func (m *ScenicAreaMutation) RemovedCarOperateLogsIDs() (ids []int) {
	for id := range m.removedcar_operate_logs {
		ids = append(ids, id)
	}
	return
}

// CarOperateLogsIDs returns the "car_operate_logs" edge IDs in the mutation.
func (m *ScenicAreaMutation) CarOperateLogsIDs() (ids []int) {
	for id := range m.car_operate_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCarOperateLogs resets all changes to the "car_operate_logs" edge.
func (m *ScenicAreaMutation) ResetCarOperateLogs() {
	m.car_operate_logs = nil
	m.clearedcar_operate_logs = false
	m.removedcar_operate_logs = nil
}

// AddStatsHourlyCarIDs adds the "stats_hourly_car" edge to the StatsHourlyCar entity by ids.
func (m *ScenicAreaMutation) AddStatsHourlyCarIDs(ids ...int) {
	if m.stats_hourly_car == nil {
		m.stats_hourly_car = make(map[int]struct{})
	}
	for i := range ids {
		m.stats_hourly_car[ids[i]] = struct{}{}
	}
}

// ClearStatsHourlyCar clears the "stats_hourly_car" edge to the StatsHourlyCar entity.
func (m *ScenicAreaMutation) ClearStatsHourlyCar() {
	m.clearedstats_hourly_car = true
}

// StatsHourlyCarCleared reports if the "stats_hourly_car" edge to the StatsHourlyCar entity was cleared.
func (m *ScenicAreaMutation) StatsHourlyCarCleared() bool {
	return m.clearedstats_hourly_car
}

// RemoveStatsHourlyCarIDs removes the "stats_hourly_car" edge to the StatsHourlyCar entity by IDs.
func (m *ScenicAreaMutation) RemoveStatsHourlyCarIDs(ids ...int) {
	if m.removedstats_hourly_car == nil {
		m.removedstats_hourly_car = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stats_hourly_car, ids[i])
		m.removedstats_hourly_car[ids[i]] = struct{}{}
	}
}

// RemovedStatsHourlyCar returns the removed IDs of the "stats_hourly_car" edge to the StatsHourlyCar entity.
func (m *ScenicAreaMutation) RemovedStatsHourlyCarIDs() (ids []int) {
	for id := range m.removedstats_hourly_car {
		ids = append(ids, id)
	}
	return
}

// StatsHourlyCarIDs returns the "stats_hourly_car" edge IDs in the mutation.
func (m *ScenicAreaMutation) StatsHourlyCarIDs() (ids []int) {
	for id := range m.stats_hourly_car {
		ids = append(ids, id)
	}
	return
}

// ResetStatsHourlyCar resets all changes to the "stats_hourly_car" edge.
func (m *ScenicAreaMutation) ResetStatsHourlyCar() {
	m.stats_hourly_car = nil
	m.clearedstats_hourly_car = false
	m.removedstats_hourly_car = nil
}

// AddConfigFileIDs adds the "config_files" edge to the CarConfig entity by ids.
func (m *ScenicAreaMutation) AddConfigFileIDs(ids ...int) {
	if m.config_files == nil {
		m.config_files = make(map[int]struct{})
	}
	for i := range ids {
		m.config_files[ids[i]] = struct{}{}
	}
}

// ClearConfigFiles clears the "config_files" edge to the CarConfig entity.
func (m *ScenicAreaMutation) ClearConfigFiles() {
	m.clearedconfig_files = true
}

// ConfigFilesCleared reports if the "config_files" edge to the CarConfig entity was cleared.
func (m *ScenicAreaMutation) ConfigFilesCleared() bool {
	return m.clearedconfig_files
}

// RemoveConfigFileIDs removes the "config_files" edge to the CarConfig entity by IDs.
func (m *ScenicAreaMutation) RemoveConfigFileIDs(ids ...int) {
	if m.removedconfig_files == nil {
		m.removedconfig_files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.config_files, ids[i])
		m.removedconfig_files[ids[i]] = struct{}{}
	}
}

// RemovedConfigFiles returns the removed IDs of the "config_files" edge to the CarConfig entity.
func (m *ScenicAreaMutation) RemovedConfigFilesIDs() (ids []int) {
	for id := range m.removedconfig_files {
		ids = append(ids, id)
	}
	return
}

// ConfigFilesIDs returns the "config_files" edge IDs in the mutation.
func (m *ScenicAreaMutation) ConfigFilesIDs() (ids []int) {
	for id := range m.config_files {
		ids = append(ids, id)
	}
	return
}

// ResetConfigFiles resets all changes to the "config_files" edge.
func (m *ScenicAreaMutation) ResetConfigFiles() {
	m.config_files = nil
	m.clearedconfig_files = false
	m.removedconfig_files = nil
}

// Where appends a list predicates to the ScenicAreaMutation builder.
func (m *ScenicAreaMutation) Where(ps ...predicate.ScenicArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScenicAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScenicAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScenicArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScenicAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScenicAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScenicArea).
func (m *ScenicAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScenicAreaMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.code != nil {
		fields = append(fields, scenicarea.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, scenicarea.FieldName)
	}
	if m.address != nil {
		fields = append(fields, scenicarea.FieldAddress)
	}
	if m.manager != nil {
		fields = append(fields, scenicarea.FieldManager)
	}
	if m.phone != nil {
		fields = append(fields, scenicarea.FieldPhone)
	}
	if m.mch_id != nil {
		fields = append(fields, scenicarea.FieldMchID)
	}
	if m.mch_name != nil {
		fields = append(fields, scenicarea.FieldMchName)
	}
	if m.timezone != nil {
		fields = append(fields, scenicarea.FieldTimezone)
	}
	if m.wgs_lon != nil {
		fields = append(fields, scenicarea.FieldWgsLon)
	}
	if m.wgs_lat != nil {
		fields = append(fields, scenicarea.FieldWgsLat)
	}
	if m.gcj_lon != nil {
		fields = append(fields, scenicarea.FieldGcjLon)
	}
	if m.gcj_lat != nil {
		fields = append(fields, scenicarea.FieldGcjLat)
	}
	if m.bd_lon != nil {
		fields = append(fields, scenicarea.FieldBdLon)
	}
	if m.bd_lat != nil {
		fields = append(fields, scenicarea.FieldBdLat)
	}
	if m.status != nil {
		fields = append(fields, scenicarea.FieldStatus)
	}
	if m.extend_yokee_id != nil {
		fields = append(fields, scenicarea.FieldExtendYokeeID)
	}
	if m.create_time != nil {
		fields = append(fields, scenicarea.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scenicarea.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScenicAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scenicarea.FieldCode:
		return m.Code()
	case scenicarea.FieldName:
		return m.Name()
	case scenicarea.FieldAddress:
		return m.Address()
	case scenicarea.FieldManager:
		return m.Manager()
	case scenicarea.FieldPhone:
		return m.Phone()
	case scenicarea.FieldMchID:
		return m.MchID()
	case scenicarea.FieldMchName:
		return m.MchName()
	case scenicarea.FieldTimezone:
		return m.Timezone()
	case scenicarea.FieldWgsLon:
		return m.WgsLon()
	case scenicarea.FieldWgsLat:
		return m.WgsLat()
	case scenicarea.FieldGcjLon:
		return m.GcjLon()
	case scenicarea.FieldGcjLat:
		return m.GcjLat()
	case scenicarea.FieldBdLon:
		return m.BdLon()
	case scenicarea.FieldBdLat:
		return m.BdLat()
	case scenicarea.FieldStatus:
		return m.Status()
	case scenicarea.FieldExtendYokeeID:
		return m.ExtendYokeeID()
	case scenicarea.FieldCreateTime:
		return m.CreateTime()
	case scenicarea.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScenicAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scenicarea.FieldCode:
		return m.OldCode(ctx)
	case scenicarea.FieldName:
		return m.OldName(ctx)
	case scenicarea.FieldAddress:
		return m.OldAddress(ctx)
	case scenicarea.FieldManager:
		return m.OldManager(ctx)
	case scenicarea.FieldPhone:
		return m.OldPhone(ctx)
	case scenicarea.FieldMchID:
		return m.OldMchID(ctx)
	case scenicarea.FieldMchName:
		return m.OldMchName(ctx)
	case scenicarea.FieldTimezone:
		return m.OldTimezone(ctx)
	case scenicarea.FieldWgsLon:
		return m.OldWgsLon(ctx)
	case scenicarea.FieldWgsLat:
		return m.OldWgsLat(ctx)
	case scenicarea.FieldGcjLon:
		return m.OldGcjLon(ctx)
	case scenicarea.FieldGcjLat:
		return m.OldGcjLat(ctx)
	case scenicarea.FieldBdLon:
		return m.OldBdLon(ctx)
	case scenicarea.FieldBdLat:
		return m.OldBdLat(ctx)
	case scenicarea.FieldStatus:
		return m.OldStatus(ctx)
	case scenicarea.FieldExtendYokeeID:
		return m.OldExtendYokeeID(ctx)
	case scenicarea.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scenicarea.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScenicArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scenicarea.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case scenicarea.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scenicarea.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case scenicarea.FieldManager:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManager(v)
		return nil
	case scenicarea.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case scenicarea.FieldMchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchID(v)
		return nil
	case scenicarea.FieldMchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMchName(v)
		return nil
	case scenicarea.FieldTimezone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case scenicarea.FieldWgsLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWgsLon(v)
		return nil
	case scenicarea.FieldWgsLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWgsLat(v)
		return nil
	case scenicarea.FieldGcjLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGcjLon(v)
		return nil
	case scenicarea.FieldGcjLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGcjLat(v)
		return nil
	case scenicarea.FieldBdLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBdLon(v)
		return nil
	case scenicarea.FieldBdLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBdLat(v)
		return nil
	case scenicarea.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case scenicarea.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendYokeeID(v)
		return nil
	case scenicarea.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scenicarea.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScenicAreaMutation) AddedFields() []string {
	var fields []string
	if m.addtimezone != nil {
		fields = append(fields, scenicarea.FieldTimezone)
	}
	if m.addwgs_lon != nil {
		fields = append(fields, scenicarea.FieldWgsLon)
	}
	if m.addwgs_lat != nil {
		fields = append(fields, scenicarea.FieldWgsLat)
	}
	if m.addgcj_lon != nil {
		fields = append(fields, scenicarea.FieldGcjLon)
	}
	if m.addgcj_lat != nil {
		fields = append(fields, scenicarea.FieldGcjLat)
	}
	if m.addbd_lon != nil {
		fields = append(fields, scenicarea.FieldBdLon)
	}
	if m.addbd_lat != nil {
		fields = append(fields, scenicarea.FieldBdLat)
	}
	if m.addstatus != nil {
		fields = append(fields, scenicarea.FieldStatus)
	}
	if m.addextend_yokee_id != nil {
		fields = append(fields, scenicarea.FieldExtendYokeeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScenicAreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scenicarea.FieldTimezone:
		return m.AddedTimezone()
	case scenicarea.FieldWgsLon:
		return m.AddedWgsLon()
	case scenicarea.FieldWgsLat:
		return m.AddedWgsLat()
	case scenicarea.FieldGcjLon:
		return m.AddedGcjLon()
	case scenicarea.FieldGcjLat:
		return m.AddedGcjLat()
	case scenicarea.FieldBdLon:
		return m.AddedBdLon()
	case scenicarea.FieldBdLat:
		return m.AddedBdLat()
	case scenicarea.FieldStatus:
		return m.AddedStatus()
	case scenicarea.FieldExtendYokeeID:
		return m.AddedExtendYokeeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scenicarea.FieldTimezone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimezone(v)
		return nil
	case scenicarea.FieldWgsLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWgsLon(v)
		return nil
	case scenicarea.FieldWgsLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWgsLat(v)
		return nil
	case scenicarea.FieldGcjLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGcjLon(v)
		return nil
	case scenicarea.FieldGcjLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGcjLat(v)
		return nil
	case scenicarea.FieldBdLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBdLon(v)
		return nil
	case scenicarea.FieldBdLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBdLat(v)
		return nil
	case scenicarea.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case scenicarea.FieldExtendYokeeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtendYokeeID(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScenicAreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scenicarea.FieldExtendYokeeID) {
		fields = append(fields, scenicarea.FieldExtendYokeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScenicAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScenicAreaMutation) ClearField(name string) error {
	switch name {
	case scenicarea.FieldExtendYokeeID:
		m.ClearExtendYokeeID()
		return nil
	}
	return fmt.Errorf("unknown ScenicArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScenicAreaMutation) ResetField(name string) error {
	switch name {
	case scenicarea.FieldCode:
		m.ResetCode()
		return nil
	case scenicarea.FieldName:
		m.ResetName()
		return nil
	case scenicarea.FieldAddress:
		m.ResetAddress()
		return nil
	case scenicarea.FieldManager:
		m.ResetManager()
		return nil
	case scenicarea.FieldPhone:
		m.ResetPhone()
		return nil
	case scenicarea.FieldMchID:
		m.ResetMchID()
		return nil
	case scenicarea.FieldMchName:
		m.ResetMchName()
		return nil
	case scenicarea.FieldTimezone:
		m.ResetTimezone()
		return nil
	case scenicarea.FieldWgsLon:
		m.ResetWgsLon()
		return nil
	case scenicarea.FieldWgsLat:
		m.ResetWgsLat()
		return nil
	case scenicarea.FieldGcjLon:
		m.ResetGcjLon()
		return nil
	case scenicarea.FieldGcjLat:
		m.ResetGcjLat()
		return nil
	case scenicarea.FieldBdLon:
		m.ResetBdLon()
		return nil
	case scenicarea.FieldBdLat:
		m.ResetBdLat()
		return nil
	case scenicarea.FieldStatus:
		m.ResetStatus()
		return nil
	case scenicarea.FieldExtendYokeeID:
		m.ResetExtendYokeeID()
		return nil
	case scenicarea.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scenicarea.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ScenicArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScenicAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.cars != nil {
		edges = append(edges, scenicarea.EdgeCars)
	}
	if m.accounts != nil {
		edges = append(edges, scenicarea.EdgeAccounts)
	}
	if m.pois != nil {
		edges = append(edges, scenicarea.EdgePois)
	}
	if m.profit_receivers != nil {
		edges = append(edges, scenicarea.EdgeProfitReceivers)
	}
	if m.pay_tx_bills != nil {
		edges = append(edges, scenicarea.EdgePayTxBills)
	}
	if m.car_billing_strategies != nil {
		edges = append(edges, scenicarea.EdgeCarBillingStrategies)
	}
	if m._map != nil {
		edges = append(edges, scenicarea.EdgeMap)
	}
	if m.map_versions != nil {
		edges = append(edges, scenicarea.EdgeMapVersions)
	}
	if m.users != nil {
		edges = append(edges, scenicarea.EdgeUsers)
	}
	if m.orders != nil {
		edges = append(edges, scenicarea.EdgeOrders)
	}
	if m.car_operate_logs != nil {
		edges = append(edges, scenicarea.EdgeCarOperateLogs)
	}
	if m.stats_hourly_car != nil {
		edges = append(edges, scenicarea.EdgeStatsHourlyCar)
	}
	if m.config_files != nil {
		edges = append(edges, scenicarea.EdgeConfigFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScenicAreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scenicarea.EdgeCars:
		ids := make([]ent.Value, 0, len(m.cars))
		for id := range m.cars {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgePois:
		ids := make([]ent.Value, 0, len(m.pois))
		for id := range m.pois {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeProfitReceivers:
		ids := make([]ent.Value, 0, len(m.profit_receivers))
		for id := range m.profit_receivers {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgePayTxBills:
		ids := make([]ent.Value, 0, len(m.pay_tx_bills))
		for id := range m.pay_tx_bills {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeCarBillingStrategies:
		ids := make([]ent.Value, 0, len(m.car_billing_strategies))
		for id := range m.car_billing_strategies {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeMap:
		if id := m._map; id != nil {
			return []ent.Value{*id}
		}
	case scenicarea.EdgeMapVersions:
		ids := make([]ent.Value, 0, len(m.map_versions))
		for id := range m.map_versions {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeCarOperateLogs:
		ids := make([]ent.Value, 0, len(m.car_operate_logs))
		for id := range m.car_operate_logs {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeStatsHourlyCar:
		ids := make([]ent.Value, 0, len(m.stats_hourly_car))
		for id := range m.stats_hourly_car {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.config_files))
		for id := range m.config_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScenicAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedcars != nil {
		edges = append(edges, scenicarea.EdgeCars)
	}
	if m.removedaccounts != nil {
		edges = append(edges, scenicarea.EdgeAccounts)
	}
	if m.removedpois != nil {
		edges = append(edges, scenicarea.EdgePois)
	}
	if m.removedprofit_receivers != nil {
		edges = append(edges, scenicarea.EdgeProfitReceivers)
	}
	if m.removedpay_tx_bills != nil {
		edges = append(edges, scenicarea.EdgePayTxBills)
	}
	if m.removedcar_billing_strategies != nil {
		edges = append(edges, scenicarea.EdgeCarBillingStrategies)
	}
	if m.removedmap_versions != nil {
		edges = append(edges, scenicarea.EdgeMapVersions)
	}
	if m.removedusers != nil {
		edges = append(edges, scenicarea.EdgeUsers)
	}
	if m.removedorders != nil {
		edges = append(edges, scenicarea.EdgeOrders)
	}
	if m.removedcar_operate_logs != nil {
		edges = append(edges, scenicarea.EdgeCarOperateLogs)
	}
	if m.removedstats_hourly_car != nil {
		edges = append(edges, scenicarea.EdgeStatsHourlyCar)
	}
	if m.removedconfig_files != nil {
		edges = append(edges, scenicarea.EdgeConfigFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScenicAreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scenicarea.EdgeCars:
		ids := make([]ent.Value, 0, len(m.removedcars))
		for id := range m.removedcars {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgePois:
		ids := make([]ent.Value, 0, len(m.removedpois))
		for id := range m.removedpois {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeProfitReceivers:
		ids := make([]ent.Value, 0, len(m.removedprofit_receivers))
		for id := range m.removedprofit_receivers {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgePayTxBills:
		ids := make([]ent.Value, 0, len(m.removedpay_tx_bills))
		for id := range m.removedpay_tx_bills {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeCarBillingStrategies:
		ids := make([]ent.Value, 0, len(m.removedcar_billing_strategies))
		for id := range m.removedcar_billing_strategies {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeMapVersions:
		ids := make([]ent.Value, 0, len(m.removedmap_versions))
		for id := range m.removedmap_versions {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeCarOperateLogs:
		ids := make([]ent.Value, 0, len(m.removedcar_operate_logs))
		for id := range m.removedcar_operate_logs {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeStatsHourlyCar:
		ids := make([]ent.Value, 0, len(m.removedstats_hourly_car))
		for id := range m.removedstats_hourly_car {
			ids = append(ids, id)
		}
		return ids
	case scenicarea.EdgeConfigFiles:
		ids := make([]ent.Value, 0, len(m.removedconfig_files))
		for id := range m.removedconfig_files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScenicAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedcars {
		edges = append(edges, scenicarea.EdgeCars)
	}
	if m.clearedaccounts {
		edges = append(edges, scenicarea.EdgeAccounts)
	}
	if m.clearedpois {
		edges = append(edges, scenicarea.EdgePois)
	}
	if m.clearedprofit_receivers {
		edges = append(edges, scenicarea.EdgeProfitReceivers)
	}
	if m.clearedpay_tx_bills {
		edges = append(edges, scenicarea.EdgePayTxBills)
	}
	if m.clearedcar_billing_strategies {
		edges = append(edges, scenicarea.EdgeCarBillingStrategies)
	}
	if m.cleared_map {
		edges = append(edges, scenicarea.EdgeMap)
	}
	if m.clearedmap_versions {
		edges = append(edges, scenicarea.EdgeMapVersions)
	}
	if m.clearedusers {
		edges = append(edges, scenicarea.EdgeUsers)
	}
	if m.clearedorders {
		edges = append(edges, scenicarea.EdgeOrders)
	}
	if m.clearedcar_operate_logs {
		edges = append(edges, scenicarea.EdgeCarOperateLogs)
	}
	if m.clearedstats_hourly_car {
		edges = append(edges, scenicarea.EdgeStatsHourlyCar)
	}
	if m.clearedconfig_files {
		edges = append(edges, scenicarea.EdgeConfigFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScenicAreaMutation) EdgeCleared(name string) bool {
	switch name {
	case scenicarea.EdgeCars:
		return m.clearedcars
	case scenicarea.EdgeAccounts:
		return m.clearedaccounts
	case scenicarea.EdgePois:
		return m.clearedpois
	case scenicarea.EdgeProfitReceivers:
		return m.clearedprofit_receivers
	case scenicarea.EdgePayTxBills:
		return m.clearedpay_tx_bills
	case scenicarea.EdgeCarBillingStrategies:
		return m.clearedcar_billing_strategies
	case scenicarea.EdgeMap:
		return m.cleared_map
	case scenicarea.EdgeMapVersions:
		return m.clearedmap_versions
	case scenicarea.EdgeUsers:
		return m.clearedusers
	case scenicarea.EdgeOrders:
		return m.clearedorders
	case scenicarea.EdgeCarOperateLogs:
		return m.clearedcar_operate_logs
	case scenicarea.EdgeStatsHourlyCar:
		return m.clearedstats_hourly_car
	case scenicarea.EdgeConfigFiles:
		return m.clearedconfig_files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScenicAreaMutation) ClearEdge(name string) error {
	switch name {
	case scenicarea.EdgeMap:
		m.ClearMap()
		return nil
	}
	return fmt.Errorf("unknown ScenicArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScenicAreaMutation) ResetEdge(name string) error {
	switch name {
	case scenicarea.EdgeCars:
		m.ResetCars()
		return nil
	case scenicarea.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case scenicarea.EdgePois:
		m.ResetPois()
		return nil
	case scenicarea.EdgeProfitReceivers:
		m.ResetProfitReceivers()
		return nil
	case scenicarea.EdgePayTxBills:
		m.ResetPayTxBills()
		return nil
	case scenicarea.EdgeCarBillingStrategies:
		m.ResetCarBillingStrategies()
		return nil
	case scenicarea.EdgeMap:
		m.ResetMap()
		return nil
	case scenicarea.EdgeMapVersions:
		m.ResetMapVersions()
		return nil
	case scenicarea.EdgeUsers:
		m.ResetUsers()
		return nil
	case scenicarea.EdgeOrders:
		m.ResetOrders()
		return nil
	case scenicarea.EdgeCarOperateLogs:
		m.ResetCarOperateLogs()
		return nil
	case scenicarea.EdgeStatsHourlyCar:
		m.ResetStatsHourlyCar()
		return nil
	case scenicarea.EdgeConfigFiles:
		m.ResetConfigFiles()
		return nil
	}
	return fmt.Errorf("unknown ScenicArea edge %s", name)
}

// ScenicAreaExtendYokeeMutation represents an operation that mutates the ScenicAreaExtendYokee nodes in the graph.
type ScenicAreaExtendYokeeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	scenic_area_id      *int
	addscenic_area_id   *int
	yokee_app_id        *string
	yokee_app_key       *string
	yokee_org_id        *int
	addyokee_org_id     *int
	yokee_org_name      *string
	yokee_station_id    *int
	addyokee_station_id *int
	yokee_station_name  *string
	create_time         *time.Time
	update_time         *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ScenicAreaExtendYokee, error)
	predicates          []predicate.ScenicAreaExtendYokee
}

var _ ent.Mutation = (*ScenicAreaExtendYokeeMutation)(nil)

// scenicareaextendyokeeOption allows management of the mutation configuration using functional options.
type scenicareaextendyokeeOption func(*ScenicAreaExtendYokeeMutation)

// newScenicAreaExtendYokeeMutation creates new mutation for the ScenicAreaExtendYokee entity.
func newScenicAreaExtendYokeeMutation(c config, op Op, opts ...scenicareaextendyokeeOption) *ScenicAreaExtendYokeeMutation {
	m := &ScenicAreaExtendYokeeMutation{
		config:        c,
		op:            op,
		typ:           TypeScenicAreaExtendYokee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScenicAreaExtendYokeeID sets the ID field of the mutation.
func withScenicAreaExtendYokeeID(id int) scenicareaextendyokeeOption {
	return func(m *ScenicAreaExtendYokeeMutation) {
		var (
			err   error
			once  sync.Once
			value *ScenicAreaExtendYokee
		)
		m.oldValue = func(ctx context.Context) (*ScenicAreaExtendYokee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScenicAreaExtendYokee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScenicAreaExtendYokee sets the old ScenicAreaExtendYokee of the mutation.
func withScenicAreaExtendYokee(node *ScenicAreaExtendYokee) scenicareaextendyokeeOption {
	return func(m *ScenicAreaExtendYokeeMutation) {
		m.oldValue = func(context.Context) (*ScenicAreaExtendYokee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScenicAreaExtendYokeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScenicAreaExtendYokeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScenicAreaExtendYokee entities.
func (m *ScenicAreaExtendYokeeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScenicAreaExtendYokeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScenicAreaExtendYokeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScenicAreaExtendYokee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *ScenicAreaExtendYokeeMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *ScenicAreaExtendYokeeMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *ScenicAreaExtendYokeeMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetYokeeAppID sets the "yokee_app_id" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeAppID(s string) {
	m.yokee_app_id = &s
}

// YokeeAppID returns the value of the "yokee_app_id" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeAppID() (r string, exists bool) {
	v := m.yokee_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeAppID returns the old "yokee_app_id" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeAppID: %w", err)
	}
	return oldValue.YokeeAppID, nil
}

// ResetYokeeAppID resets all changes to the "yokee_app_id" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeAppID() {
	m.yokee_app_id = nil
}

// SetYokeeAppKey sets the "yokee_app_key" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeAppKey(s string) {
	m.yokee_app_key = &s
}

// YokeeAppKey returns the value of the "yokee_app_key" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeAppKey() (r string, exists bool) {
	v := m.yokee_app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeAppKey returns the old "yokee_app_key" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeAppKey: %w", err)
	}
	return oldValue.YokeeAppKey, nil
}

// ResetYokeeAppKey resets all changes to the "yokee_app_key" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeAppKey() {
	m.yokee_app_key = nil
}

// SetYokeeOrgID sets the "yokee_org_id" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeOrgID(i int) {
	m.yokee_org_id = &i
	m.addyokee_org_id = nil
}

// YokeeOrgID returns the value of the "yokee_org_id" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeOrgID() (r int, exists bool) {
	v := m.yokee_org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeOrgID returns the old "yokee_org_id" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeOrgID: %w", err)
	}
	return oldValue.YokeeOrgID, nil
}

// AddYokeeOrgID adds i to the "yokee_org_id" field.
func (m *ScenicAreaExtendYokeeMutation) AddYokeeOrgID(i int) {
	if m.addyokee_org_id != nil {
		*m.addyokee_org_id += i
	} else {
		m.addyokee_org_id = &i
	}
}

// AddedYokeeOrgID returns the value that was added to the "yokee_org_id" field in this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedYokeeOrgID() (r int, exists bool) {
	v := m.addyokee_org_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeOrgID resets all changes to the "yokee_org_id" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeOrgID() {
	m.yokee_org_id = nil
	m.addyokee_org_id = nil
}

// SetYokeeOrgName sets the "yokee_org_name" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeOrgName(s string) {
	m.yokee_org_name = &s
}

// YokeeOrgName returns the value of the "yokee_org_name" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeOrgName() (r string, exists bool) {
	v := m.yokee_org_name
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeOrgName returns the old "yokee_org_name" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeOrgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeOrgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeOrgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeOrgName: %w", err)
	}
	return oldValue.YokeeOrgName, nil
}

// ResetYokeeOrgName resets all changes to the "yokee_org_name" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeOrgName() {
	m.yokee_org_name = nil
}

// SetYokeeStationID sets the "yokee_station_id" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeStationID(i int) {
	m.yokee_station_id = &i
	m.addyokee_station_id = nil
}

// YokeeStationID returns the value of the "yokee_station_id" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeStationID() (r int, exists bool) {
	v := m.yokee_station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStationID returns the old "yokee_station_id" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeStationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStationID: %w", err)
	}
	return oldValue.YokeeStationID, nil
}

// AddYokeeStationID adds i to the "yokee_station_id" field.
func (m *ScenicAreaExtendYokeeMutation) AddYokeeStationID(i int) {
	if m.addyokee_station_id != nil {
		*m.addyokee_station_id += i
	} else {
		m.addyokee_station_id = &i
	}
}

// AddedYokeeStationID returns the value that was added to the "yokee_station_id" field in this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedYokeeStationID() (r int, exists bool) {
	v := m.addyokee_station_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetYokeeStationID resets all changes to the "yokee_station_id" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeStationID() {
	m.yokee_station_id = nil
	m.addyokee_station_id = nil
}

// SetYokeeStationName sets the "yokee_station_name" field.
func (m *ScenicAreaExtendYokeeMutation) SetYokeeStationName(s string) {
	m.yokee_station_name = &s
}

// YokeeStationName returns the value of the "yokee_station_name" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) YokeeStationName() (r string, exists bool) {
	v := m.yokee_station_name
	if v == nil {
		return
	}
	return *v, true
}

// OldYokeeStationName returns the old "yokee_station_name" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldYokeeStationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYokeeStationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYokeeStationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYokeeStationName: %w", err)
	}
	return oldValue.YokeeStationName, nil
}

// ResetYokeeStationName resets all changes to the "yokee_station_name" field.
func (m *ScenicAreaExtendYokeeMutation) ResetYokeeStationName() {
	m.yokee_station_name = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ScenicAreaExtendYokeeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScenicAreaExtendYokeeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScenicAreaExtendYokeeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScenicAreaExtendYokeeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScenicAreaExtendYokee entity.
// If the ScenicAreaExtendYokee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaExtendYokeeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScenicAreaExtendYokeeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the ScenicAreaExtendYokeeMutation builder.
func (m *ScenicAreaExtendYokeeMutation) Where(ps ...predicate.ScenicAreaExtendYokee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScenicAreaExtendYokeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScenicAreaExtendYokeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScenicAreaExtendYokee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScenicAreaExtendYokeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScenicAreaExtendYokeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScenicAreaExtendYokee).
func (m *ScenicAreaExtendYokeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScenicAreaExtendYokeeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.scenic_area_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldScenicAreaID)
	}
	if m.yokee_app_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeAppID)
	}
	if m.yokee_app_key != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeAppKey)
	}
	if m.yokee_org_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeOrgID)
	}
	if m.yokee_org_name != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeOrgName)
	}
	if m.yokee_station_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeStationID)
	}
	if m.yokee_station_name != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeStationName)
	}
	if m.create_time != nil {
		fields = append(fields, scenicareaextendyokee.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scenicareaextendyokee.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScenicAreaExtendYokeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		return m.ScenicAreaID()
	case scenicareaextendyokee.FieldYokeeAppID:
		return m.YokeeAppID()
	case scenicareaextendyokee.FieldYokeeAppKey:
		return m.YokeeAppKey()
	case scenicareaextendyokee.FieldYokeeOrgID:
		return m.YokeeOrgID()
	case scenicareaextendyokee.FieldYokeeOrgName:
		return m.YokeeOrgName()
	case scenicareaextendyokee.FieldYokeeStationID:
		return m.YokeeStationID()
	case scenicareaextendyokee.FieldYokeeStationName:
		return m.YokeeStationName()
	case scenicareaextendyokee.FieldCreateTime:
		return m.CreateTime()
	case scenicareaextendyokee.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScenicAreaExtendYokeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case scenicareaextendyokee.FieldYokeeAppID:
		return m.OldYokeeAppID(ctx)
	case scenicareaextendyokee.FieldYokeeAppKey:
		return m.OldYokeeAppKey(ctx)
	case scenicareaextendyokee.FieldYokeeOrgID:
		return m.OldYokeeOrgID(ctx)
	case scenicareaextendyokee.FieldYokeeOrgName:
		return m.OldYokeeOrgName(ctx)
	case scenicareaextendyokee.FieldYokeeStationID:
		return m.OldYokeeStationID(ctx)
	case scenicareaextendyokee.FieldYokeeStationName:
		return m.OldYokeeStationName(ctx)
	case scenicareaextendyokee.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scenicareaextendyokee.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScenicAreaExtendYokee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaExtendYokeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeAppID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeAppKey(v)
		return nil
	case scenicareaextendyokee.FieldYokeeOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeOrgID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeOrgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeOrgName(v)
		return nil
	case scenicareaextendyokee.FieldYokeeStationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStationID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeStationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYokeeStationName(v)
		return nil
	case scenicareaextendyokee.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scenicareaextendyokee.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaExtendYokee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldScenicAreaID)
	}
	if m.addyokee_org_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeOrgID)
	}
	if m.addyokee_station_id != nil {
		fields = append(fields, scenicareaextendyokee.FieldYokeeStationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScenicAreaExtendYokeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case scenicareaextendyokee.FieldYokeeOrgID:
		return m.AddedYokeeOrgID()
	case scenicareaextendyokee.FieldYokeeStationID:
		return m.AddedYokeeStationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaExtendYokeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeOrgID(v)
		return nil
	case scenicareaextendyokee.FieldYokeeStationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYokeeStationID(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaExtendYokee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScenicAreaExtendYokeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScenicAreaExtendYokeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScenicAreaExtendYokeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScenicAreaExtendYokee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScenicAreaExtendYokeeMutation) ResetField(name string) error {
	switch name {
	case scenicareaextendyokee.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case scenicareaextendyokee.FieldYokeeAppID:
		m.ResetYokeeAppID()
		return nil
	case scenicareaextendyokee.FieldYokeeAppKey:
		m.ResetYokeeAppKey()
		return nil
	case scenicareaextendyokee.FieldYokeeOrgID:
		m.ResetYokeeOrgID()
		return nil
	case scenicareaextendyokee.FieldYokeeOrgName:
		m.ResetYokeeOrgName()
		return nil
	case scenicareaextendyokee.FieldYokeeStationID:
		m.ResetYokeeStationID()
		return nil
	case scenicareaextendyokee.FieldYokeeStationName:
		m.ResetYokeeStationName()
		return nil
	case scenicareaextendyokee.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scenicareaextendyokee.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaExtendYokee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScenicAreaExtendYokeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScenicAreaExtendYokeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScenicAreaExtendYokeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScenicAreaExtendYokeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScenicAreaExtendYokeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScenicAreaExtendYokeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScenicAreaExtendYokee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScenicAreaExtendYokeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScenicAreaExtendYokee edge %s", name)
}

// ScenicAreaMapMutation represents an operation that mutates the ScenicAreaMap nodes in the graph.
type ScenicAreaMapMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	name                          *string
	base_map_file_id              *int
	addbase_map_file_id           *int
	routing_map_file_id           *int
	addrouting_map_file_id        *int
	sim_map_file_id               *int
	addsim_map_file_id            *int
	fence_map_file_id             *int
	addfence_map_file_id          *int
	carui_map_file_id             *int
	addcarui_map_file_id          *int
	carui_ne_coord                *string
	carui_sw_coord                *string
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*ScenicAreaMap, error)
	predicates                    []predicate.ScenicAreaMap
}

var _ ent.Mutation = (*ScenicAreaMapMutation)(nil)

// scenicareamapOption allows management of the mutation configuration using functional options.
type scenicareamapOption func(*ScenicAreaMapMutation)

// newScenicAreaMapMutation creates new mutation for the ScenicAreaMap entity.
func newScenicAreaMapMutation(c config, op Op, opts ...scenicareamapOption) *ScenicAreaMapMutation {
	m := &ScenicAreaMapMutation{
		config:        c,
		op:            op,
		typ:           TypeScenicAreaMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScenicAreaMapID sets the ID field of the mutation.
func withScenicAreaMapID(id int) scenicareamapOption {
	return func(m *ScenicAreaMapMutation) {
		var (
			err   error
			once  sync.Once
			value *ScenicAreaMap
		)
		m.oldValue = func(ctx context.Context) (*ScenicAreaMap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScenicAreaMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScenicAreaMap sets the old ScenicAreaMap of the mutation.
func withScenicAreaMap(node *ScenicAreaMap) scenicareamapOption {
	return func(m *ScenicAreaMapMutation) {
		m.oldValue = func(context.Context) (*ScenicAreaMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScenicAreaMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScenicAreaMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScenicAreaMap entities.
func (m *ScenicAreaMapMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScenicAreaMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScenicAreaMapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScenicAreaMap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *ScenicAreaMapMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *ScenicAreaMapMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *ScenicAreaMapMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetName sets the "name" field.
func (m *ScenicAreaMapMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScenicAreaMapMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScenicAreaMapMutation) ResetName() {
	m.name = nil
}

// SetBaseMapFileID sets the "base_map_file_id" field.
func (m *ScenicAreaMapMutation) SetBaseMapFileID(i int) {
	m.base_map_file_id = &i
	m.addbase_map_file_id = nil
}

// BaseMapFileID returns the value of the "base_map_file_id" field in the mutation.
func (m *ScenicAreaMapMutation) BaseMapFileID() (r int, exists bool) {
	v := m.base_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseMapFileID returns the old "base_map_file_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldBaseMapFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseMapFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseMapFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseMapFileID: %w", err)
	}
	return oldValue.BaseMapFileID, nil
}

// AddBaseMapFileID adds i to the "base_map_file_id" field.
func (m *ScenicAreaMapMutation) AddBaseMapFileID(i int) {
	if m.addbase_map_file_id != nil {
		*m.addbase_map_file_id += i
	} else {
		m.addbase_map_file_id = &i
	}
}

// AddedBaseMapFileID returns the value that was added to the "base_map_file_id" field in this mutation.
func (m *ScenicAreaMapMutation) AddedBaseMapFileID() (r int, exists bool) {
	v := m.addbase_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseMapFileID resets all changes to the "base_map_file_id" field.
func (m *ScenicAreaMapMutation) ResetBaseMapFileID() {
	m.base_map_file_id = nil
	m.addbase_map_file_id = nil
}

// SetRoutingMapFileID sets the "routing_map_file_id" field.
func (m *ScenicAreaMapMutation) SetRoutingMapFileID(i int) {
	m.routing_map_file_id = &i
	m.addrouting_map_file_id = nil
}

// RoutingMapFileID returns the value of the "routing_map_file_id" field in the mutation.
func (m *ScenicAreaMapMutation) RoutingMapFileID() (r int, exists bool) {
	v := m.routing_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingMapFileID returns the old "routing_map_file_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldRoutingMapFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingMapFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingMapFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingMapFileID: %w", err)
	}
	return oldValue.RoutingMapFileID, nil
}

// AddRoutingMapFileID adds i to the "routing_map_file_id" field.
func (m *ScenicAreaMapMutation) AddRoutingMapFileID(i int) {
	if m.addrouting_map_file_id != nil {
		*m.addrouting_map_file_id += i
	} else {
		m.addrouting_map_file_id = &i
	}
}

// AddedRoutingMapFileID returns the value that was added to the "routing_map_file_id" field in this mutation.
func (m *ScenicAreaMapMutation) AddedRoutingMapFileID() (r int, exists bool) {
	v := m.addrouting_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoutingMapFileID resets all changes to the "routing_map_file_id" field.
func (m *ScenicAreaMapMutation) ResetRoutingMapFileID() {
	m.routing_map_file_id = nil
	m.addrouting_map_file_id = nil
}

// SetSimMapFileID sets the "sim_map_file_id" field.
func (m *ScenicAreaMapMutation) SetSimMapFileID(i int) {
	m.sim_map_file_id = &i
	m.addsim_map_file_id = nil
}

// SimMapFileID returns the value of the "sim_map_file_id" field in the mutation.
func (m *ScenicAreaMapMutation) SimMapFileID() (r int, exists bool) {
	v := m.sim_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSimMapFileID returns the old "sim_map_file_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldSimMapFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimMapFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimMapFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimMapFileID: %w", err)
	}
	return oldValue.SimMapFileID, nil
}

// AddSimMapFileID adds i to the "sim_map_file_id" field.
func (m *ScenicAreaMapMutation) AddSimMapFileID(i int) {
	if m.addsim_map_file_id != nil {
		*m.addsim_map_file_id += i
	} else {
		m.addsim_map_file_id = &i
	}
}

// AddedSimMapFileID returns the value that was added to the "sim_map_file_id" field in this mutation.
func (m *ScenicAreaMapMutation) AddedSimMapFileID() (r int, exists bool) {
	v := m.addsim_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSimMapFileID resets all changes to the "sim_map_file_id" field.
func (m *ScenicAreaMapMutation) ResetSimMapFileID() {
	m.sim_map_file_id = nil
	m.addsim_map_file_id = nil
}

// SetFenceMapFileID sets the "fence_map_file_id" field.
func (m *ScenicAreaMapMutation) SetFenceMapFileID(i int) {
	m.fence_map_file_id = &i
	m.addfence_map_file_id = nil
}

// FenceMapFileID returns the value of the "fence_map_file_id" field in the mutation.
func (m *ScenicAreaMapMutation) FenceMapFileID() (r int, exists bool) {
	v := m.fence_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFenceMapFileID returns the old "fence_map_file_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldFenceMapFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFenceMapFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFenceMapFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFenceMapFileID: %w", err)
	}
	return oldValue.FenceMapFileID, nil
}

// AddFenceMapFileID adds i to the "fence_map_file_id" field.
func (m *ScenicAreaMapMutation) AddFenceMapFileID(i int) {
	if m.addfence_map_file_id != nil {
		*m.addfence_map_file_id += i
	} else {
		m.addfence_map_file_id = &i
	}
}

// AddedFenceMapFileID returns the value that was added to the "fence_map_file_id" field in this mutation.
func (m *ScenicAreaMapMutation) AddedFenceMapFileID() (r int, exists bool) {
	v := m.addfence_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFenceMapFileID resets all changes to the "fence_map_file_id" field.
func (m *ScenicAreaMapMutation) ResetFenceMapFileID() {
	m.fence_map_file_id = nil
	m.addfence_map_file_id = nil
}

// SetCaruiMapFileID sets the "carui_map_file_id" field.
func (m *ScenicAreaMapMutation) SetCaruiMapFileID(i int) {
	m.carui_map_file_id = &i
	m.addcarui_map_file_id = nil
}

// CaruiMapFileID returns the value of the "carui_map_file_id" field in the mutation.
func (m *ScenicAreaMapMutation) CaruiMapFileID() (r int, exists bool) {
	v := m.carui_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCaruiMapFileID returns the old "carui_map_file_id" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldCaruiMapFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaruiMapFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaruiMapFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaruiMapFileID: %w", err)
	}
	return oldValue.CaruiMapFileID, nil
}

// AddCaruiMapFileID adds i to the "carui_map_file_id" field.
func (m *ScenicAreaMapMutation) AddCaruiMapFileID(i int) {
	if m.addcarui_map_file_id != nil {
		*m.addcarui_map_file_id += i
	} else {
		m.addcarui_map_file_id = &i
	}
}

// AddedCaruiMapFileID returns the value that was added to the "carui_map_file_id" field in this mutation.
func (m *ScenicAreaMapMutation) AddedCaruiMapFileID() (r int, exists bool) {
	v := m.addcarui_map_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCaruiMapFileID resets all changes to the "carui_map_file_id" field.
func (m *ScenicAreaMapMutation) ResetCaruiMapFileID() {
	m.carui_map_file_id = nil
	m.addcarui_map_file_id = nil
}

// SetCaruiNeCoord sets the "carui_ne_coord" field.
func (m *ScenicAreaMapMutation) SetCaruiNeCoord(s string) {
	m.carui_ne_coord = &s
}

// CaruiNeCoord returns the value of the "carui_ne_coord" field in the mutation.
func (m *ScenicAreaMapMutation) CaruiNeCoord() (r string, exists bool) {
	v := m.carui_ne_coord
	if v == nil {
		return
	}
	return *v, true
}

// OldCaruiNeCoord returns the old "carui_ne_coord" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldCaruiNeCoord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaruiNeCoord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaruiNeCoord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaruiNeCoord: %w", err)
	}
	return oldValue.CaruiNeCoord, nil
}

// ResetCaruiNeCoord resets all changes to the "carui_ne_coord" field.
func (m *ScenicAreaMapMutation) ResetCaruiNeCoord() {
	m.carui_ne_coord = nil
}

// SetCaruiSwCoord sets the "carui_sw_coord" field.
func (m *ScenicAreaMapMutation) SetCaruiSwCoord(s string) {
	m.carui_sw_coord = &s
}

// CaruiSwCoord returns the value of the "carui_sw_coord" field in the mutation.
func (m *ScenicAreaMapMutation) CaruiSwCoord() (r string, exists bool) {
	v := m.carui_sw_coord
	if v == nil {
		return
	}
	return *v, true
}

// OldCaruiSwCoord returns the old "carui_sw_coord" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldCaruiSwCoord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaruiSwCoord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaruiSwCoord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaruiSwCoord: %w", err)
	}
	return oldValue.CaruiSwCoord, nil
}

// ResetCaruiSwCoord resets all changes to the "carui_sw_coord" field.
func (m *ScenicAreaMapMutation) ResetCaruiSwCoord() {
	m.carui_sw_coord = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ScenicAreaMapMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScenicAreaMapMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScenicAreaMapMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScenicAreaMapMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScenicAreaMapMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScenicAreaMap entity.
// If the ScenicAreaMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScenicAreaMapMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScenicAreaMapMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *ScenicAreaMapMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *ScenicAreaMapMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[scenicareamap.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *ScenicAreaMapMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *ScenicAreaMapMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *ScenicAreaMapMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *ScenicAreaMapMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the ScenicAreaMapMutation builder.
func (m *ScenicAreaMapMutation) Where(ps ...predicate.ScenicAreaMap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScenicAreaMapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScenicAreaMapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScenicAreaMap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScenicAreaMapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScenicAreaMapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScenicAreaMap).
func (m *ScenicAreaMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScenicAreaMapMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.background_scenic_area != nil {
		fields = append(fields, scenicareamap.FieldScenicAreaID)
	}
	if m.name != nil {
		fields = append(fields, scenicareamap.FieldName)
	}
	if m.base_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldBaseMapFileID)
	}
	if m.routing_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldRoutingMapFileID)
	}
	if m.sim_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldSimMapFileID)
	}
	if m.fence_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldFenceMapFileID)
	}
	if m.carui_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldCaruiMapFileID)
	}
	if m.carui_ne_coord != nil {
		fields = append(fields, scenicareamap.FieldCaruiNeCoord)
	}
	if m.carui_sw_coord != nil {
		fields = append(fields, scenicareamap.FieldCaruiSwCoord)
	}
	if m.create_time != nil {
		fields = append(fields, scenicareamap.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scenicareamap.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScenicAreaMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scenicareamap.FieldScenicAreaID:
		return m.ScenicAreaID()
	case scenicareamap.FieldName:
		return m.Name()
	case scenicareamap.FieldBaseMapFileID:
		return m.BaseMapFileID()
	case scenicareamap.FieldRoutingMapFileID:
		return m.RoutingMapFileID()
	case scenicareamap.FieldSimMapFileID:
		return m.SimMapFileID()
	case scenicareamap.FieldFenceMapFileID:
		return m.FenceMapFileID()
	case scenicareamap.FieldCaruiMapFileID:
		return m.CaruiMapFileID()
	case scenicareamap.FieldCaruiNeCoord:
		return m.CaruiNeCoord()
	case scenicareamap.FieldCaruiSwCoord:
		return m.CaruiSwCoord()
	case scenicareamap.FieldCreateTime:
		return m.CreateTime()
	case scenicareamap.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScenicAreaMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scenicareamap.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case scenicareamap.FieldName:
		return m.OldName(ctx)
	case scenicareamap.FieldBaseMapFileID:
		return m.OldBaseMapFileID(ctx)
	case scenicareamap.FieldRoutingMapFileID:
		return m.OldRoutingMapFileID(ctx)
	case scenicareamap.FieldSimMapFileID:
		return m.OldSimMapFileID(ctx)
	case scenicareamap.FieldFenceMapFileID:
		return m.OldFenceMapFileID(ctx)
	case scenicareamap.FieldCaruiMapFileID:
		return m.OldCaruiMapFileID(ctx)
	case scenicareamap.FieldCaruiNeCoord:
		return m.OldCaruiNeCoord(ctx)
	case scenicareamap.FieldCaruiSwCoord:
		return m.OldCaruiSwCoord(ctx)
	case scenicareamap.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scenicareamap.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScenicAreaMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scenicareamap.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case scenicareamap.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scenicareamap.FieldBaseMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseMapFileID(v)
		return nil
	case scenicareamap.FieldRoutingMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingMapFileID(v)
		return nil
	case scenicareamap.FieldSimMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimMapFileID(v)
		return nil
	case scenicareamap.FieldFenceMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFenceMapFileID(v)
		return nil
	case scenicareamap.FieldCaruiMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaruiMapFileID(v)
		return nil
	case scenicareamap.FieldCaruiNeCoord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaruiNeCoord(v)
		return nil
	case scenicareamap.FieldCaruiSwCoord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaruiSwCoord(v)
		return nil
	case scenicareamap.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scenicareamap.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScenicAreaMapMutation) AddedFields() []string {
	var fields []string
	if m.addbase_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldBaseMapFileID)
	}
	if m.addrouting_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldRoutingMapFileID)
	}
	if m.addsim_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldSimMapFileID)
	}
	if m.addfence_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldFenceMapFileID)
	}
	if m.addcarui_map_file_id != nil {
		fields = append(fields, scenicareamap.FieldCaruiMapFileID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScenicAreaMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scenicareamap.FieldBaseMapFileID:
		return m.AddedBaseMapFileID()
	case scenicareamap.FieldRoutingMapFileID:
		return m.AddedRoutingMapFileID()
	case scenicareamap.FieldSimMapFileID:
		return m.AddedSimMapFileID()
	case scenicareamap.FieldFenceMapFileID:
		return m.AddedFenceMapFileID()
	case scenicareamap.FieldCaruiMapFileID:
		return m.AddedCaruiMapFileID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScenicAreaMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scenicareamap.FieldBaseMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseMapFileID(v)
		return nil
	case scenicareamap.FieldRoutingMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoutingMapFileID(v)
		return nil
	case scenicareamap.FieldSimMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSimMapFileID(v)
		return nil
	case scenicareamap.FieldFenceMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFenceMapFileID(v)
		return nil
	case scenicareamap.FieldCaruiMapFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCaruiMapFileID(v)
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScenicAreaMapMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScenicAreaMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScenicAreaMapMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScenicAreaMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScenicAreaMapMutation) ResetField(name string) error {
	switch name {
	case scenicareamap.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case scenicareamap.FieldName:
		m.ResetName()
		return nil
	case scenicareamap.FieldBaseMapFileID:
		m.ResetBaseMapFileID()
		return nil
	case scenicareamap.FieldRoutingMapFileID:
		m.ResetRoutingMapFileID()
		return nil
	case scenicareamap.FieldSimMapFileID:
		m.ResetSimMapFileID()
		return nil
	case scenicareamap.FieldFenceMapFileID:
		m.ResetFenceMapFileID()
		return nil
	case scenicareamap.FieldCaruiMapFileID:
		m.ResetCaruiMapFileID()
		return nil
	case scenicareamap.FieldCaruiNeCoord:
		m.ResetCaruiNeCoord()
		return nil
	case scenicareamap.FieldCaruiSwCoord:
		m.ResetCaruiSwCoord()
		return nil
	case scenicareamap.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scenicareamap.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScenicAreaMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, scenicareamap.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScenicAreaMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scenicareamap.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScenicAreaMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScenicAreaMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScenicAreaMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, scenicareamap.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScenicAreaMapMutation) EdgeCleared(name string) bool {
	switch name {
	case scenicareamap.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScenicAreaMapMutation) ClearEdge(name string) error {
	switch name {
	case scenicareamap.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScenicAreaMapMutation) ResetEdge(name string) error {
	switch name {
	case scenicareamap.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown ScenicAreaMap edge %s", name)
}

// ScheTaskMutation represents an operation that mutates the ScheTask nodes in the graph.
type ScheTaskMutation struct {
	config
	op                Op
	typ               string
	id                *int
	user_type         *int
	adduser_type      *int
	user_id           *int
	adduser_id        *int
	scenic_area_id    *int
	addscenic_area_id *int
	device_id         *string
	dest_id           *int
	adddest_id        *int
	dest_lon          *float64
	adddest_lon       *float64
	dest_lat          *float64
	adddest_lat       *float64
	_type             *int
	add_type          *int
	load_limit        *int
	addload_limit     *int
	state             *int
	addstate          *int
	abnormal_state    *int
	addabnormal_state *int
	remark            *string
	routing_path      *types.RoutingPath
	end_time          *time.Time
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	car               *int
	clearedcar        bool
	events            map[int]struct{}
	removedevents     map[int]struct{}
	clearedevents     bool
	done              bool
	oldValue          func(context.Context) (*ScheTask, error)
	predicates        []predicate.ScheTask
}

var _ ent.Mutation = (*ScheTaskMutation)(nil)

// schetaskOption allows management of the mutation configuration using functional options.
type schetaskOption func(*ScheTaskMutation)

// newScheTaskMutation creates new mutation for the ScheTask entity.
func newScheTaskMutation(c config, op Op, opts ...schetaskOption) *ScheTaskMutation {
	m := &ScheTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeScheTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheTaskID sets the ID field of the mutation.
func withScheTaskID(id int) schetaskOption {
	return func(m *ScheTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheTask
		)
		m.oldValue = func(ctx context.Context) (*ScheTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheTask sets the old ScheTask of the mutation.
func withScheTask(node *ScheTask) schetaskOption {
	return func(m *ScheTaskMutation) {
		m.oldValue = func(context.Context) (*ScheTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheTask entities.
func (m *ScheTaskMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserType sets the "user_type" field.
func (m *ScheTaskMutation) SetUserType(i int) {
	m.user_type = &i
	m.adduser_type = nil
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *ScheTaskMutation) UserType() (r int, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldUserType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// AddUserType adds i to the "user_type" field.
func (m *ScheTaskMutation) AddUserType(i int) {
	if m.adduser_type != nil {
		*m.adduser_type += i
	} else {
		m.adduser_type = &i
	}
}

// AddedUserType returns the value that was added to the "user_type" field in this mutation.
func (m *ScheTaskMutation) AddedUserType() (r int, exists bool) {
	v := m.adduser_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserType resets all changes to the "user_type" field.
func (m *ScheTaskMutation) ResetUserType() {
	m.user_type = nil
	m.adduser_type = nil
}

// SetUserID sets the "user_id" field.
func (m *ScheTaskMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ScheTaskMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ScheTaskMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ScheTaskMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ScheTaskMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *ScheTaskMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *ScheTaskMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *ScheTaskMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *ScheTaskMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *ScheTaskMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetCarID sets the "car_id" field.
func (m *ScheTaskMutation) SetCarID(i int) {
	m.car = &i
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *ScheTaskMutation) CarID() (r int, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ResetCarID resets all changes to the "car_id" field.
func (m *ScheTaskMutation) ResetCarID() {
	m.car = nil
}

// SetDeviceID sets the "device_id" field.
func (m *ScheTaskMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *ScheTaskMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *ScheTaskMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetDestID sets the "dest_id" field.
func (m *ScheTaskMutation) SetDestID(i int) {
	m.dest_id = &i
	m.adddest_id = nil
}

// DestID returns the value of the "dest_id" field in the mutation.
func (m *ScheTaskMutation) DestID() (r int, exists bool) {
	v := m.dest_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDestID returns the old "dest_id" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldDestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestID: %w", err)
	}
	return oldValue.DestID, nil
}

// AddDestID adds i to the "dest_id" field.
func (m *ScheTaskMutation) AddDestID(i int) {
	if m.adddest_id != nil {
		*m.adddest_id += i
	} else {
		m.adddest_id = &i
	}
}

// AddedDestID returns the value that was added to the "dest_id" field in this mutation.
func (m *ScheTaskMutation) AddedDestID() (r int, exists bool) {
	v := m.adddest_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDestID resets all changes to the "dest_id" field.
func (m *ScheTaskMutation) ResetDestID() {
	m.dest_id = nil
	m.adddest_id = nil
}

// SetDestLon sets the "dest_lon" field.
func (m *ScheTaskMutation) SetDestLon(f float64) {
	m.dest_lon = &f
	m.adddest_lon = nil
}

// DestLon returns the value of the "dest_lon" field in the mutation.
func (m *ScheTaskMutation) DestLon() (r float64, exists bool) {
	v := m.dest_lon
	if v == nil {
		return
	}
	return *v, true
}

// OldDestLon returns the old "dest_lon" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldDestLon(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestLon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestLon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestLon: %w", err)
	}
	return oldValue.DestLon, nil
}

// AddDestLon adds f to the "dest_lon" field.
func (m *ScheTaskMutation) AddDestLon(f float64) {
	if m.adddest_lon != nil {
		*m.adddest_lon += f
	} else {
		m.adddest_lon = &f
	}
}

// AddedDestLon returns the value that was added to the "dest_lon" field in this mutation.
func (m *ScheTaskMutation) AddedDestLon() (r float64, exists bool) {
	v := m.adddest_lon
	if v == nil {
		return
	}
	return *v, true
}

// ResetDestLon resets all changes to the "dest_lon" field.
func (m *ScheTaskMutation) ResetDestLon() {
	m.dest_lon = nil
	m.adddest_lon = nil
}

// SetDestLat sets the "dest_lat" field.
func (m *ScheTaskMutation) SetDestLat(f float64) {
	m.dest_lat = &f
	m.adddest_lat = nil
}

// DestLat returns the value of the "dest_lat" field in the mutation.
func (m *ScheTaskMutation) DestLat() (r float64, exists bool) {
	v := m.dest_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldDestLat returns the old "dest_lat" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldDestLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestLat: %w", err)
	}
	return oldValue.DestLat, nil
}

// AddDestLat adds f to the "dest_lat" field.
func (m *ScheTaskMutation) AddDestLat(f float64) {
	if m.adddest_lat != nil {
		*m.adddest_lat += f
	} else {
		m.adddest_lat = &f
	}
}

// AddedDestLat returns the value that was added to the "dest_lat" field in this mutation.
func (m *ScheTaskMutation) AddedDestLat() (r float64, exists bool) {
	v := m.adddest_lat
	if v == nil {
		return
	}
	return *v, true
}

// ResetDestLat resets all changes to the "dest_lat" field.
func (m *ScheTaskMutation) ResetDestLat() {
	m.dest_lat = nil
	m.adddest_lat = nil
}

// SetType sets the "type" field.
func (m *ScheTaskMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheTaskMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ScheTaskMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ScheTaskMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ScheTaskMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetLoadLimit sets the "load_limit" field.
func (m *ScheTaskMutation) SetLoadLimit(i int) {
	m.load_limit = &i
	m.addload_limit = nil
}

// LoadLimit returns the value of the "load_limit" field in the mutation.
func (m *ScheTaskMutation) LoadLimit() (r int, exists bool) {
	v := m.load_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadLimit returns the old "load_limit" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldLoadLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadLimit: %w", err)
	}
	return oldValue.LoadLimit, nil
}

// AddLoadLimit adds i to the "load_limit" field.
func (m *ScheTaskMutation) AddLoadLimit(i int) {
	if m.addload_limit != nil {
		*m.addload_limit += i
	} else {
		m.addload_limit = &i
	}
}

// AddedLoadLimit returns the value that was added to the "load_limit" field in this mutation.
func (m *ScheTaskMutation) AddedLoadLimit() (r int, exists bool) {
	v := m.addload_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadLimit resets all changes to the "load_limit" field.
func (m *ScheTaskMutation) ResetLoadLimit() {
	m.load_limit = nil
	m.addload_limit = nil
}

// SetState sets the "state" field.
func (m *ScheTaskMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *ScheTaskMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *ScheTaskMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *ScheTaskMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *ScheTaskMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetAbnormalState sets the "abnormal_state" field.
func (m *ScheTaskMutation) SetAbnormalState(i int) {
	m.abnormal_state = &i
	m.addabnormal_state = nil
}

// AbnormalState returns the value of the "abnormal_state" field in the mutation.
func (m *ScheTaskMutation) AbnormalState() (r int, exists bool) {
	v := m.abnormal_state
	if v == nil {
		return
	}
	return *v, true
}

// OldAbnormalState returns the old "abnormal_state" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldAbnormalState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbnormalState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbnormalState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbnormalState: %w", err)
	}
	return oldValue.AbnormalState, nil
}

// AddAbnormalState adds i to the "abnormal_state" field.
func (m *ScheTaskMutation) AddAbnormalState(i int) {
	if m.addabnormal_state != nil {
		*m.addabnormal_state += i
	} else {
		m.addabnormal_state = &i
	}
}

// AddedAbnormalState returns the value that was added to the "abnormal_state" field in this mutation.
func (m *ScheTaskMutation) AddedAbnormalState() (r int, exists bool) {
	v := m.addabnormal_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbnormalState resets all changes to the "abnormal_state" field.
func (m *ScheTaskMutation) ResetAbnormalState() {
	m.abnormal_state = nil
	m.addabnormal_state = nil
}

// SetRemark sets the "remark" field.
func (m *ScheTaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ScheTaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ScheTaskMutation) ResetRemark() {
	m.remark = nil
}

// SetRoutingPath sets the "routing_path" field.
func (m *ScheTaskMutation) SetRoutingPath(tp types.RoutingPath) {
	m.routing_path = &tp
}

// RoutingPath returns the value of the "routing_path" field in the mutation.
func (m *ScheTaskMutation) RoutingPath() (r types.RoutingPath, exists bool) {
	v := m.routing_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingPath returns the old "routing_path" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldRoutingPath(ctx context.Context) (v types.RoutingPath, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoutingPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoutingPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingPath: %w", err)
	}
	return oldValue.RoutingPath, nil
}

// ResetRoutingPath resets all changes to the "routing_path" field.
func (m *ScheTaskMutation) ResetRoutingPath() {
	m.routing_path = nil
}

// SetEndTime sets the "end_time" field.
func (m *ScheTaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ScheTaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ScheTaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[schetask.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ScheTaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[schetask.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ScheTaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, schetask.FieldEndTime)
}

// SetCreateTime sets the "create_time" field.
func (m *ScheTaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScheTaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScheTaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScheTaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScheTaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ScheTask entity.
// If the ScheTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScheTaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ScheTaskMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[schetask.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ScheTaskMutation) CarCleared() bool {
	return m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ScheTaskMutation) CarIDs() (ids []int) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ScheTaskMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddEventIDs adds the "events" edge to the ScheTaskEvent entity by ids.
func (m *ScheTaskMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the ScheTaskEvent entity.
func (m *ScheTaskMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the ScheTaskEvent entity was cleared.
func (m *ScheTaskMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the ScheTaskEvent entity by IDs.
func (m *ScheTaskMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the ScheTaskEvent entity.
func (m *ScheTaskMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ScheTaskMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ScheTaskMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the ScheTaskMutation builder.
func (m *ScheTaskMutation) Where(ps ...predicate.ScheTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheTask).
func (m *ScheTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheTaskMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.user_type != nil {
		fields = append(fields, schetask.FieldUserType)
	}
	if m.user_id != nil {
		fields = append(fields, schetask.FieldUserID)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, schetask.FieldScenicAreaID)
	}
	if m.car != nil {
		fields = append(fields, schetask.FieldCarID)
	}
	if m.device_id != nil {
		fields = append(fields, schetask.FieldDeviceID)
	}
	if m.dest_id != nil {
		fields = append(fields, schetask.FieldDestID)
	}
	if m.dest_lon != nil {
		fields = append(fields, schetask.FieldDestLon)
	}
	if m.dest_lat != nil {
		fields = append(fields, schetask.FieldDestLat)
	}
	if m._type != nil {
		fields = append(fields, schetask.FieldType)
	}
	if m.load_limit != nil {
		fields = append(fields, schetask.FieldLoadLimit)
	}
	if m.state != nil {
		fields = append(fields, schetask.FieldState)
	}
	if m.abnormal_state != nil {
		fields = append(fields, schetask.FieldAbnormalState)
	}
	if m.remark != nil {
		fields = append(fields, schetask.FieldRemark)
	}
	if m.routing_path != nil {
		fields = append(fields, schetask.FieldRoutingPath)
	}
	if m.end_time != nil {
		fields = append(fields, schetask.FieldEndTime)
	}
	if m.create_time != nil {
		fields = append(fields, schetask.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, schetask.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schetask.FieldUserType:
		return m.UserType()
	case schetask.FieldUserID:
		return m.UserID()
	case schetask.FieldScenicAreaID:
		return m.ScenicAreaID()
	case schetask.FieldCarID:
		return m.CarID()
	case schetask.FieldDeviceID:
		return m.DeviceID()
	case schetask.FieldDestID:
		return m.DestID()
	case schetask.FieldDestLon:
		return m.DestLon()
	case schetask.FieldDestLat:
		return m.DestLat()
	case schetask.FieldType:
		return m.GetType()
	case schetask.FieldLoadLimit:
		return m.LoadLimit()
	case schetask.FieldState:
		return m.State()
	case schetask.FieldAbnormalState:
		return m.AbnormalState()
	case schetask.FieldRemark:
		return m.Remark()
	case schetask.FieldRoutingPath:
		return m.RoutingPath()
	case schetask.FieldEndTime:
		return m.EndTime()
	case schetask.FieldCreateTime:
		return m.CreateTime()
	case schetask.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schetask.FieldUserType:
		return m.OldUserType(ctx)
	case schetask.FieldUserID:
		return m.OldUserID(ctx)
	case schetask.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case schetask.FieldCarID:
		return m.OldCarID(ctx)
	case schetask.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case schetask.FieldDestID:
		return m.OldDestID(ctx)
	case schetask.FieldDestLon:
		return m.OldDestLon(ctx)
	case schetask.FieldDestLat:
		return m.OldDestLat(ctx)
	case schetask.FieldType:
		return m.OldType(ctx)
	case schetask.FieldLoadLimit:
		return m.OldLoadLimit(ctx)
	case schetask.FieldState:
		return m.OldState(ctx)
	case schetask.FieldAbnormalState:
		return m.OldAbnormalState(ctx)
	case schetask.FieldRemark:
		return m.OldRemark(ctx)
	case schetask.FieldRoutingPath:
		return m.OldRoutingPath(ctx)
	case schetask.FieldEndTime:
		return m.OldEndTime(ctx)
	case schetask.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case schetask.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScheTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schetask.FieldUserType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case schetask.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case schetask.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case schetask.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case schetask.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case schetask.FieldDestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestID(v)
		return nil
	case schetask.FieldDestLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestLon(v)
		return nil
	case schetask.FieldDestLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestLat(v)
		return nil
	case schetask.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schetask.FieldLoadLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadLimit(v)
		return nil
	case schetask.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case schetask.FieldAbnormalState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbnormalState(v)
		return nil
	case schetask.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case schetask.FieldRoutingPath:
		v, ok := value.(types.RoutingPath)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingPath(v)
		return nil
	case schetask.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case schetask.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case schetask.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScheTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheTaskMutation) AddedFields() []string {
	var fields []string
	if m.adduser_type != nil {
		fields = append(fields, schetask.FieldUserType)
	}
	if m.adduser_id != nil {
		fields = append(fields, schetask.FieldUserID)
	}
	if m.addscenic_area_id != nil {
		fields = append(fields, schetask.FieldScenicAreaID)
	}
	if m.adddest_id != nil {
		fields = append(fields, schetask.FieldDestID)
	}
	if m.adddest_lon != nil {
		fields = append(fields, schetask.FieldDestLon)
	}
	if m.adddest_lat != nil {
		fields = append(fields, schetask.FieldDestLat)
	}
	if m.add_type != nil {
		fields = append(fields, schetask.FieldType)
	}
	if m.addload_limit != nil {
		fields = append(fields, schetask.FieldLoadLimit)
	}
	if m.addstate != nil {
		fields = append(fields, schetask.FieldState)
	}
	if m.addabnormal_state != nil {
		fields = append(fields, schetask.FieldAbnormalState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schetask.FieldUserType:
		return m.AddedUserType()
	case schetask.FieldUserID:
		return m.AddedUserID()
	case schetask.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case schetask.FieldDestID:
		return m.AddedDestID()
	case schetask.FieldDestLon:
		return m.AddedDestLon()
	case schetask.FieldDestLat:
		return m.AddedDestLat()
	case schetask.FieldType:
		return m.AddedType()
	case schetask.FieldLoadLimit:
		return m.AddedLoadLimit()
	case schetask.FieldState:
		return m.AddedState()
	case schetask.FieldAbnormalState:
		return m.AddedAbnormalState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schetask.FieldUserType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserType(v)
		return nil
	case schetask.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case schetask.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case schetask.FieldDestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDestID(v)
		return nil
	case schetask.FieldDestLon:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDestLon(v)
		return nil
	case schetask.FieldDestLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDestLat(v)
		return nil
	case schetask.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case schetask.FieldLoadLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadLimit(v)
		return nil
	case schetask.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case schetask.FieldAbnormalState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbnormalState(v)
		return nil
	}
	return fmt.Errorf("unknown ScheTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schetask.FieldEndTime) {
		fields = append(fields, schetask.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheTaskMutation) ClearField(name string) error {
	switch name {
	case schetask.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown ScheTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheTaskMutation) ResetField(name string) error {
	switch name {
	case schetask.FieldUserType:
		m.ResetUserType()
		return nil
	case schetask.FieldUserID:
		m.ResetUserID()
		return nil
	case schetask.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case schetask.FieldCarID:
		m.ResetCarID()
		return nil
	case schetask.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case schetask.FieldDestID:
		m.ResetDestID()
		return nil
	case schetask.FieldDestLon:
		m.ResetDestLon()
		return nil
	case schetask.FieldDestLat:
		m.ResetDestLat()
		return nil
	case schetask.FieldType:
		m.ResetType()
		return nil
	case schetask.FieldLoadLimit:
		m.ResetLoadLimit()
		return nil
	case schetask.FieldState:
		m.ResetState()
		return nil
	case schetask.FieldAbnormalState:
		m.ResetAbnormalState()
		return nil
	case schetask.FieldRemark:
		m.ResetRemark()
		return nil
	case schetask.FieldRoutingPath:
		m.ResetRoutingPath()
		return nil
	case schetask.FieldEndTime:
		m.ResetEndTime()
		return nil
	case schetask.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case schetask.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ScheTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.car != nil {
		edges = append(edges, schetask.EdgeCar)
	}
	if m.events != nil {
		edges = append(edges, schetask.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schetask.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case schetask.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, schetask.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schetask.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcar {
		edges = append(edges, schetask.EdgeCar)
	}
	if m.clearedevents {
		edges = append(edges, schetask.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case schetask.EdgeCar:
		return m.clearedcar
	case schetask.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheTaskMutation) ClearEdge(name string) error {
	switch name {
	case schetask.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ScheTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheTaskMutation) ResetEdge(name string) error {
	switch name {
	case schetask.EdgeCar:
		m.ResetCar()
		return nil
	case schetask.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown ScheTask edge %s", name)
}

// ScheTaskEventMutation represents an operation that mutates the ScheTaskEvent nodes in the graph.
type ScheTaskEventMutation struct {
	config
	op                Op
	typ               string
	id                *int
	state             *int
	addstate          *int
	abnormal_state    *int
	addabnormal_state *int
	remark            *string
	create_time       *time.Time
	clearedFields     map[string]struct{}
	sche_task         *int
	clearedsche_task  bool
	done              bool
	oldValue          func(context.Context) (*ScheTaskEvent, error)
	predicates        []predicate.ScheTaskEvent
}

var _ ent.Mutation = (*ScheTaskEventMutation)(nil)

// schetaskeventOption allows management of the mutation configuration using functional options.
type schetaskeventOption func(*ScheTaskEventMutation)

// newScheTaskEventMutation creates new mutation for the ScheTaskEvent entity.
func newScheTaskEventMutation(c config, op Op, opts ...schetaskeventOption) *ScheTaskEventMutation {
	m := &ScheTaskEventMutation{
		config:        c,
		op:            op,
		typ:           TypeScheTaskEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheTaskEventID sets the ID field of the mutation.
func withScheTaskEventID(id int) schetaskeventOption {
	return func(m *ScheTaskEventMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheTaskEvent
		)
		m.oldValue = func(ctx context.Context) (*ScheTaskEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheTaskEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheTaskEvent sets the old ScheTaskEvent of the mutation.
func withScheTaskEvent(node *ScheTaskEvent) schetaskeventOption {
	return func(m *ScheTaskEventMutation) {
		m.oldValue = func(context.Context) (*ScheTaskEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheTaskEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheTaskEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheTaskEvent entities.
func (m *ScheTaskEventMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheTaskEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheTaskEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheTaskEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScheTaskID sets the "sche_task_id" field.
func (m *ScheTaskEventMutation) SetScheTaskID(i int) {
	m.sche_task = &i
}

// ScheTaskID returns the value of the "sche_task_id" field in the mutation.
func (m *ScheTaskEventMutation) ScheTaskID() (r int, exists bool) {
	v := m.sche_task
	if v == nil {
		return
	}
	return *v, true
}

// OldScheTaskID returns the old "sche_task_id" field's value of the ScheTaskEvent entity.
// If the ScheTaskEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskEventMutation) OldScheTaskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheTaskID: %w", err)
	}
	return oldValue.ScheTaskID, nil
}

// ResetScheTaskID resets all changes to the "sche_task_id" field.
func (m *ScheTaskEventMutation) ResetScheTaskID() {
	m.sche_task = nil
}

// SetState sets the "state" field.
func (m *ScheTaskEventMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *ScheTaskEventMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the ScheTaskEvent entity.
// If the ScheTaskEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskEventMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *ScheTaskEventMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *ScheTaskEventMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *ScheTaskEventMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetAbnormalState sets the "abnormal_state" field.
func (m *ScheTaskEventMutation) SetAbnormalState(i int) {
	m.abnormal_state = &i
	m.addabnormal_state = nil
}

// AbnormalState returns the value of the "abnormal_state" field in the mutation.
func (m *ScheTaskEventMutation) AbnormalState() (r int, exists bool) {
	v := m.abnormal_state
	if v == nil {
		return
	}
	return *v, true
}

// OldAbnormalState returns the old "abnormal_state" field's value of the ScheTaskEvent entity.
// If the ScheTaskEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskEventMutation) OldAbnormalState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbnormalState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbnormalState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbnormalState: %w", err)
	}
	return oldValue.AbnormalState, nil
}

// AddAbnormalState adds i to the "abnormal_state" field.
func (m *ScheTaskEventMutation) AddAbnormalState(i int) {
	if m.addabnormal_state != nil {
		*m.addabnormal_state += i
	} else {
		m.addabnormal_state = &i
	}
}

// AddedAbnormalState returns the value that was added to the "abnormal_state" field in this mutation.
func (m *ScheTaskEventMutation) AddedAbnormalState() (r int, exists bool) {
	v := m.addabnormal_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbnormalState resets all changes to the "abnormal_state" field.
func (m *ScheTaskEventMutation) ResetAbnormalState() {
	m.abnormal_state = nil
	m.addabnormal_state = nil
}

// SetRemark sets the "remark" field.
func (m *ScheTaskEventMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ScheTaskEventMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ScheTaskEvent entity.
// If the ScheTaskEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskEventMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ScheTaskEventMutation) ResetRemark() {
	m.remark = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ScheTaskEventMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScheTaskEventMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ScheTaskEvent entity.
// If the ScheTaskEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheTaskEventMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScheTaskEventMutation) ResetCreateTime() {
	m.create_time = nil
}

// ClearScheTask clears the "sche_task" edge to the ScheTask entity.
func (m *ScheTaskEventMutation) ClearScheTask() {
	m.clearedsche_task = true
	m.clearedFields[schetaskevent.FieldScheTaskID] = struct{}{}
}

// ScheTaskCleared reports if the "sche_task" edge to the ScheTask entity was cleared.
func (m *ScheTaskEventMutation) ScheTaskCleared() bool {
	return m.clearedsche_task
}

// ScheTaskIDs returns the "sche_task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheTaskID instead. It exists only for internal usage by the builders.
func (m *ScheTaskEventMutation) ScheTaskIDs() (ids []int) {
	if id := m.sche_task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheTask resets all changes to the "sche_task" edge.
func (m *ScheTaskEventMutation) ResetScheTask() {
	m.sche_task = nil
	m.clearedsche_task = false
}

// Where appends a list predicates to the ScheTaskEventMutation builder.
func (m *ScheTaskEventMutation) Where(ps ...predicate.ScheTaskEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheTaskEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheTaskEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheTaskEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheTaskEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheTaskEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheTaskEvent).
func (m *ScheTaskEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheTaskEventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.sche_task != nil {
		fields = append(fields, schetaskevent.FieldScheTaskID)
	}
	if m.state != nil {
		fields = append(fields, schetaskevent.FieldState)
	}
	if m.abnormal_state != nil {
		fields = append(fields, schetaskevent.FieldAbnormalState)
	}
	if m.remark != nil {
		fields = append(fields, schetaskevent.FieldRemark)
	}
	if m.create_time != nil {
		fields = append(fields, schetaskevent.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheTaskEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schetaskevent.FieldScheTaskID:
		return m.ScheTaskID()
	case schetaskevent.FieldState:
		return m.State()
	case schetaskevent.FieldAbnormalState:
		return m.AbnormalState()
	case schetaskevent.FieldRemark:
		return m.Remark()
	case schetaskevent.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheTaskEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schetaskevent.FieldScheTaskID:
		return m.OldScheTaskID(ctx)
	case schetaskevent.FieldState:
		return m.OldState(ctx)
	case schetaskevent.FieldAbnormalState:
		return m.OldAbnormalState(ctx)
	case schetaskevent.FieldRemark:
		return m.OldRemark(ctx)
	case schetaskevent.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ScheTaskEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheTaskEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schetaskevent.FieldScheTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheTaskID(v)
		return nil
	case schetaskevent.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case schetaskevent.FieldAbnormalState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbnormalState(v)
		return nil
	case schetaskevent.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case schetaskevent.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ScheTaskEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheTaskEventMutation) AddedFields() []string {
	var fields []string
	if m.addstate != nil {
		fields = append(fields, schetaskevent.FieldState)
	}
	if m.addabnormal_state != nil {
		fields = append(fields, schetaskevent.FieldAbnormalState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheTaskEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schetaskevent.FieldState:
		return m.AddedState()
	case schetaskevent.FieldAbnormalState:
		return m.AddedAbnormalState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheTaskEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schetaskevent.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case schetaskevent.FieldAbnormalState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbnormalState(v)
		return nil
	}
	return fmt.Errorf("unknown ScheTaskEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheTaskEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheTaskEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheTaskEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ScheTaskEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheTaskEventMutation) ResetField(name string) error {
	switch name {
	case schetaskevent.FieldScheTaskID:
		m.ResetScheTaskID()
		return nil
	case schetaskevent.FieldState:
		m.ResetState()
		return nil
	case schetaskevent.FieldAbnormalState:
		m.ResetAbnormalState()
		return nil
	case schetaskevent.FieldRemark:
		m.ResetRemark()
		return nil
	case schetaskevent.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown ScheTaskEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheTaskEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sche_task != nil {
		edges = append(edges, schetaskevent.EdgeScheTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheTaskEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schetaskevent.EdgeScheTask:
		if id := m.sche_task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheTaskEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheTaskEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheTaskEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsche_task {
		edges = append(edges, schetaskevent.EdgeScheTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheTaskEventMutation) EdgeCleared(name string) bool {
	switch name {
	case schetaskevent.EdgeScheTask:
		return m.clearedsche_task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheTaskEventMutation) ClearEdge(name string) error {
	switch name {
	case schetaskevent.EdgeScheTask:
		m.ClearScheTask()
		return nil
	}
	return fmt.Errorf("unknown ScheTaskEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheTaskEventMutation) ResetEdge(name string) error {
	switch name {
	case schetaskevent.EdgeScheTask:
		m.ResetScheTask()
		return nil
	}
	return fmt.Errorf("unknown ScheTaskEvent edge %s", name)
}

// SshAccountMutation represents an operation that mutates the SshAccount nodes in the graph.
type SshAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int
	delete_time       *time.Time
	_type             *string
	username          *string
	password          *string
	scenic_area_id    *int
	addscenic_area_id *int
	car_id            *int
	addcar_id         *int
	state             *int
	addstate          *int
	use_time          *time.Time
	create_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*SshAccount, error)
	predicates        []predicate.SshAccount
}

var _ ent.Mutation = (*SshAccountMutation)(nil)

// sshaccountOption allows management of the mutation configuration using functional options.
type sshaccountOption func(*SshAccountMutation)

// newSshAccountMutation creates new mutation for the SshAccount entity.
func newSshAccountMutation(c config, op Op, opts ...sshaccountOption) *SshAccountMutation {
	m := &SshAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeSshAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSshAccountID sets the ID field of the mutation.
func withSshAccountID(id int) sshaccountOption {
	return func(m *SshAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *SshAccount
		)
		m.oldValue = func(ctx context.Context) (*SshAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SshAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSshAccount sets the old SshAccount of the mutation.
func withSshAccount(node *SshAccount) sshaccountOption {
	return func(m *SshAccountMutation) {
		m.oldValue = func(context.Context) (*SshAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SshAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SshAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SshAccount entities.
func (m *SshAccountMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SshAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SshAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SshAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeleteTime sets the "delete_time" field.
func (m *SshAccountMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SshAccountMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SshAccountMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sshaccount.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SshAccountMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sshaccount.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SshAccountMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sshaccount.FieldDeleteTime)
}

// SetType sets the "type" field.
func (m *SshAccountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SshAccountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SshAccountMutation) ResetType() {
	m._type = nil
}

// SetUsername sets the "username" field.
func (m *SshAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SshAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *SshAccountMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *SshAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *SshAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *SshAccountMutation) ResetPassword() {
	m.password = nil
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *SshAccountMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *SshAccountMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldScenicAreaID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *SshAccountMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *SshAccountMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *SshAccountMutation) ClearScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	m.clearedFields[sshaccount.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *SshAccountMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[sshaccount.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *SshAccountMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
	delete(m.clearedFields, sshaccount.FieldScenicAreaID)
}

// SetCarID sets the "car_id" field.
func (m *SshAccountMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *SshAccountMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldCarID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *SshAccountMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *SshAccountMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarID clears the value of the "car_id" field.
func (m *SshAccountMutation) ClearCarID() {
	m.car_id = nil
	m.addcar_id = nil
	m.clearedFields[sshaccount.FieldCarID] = struct{}{}
}

// CarIDCleared returns if the "car_id" field was cleared in this mutation.
func (m *SshAccountMutation) CarIDCleared() bool {
	_, ok := m.clearedFields[sshaccount.FieldCarID]
	return ok
}

// ResetCarID resets all changes to the "car_id" field.
func (m *SshAccountMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
	delete(m.clearedFields, sshaccount.FieldCarID)
}

// SetState sets the "state" field.
func (m *SshAccountMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *SshAccountMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *SshAccountMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *SshAccountMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *SshAccountMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetUseTime sets the "use_time" field.
func (m *SshAccountMutation) SetUseTime(t time.Time) {
	m.use_time = &t
}

// UseTime returns the value of the "use_time" field in the mutation.
func (m *SshAccountMutation) UseTime() (r time.Time, exists bool) {
	v := m.use_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUseTime returns the old "use_time" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldUseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseTime: %w", err)
	}
	return oldValue.UseTime, nil
}

// ClearUseTime clears the value of the "use_time" field.
func (m *SshAccountMutation) ClearUseTime() {
	m.use_time = nil
	m.clearedFields[sshaccount.FieldUseTime] = struct{}{}
}

// UseTimeCleared returns if the "use_time" field was cleared in this mutation.
func (m *SshAccountMutation) UseTimeCleared() bool {
	_, ok := m.clearedFields[sshaccount.FieldUseTime]
	return ok
}

// ResetUseTime resets all changes to the "use_time" field.
func (m *SshAccountMutation) ResetUseTime() {
	m.use_time = nil
	delete(m.clearedFields, sshaccount.FieldUseTime)
}

// SetCreateTime sets the "create_time" field.
func (m *SshAccountMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SshAccountMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SshAccountMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SshAccountMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SshAccountMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SshAccount entity.
// If the SshAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SshAccountMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SshAccountMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the SshAccountMutation builder.
func (m *SshAccountMutation) Where(ps ...predicate.SshAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SshAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SshAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SshAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SshAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SshAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SshAccount).
func (m *SshAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SshAccountMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.delete_time != nil {
		fields = append(fields, sshaccount.FieldDeleteTime)
	}
	if m._type != nil {
		fields = append(fields, sshaccount.FieldType)
	}
	if m.username != nil {
		fields = append(fields, sshaccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, sshaccount.FieldPassword)
	}
	if m.scenic_area_id != nil {
		fields = append(fields, sshaccount.FieldScenicAreaID)
	}
	if m.car_id != nil {
		fields = append(fields, sshaccount.FieldCarID)
	}
	if m.state != nil {
		fields = append(fields, sshaccount.FieldState)
	}
	if m.use_time != nil {
		fields = append(fields, sshaccount.FieldUseTime)
	}
	if m.create_time != nil {
		fields = append(fields, sshaccount.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sshaccount.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SshAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sshaccount.FieldDeleteTime:
		return m.DeleteTime()
	case sshaccount.FieldType:
		return m.GetType()
	case sshaccount.FieldUsername:
		return m.Username()
	case sshaccount.FieldPassword:
		return m.Password()
	case sshaccount.FieldScenicAreaID:
		return m.ScenicAreaID()
	case sshaccount.FieldCarID:
		return m.CarID()
	case sshaccount.FieldState:
		return m.State()
	case sshaccount.FieldUseTime:
		return m.UseTime()
	case sshaccount.FieldCreateTime:
		return m.CreateTime()
	case sshaccount.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SshAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sshaccount.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sshaccount.FieldType:
		return m.OldType(ctx)
	case sshaccount.FieldUsername:
		return m.OldUsername(ctx)
	case sshaccount.FieldPassword:
		return m.OldPassword(ctx)
	case sshaccount.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case sshaccount.FieldCarID:
		return m.OldCarID(ctx)
	case sshaccount.FieldState:
		return m.OldState(ctx)
	case sshaccount.FieldUseTime:
		return m.OldUseTime(ctx)
	case sshaccount.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sshaccount.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown SshAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SshAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sshaccount.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sshaccount.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case sshaccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case sshaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case sshaccount.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case sshaccount.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case sshaccount.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case sshaccount.FieldUseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseTime(v)
		return nil
	case sshaccount.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sshaccount.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown SshAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SshAccountMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, sshaccount.FieldScenicAreaID)
	}
	if m.addcar_id != nil {
		fields = append(fields, sshaccount.FieldCarID)
	}
	if m.addstate != nil {
		fields = append(fields, sshaccount.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SshAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sshaccount.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case sshaccount.FieldCarID:
		return m.AddedCarID()
	case sshaccount.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SshAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sshaccount.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case sshaccount.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case sshaccount.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown SshAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SshAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sshaccount.FieldDeleteTime) {
		fields = append(fields, sshaccount.FieldDeleteTime)
	}
	if m.FieldCleared(sshaccount.FieldScenicAreaID) {
		fields = append(fields, sshaccount.FieldScenicAreaID)
	}
	if m.FieldCleared(sshaccount.FieldCarID) {
		fields = append(fields, sshaccount.FieldCarID)
	}
	if m.FieldCleared(sshaccount.FieldUseTime) {
		fields = append(fields, sshaccount.FieldUseTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SshAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SshAccountMutation) ClearField(name string) error {
	switch name {
	case sshaccount.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sshaccount.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case sshaccount.FieldCarID:
		m.ClearCarID()
		return nil
	case sshaccount.FieldUseTime:
		m.ClearUseTime()
		return nil
	}
	return fmt.Errorf("unknown SshAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SshAccountMutation) ResetField(name string) error {
	switch name {
	case sshaccount.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sshaccount.FieldType:
		m.ResetType()
		return nil
	case sshaccount.FieldUsername:
		m.ResetUsername()
		return nil
	case sshaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case sshaccount.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case sshaccount.FieldCarID:
		m.ResetCarID()
		return nil
	case sshaccount.FieldState:
		m.ResetState()
		return nil
	case sshaccount.FieldUseTime:
		m.ResetUseTime()
		return nil
	case sshaccount.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sshaccount.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown SshAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SshAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SshAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SshAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SshAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SshAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SshAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SshAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SshAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SshAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SshAccount edge %s", name)
}

// StatsDailyMutation represents an operation that mutates the StatsDaily nodes in the graph.
type StatsDailyMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	scenic_area_id            *int
	addscenic_area_id         *int
	y                         *string
	ym                        *string
	ymd                       *string
	order_amount              *int
	addorder_amount           *int
	order_count               *int
	addorder_count            *int
	order_duration            *int
	addorder_duration         *int
	order_distance            *int
	addorder_distance         *int
	register_user_count       *int
	addregister_user_count    *int
	order_user_count          *int
	addorder_user_count       *int
	operation_car_count       *int
	addoperation_car_count    *int
	operation_car_duration    *int
	addoperation_car_duration *int
	create_time               *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*StatsDaily, error)
	predicates                []predicate.StatsDaily
}

var _ ent.Mutation = (*StatsDailyMutation)(nil)

// statsdailyOption allows management of the mutation configuration using functional options.
type statsdailyOption func(*StatsDailyMutation)

// newStatsDailyMutation creates new mutation for the StatsDaily entity.
func newStatsDailyMutation(c config, op Op, opts ...statsdailyOption) *StatsDailyMutation {
	m := &StatsDailyMutation{
		config:        c,
		op:            op,
		typ:           TypeStatsDaily,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatsDailyID sets the ID field of the mutation.
func withStatsDailyID(id int) statsdailyOption {
	return func(m *StatsDailyMutation) {
		var (
			err   error
			once  sync.Once
			value *StatsDaily
		)
		m.oldValue = func(ctx context.Context) (*StatsDaily, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatsDaily.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatsDaily sets the old StatsDaily of the mutation.
func withStatsDaily(node *StatsDaily) statsdailyOption {
	return func(m *StatsDailyMutation) {
		m.oldValue = func(context.Context) (*StatsDaily, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatsDailyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatsDailyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatsDaily entities.
func (m *StatsDailyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatsDailyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatsDailyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatsDaily.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *StatsDailyMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *StatsDailyMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *StatsDailyMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *StatsDailyMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *StatsDailyMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetY sets the "y" field.
func (m *StatsDailyMutation) SetY(s string) {
	m.y = &s
}

// Y returns the value of the "y" field in the mutation.
func (m *StatsDailyMutation) Y() (r string, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// ResetY resets all changes to the "y" field.
func (m *StatsDailyMutation) ResetY() {
	m.y = nil
}

// SetYm sets the "ym" field.
func (m *StatsDailyMutation) SetYm(s string) {
	m.ym = &s
}

// Ym returns the value of the "ym" field in the mutation.
func (m *StatsDailyMutation) Ym() (r string, exists bool) {
	v := m.ym
	if v == nil {
		return
	}
	return *v, true
}

// OldYm returns the old "ym" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldYm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYm: %w", err)
	}
	return oldValue.Ym, nil
}

// ResetYm resets all changes to the "ym" field.
func (m *StatsDailyMutation) ResetYm() {
	m.ym = nil
}

// SetYmd sets the "ymd" field.
func (m *StatsDailyMutation) SetYmd(s string) {
	m.ymd = &s
}

// Ymd returns the value of the "ymd" field in the mutation.
func (m *StatsDailyMutation) Ymd() (r string, exists bool) {
	v := m.ymd
	if v == nil {
		return
	}
	return *v, true
}

// OldYmd returns the old "ymd" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldYmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYmd: %w", err)
	}
	return oldValue.Ymd, nil
}

// ResetYmd resets all changes to the "ymd" field.
func (m *StatsDailyMutation) ResetYmd() {
	m.ymd = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *StatsDailyMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *StatsDailyMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *StatsDailyMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *StatsDailyMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *StatsDailyMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderCount sets the "order_count" field.
func (m *StatsDailyMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *StatsDailyMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *StatsDailyMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *StatsDailyMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *StatsDailyMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
}

// SetOrderDuration sets the "order_duration" field.
func (m *StatsDailyMutation) SetOrderDuration(i int) {
	m.order_duration = &i
	m.addorder_duration = nil
}

// OrderDuration returns the value of the "order_duration" field in the mutation.
func (m *StatsDailyMutation) OrderDuration() (r int, exists bool) {
	v := m.order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDuration returns the old "order_duration" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOrderDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDuration: %w", err)
	}
	return oldValue.OrderDuration, nil
}

// AddOrderDuration adds i to the "order_duration" field.
func (m *StatsDailyMutation) AddOrderDuration(i int) {
	if m.addorder_duration != nil {
		*m.addorder_duration += i
	} else {
		m.addorder_duration = &i
	}
}

// AddedOrderDuration returns the value that was added to the "order_duration" field in this mutation.
func (m *StatsDailyMutation) AddedOrderDuration() (r int, exists bool) {
	v := m.addorder_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDuration resets all changes to the "order_duration" field.
func (m *StatsDailyMutation) ResetOrderDuration() {
	m.order_duration = nil
	m.addorder_duration = nil
}

// SetOrderDistance sets the "order_distance" field.
func (m *StatsDailyMutation) SetOrderDistance(i int) {
	m.order_distance = &i
	m.addorder_distance = nil
}

// OrderDistance returns the value of the "order_distance" field in the mutation.
func (m *StatsDailyMutation) OrderDistance() (r int, exists bool) {
	v := m.order_distance
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDistance returns the old "order_distance" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOrderDistance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDistance: %w", err)
	}
	return oldValue.OrderDistance, nil
}

// AddOrderDistance adds i to the "order_distance" field.
func (m *StatsDailyMutation) AddOrderDistance(i int) {
	if m.addorder_distance != nil {
		*m.addorder_distance += i
	} else {
		m.addorder_distance = &i
	}
}

// AddedOrderDistance returns the value that was added to the "order_distance" field in this mutation.
func (m *StatsDailyMutation) AddedOrderDistance() (r int, exists bool) {
	v := m.addorder_distance
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDistance resets all changes to the "order_distance" field.
func (m *StatsDailyMutation) ResetOrderDistance() {
	m.order_distance = nil
	m.addorder_distance = nil
}

// SetRegisterUserCount sets the "register_user_count" field.
func (m *StatsDailyMutation) SetRegisterUserCount(i int) {
	m.register_user_count = &i
	m.addregister_user_count = nil
}

// RegisterUserCount returns the value of the "register_user_count" field in the mutation.
func (m *StatsDailyMutation) RegisterUserCount() (r int, exists bool) {
	v := m.register_user_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterUserCount returns the old "register_user_count" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldRegisterUserCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterUserCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterUserCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterUserCount: %w", err)
	}
	return oldValue.RegisterUserCount, nil
}

// AddRegisterUserCount adds i to the "register_user_count" field.
func (m *StatsDailyMutation) AddRegisterUserCount(i int) {
	if m.addregister_user_count != nil {
		*m.addregister_user_count += i
	} else {
		m.addregister_user_count = &i
	}
}

// AddedRegisterUserCount returns the value that was added to the "register_user_count" field in this mutation.
func (m *StatsDailyMutation) AddedRegisterUserCount() (r int, exists bool) {
	v := m.addregister_user_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegisterUserCount resets all changes to the "register_user_count" field.
func (m *StatsDailyMutation) ResetRegisterUserCount() {
	m.register_user_count = nil
	m.addregister_user_count = nil
}

// SetOrderUserCount sets the "order_user_count" field.
func (m *StatsDailyMutation) SetOrderUserCount(i int) {
	m.order_user_count = &i
	m.addorder_user_count = nil
}

// OrderUserCount returns the value of the "order_user_count" field in the mutation.
func (m *StatsDailyMutation) OrderUserCount() (r int, exists bool) {
	v := m.order_user_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderUserCount returns the old "order_user_count" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOrderUserCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderUserCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderUserCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderUserCount: %w", err)
	}
	return oldValue.OrderUserCount, nil
}

// AddOrderUserCount adds i to the "order_user_count" field.
func (m *StatsDailyMutation) AddOrderUserCount(i int) {
	if m.addorder_user_count != nil {
		*m.addorder_user_count += i
	} else {
		m.addorder_user_count = &i
	}
}

// AddedOrderUserCount returns the value that was added to the "order_user_count" field in this mutation.
func (m *StatsDailyMutation) AddedOrderUserCount() (r int, exists bool) {
	v := m.addorder_user_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderUserCount resets all changes to the "order_user_count" field.
func (m *StatsDailyMutation) ResetOrderUserCount() {
	m.order_user_count = nil
	m.addorder_user_count = nil
}

// SetOperationCarCount sets the "operation_car_count" field.
func (m *StatsDailyMutation) SetOperationCarCount(i int) {
	m.operation_car_count = &i
	m.addoperation_car_count = nil
}

// OperationCarCount returns the value of the "operation_car_count" field in the mutation.
func (m *StatsDailyMutation) OperationCarCount() (r int, exists bool) {
	v := m.operation_car_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationCarCount returns the old "operation_car_count" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOperationCarCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationCarCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationCarCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationCarCount: %w", err)
	}
	return oldValue.OperationCarCount, nil
}

// AddOperationCarCount adds i to the "operation_car_count" field.
func (m *StatsDailyMutation) AddOperationCarCount(i int) {
	if m.addoperation_car_count != nil {
		*m.addoperation_car_count += i
	} else {
		m.addoperation_car_count = &i
	}
}

// AddedOperationCarCount returns the value that was added to the "operation_car_count" field in this mutation.
func (m *StatsDailyMutation) AddedOperationCarCount() (r int, exists bool) {
	v := m.addoperation_car_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationCarCount resets all changes to the "operation_car_count" field.
func (m *StatsDailyMutation) ResetOperationCarCount() {
	m.operation_car_count = nil
	m.addoperation_car_count = nil
}

// SetOperationCarDuration sets the "operation_car_duration" field.
func (m *StatsDailyMutation) SetOperationCarDuration(i int) {
	m.operation_car_duration = &i
	m.addoperation_car_duration = nil
}

// OperationCarDuration returns the value of the "operation_car_duration" field in the mutation.
func (m *StatsDailyMutation) OperationCarDuration() (r int, exists bool) {
	v := m.operation_car_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationCarDuration returns the old "operation_car_duration" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldOperationCarDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationCarDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationCarDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationCarDuration: %w", err)
	}
	return oldValue.OperationCarDuration, nil
}

// AddOperationCarDuration adds i to the "operation_car_duration" field.
func (m *StatsDailyMutation) AddOperationCarDuration(i int) {
	if m.addoperation_car_duration != nil {
		*m.addoperation_car_duration += i
	} else {
		m.addoperation_car_duration = &i
	}
}

// AddedOperationCarDuration returns the value that was added to the "operation_car_duration" field in this mutation.
func (m *StatsDailyMutation) AddedOperationCarDuration() (r int, exists bool) {
	v := m.addoperation_car_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationCarDuration resets all changes to the "operation_car_duration" field.
func (m *StatsDailyMutation) ResetOperationCarDuration() {
	m.operation_car_duration = nil
	m.addoperation_car_duration = nil
}

// SetCreateTime sets the "create_time" field.
func (m *StatsDailyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatsDailyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatsDaily entity.
// If the StatsDaily object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatsDailyMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the StatsDailyMutation builder.
func (m *StatsDailyMutation) Where(ps ...predicate.StatsDaily) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatsDailyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatsDailyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatsDaily, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatsDailyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatsDailyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatsDaily).
func (m *StatsDailyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatsDailyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.scenic_area_id != nil {
		fields = append(fields, statsdaily.FieldScenicAreaID)
	}
	if m.y != nil {
		fields = append(fields, statsdaily.FieldY)
	}
	if m.ym != nil {
		fields = append(fields, statsdaily.FieldYm)
	}
	if m.ymd != nil {
		fields = append(fields, statsdaily.FieldYmd)
	}
	if m.order_amount != nil {
		fields = append(fields, statsdaily.FieldOrderAmount)
	}
	if m.order_count != nil {
		fields = append(fields, statsdaily.FieldOrderCount)
	}
	if m.order_duration != nil {
		fields = append(fields, statsdaily.FieldOrderDuration)
	}
	if m.order_distance != nil {
		fields = append(fields, statsdaily.FieldOrderDistance)
	}
	if m.register_user_count != nil {
		fields = append(fields, statsdaily.FieldRegisterUserCount)
	}
	if m.order_user_count != nil {
		fields = append(fields, statsdaily.FieldOrderUserCount)
	}
	if m.operation_car_count != nil {
		fields = append(fields, statsdaily.FieldOperationCarCount)
	}
	if m.operation_car_duration != nil {
		fields = append(fields, statsdaily.FieldOperationCarDuration)
	}
	if m.create_time != nil {
		fields = append(fields, statsdaily.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatsDailyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statsdaily.FieldScenicAreaID:
		return m.ScenicAreaID()
	case statsdaily.FieldY:
		return m.Y()
	case statsdaily.FieldYm:
		return m.Ym()
	case statsdaily.FieldYmd:
		return m.Ymd()
	case statsdaily.FieldOrderAmount:
		return m.OrderAmount()
	case statsdaily.FieldOrderCount:
		return m.OrderCount()
	case statsdaily.FieldOrderDuration:
		return m.OrderDuration()
	case statsdaily.FieldOrderDistance:
		return m.OrderDistance()
	case statsdaily.FieldRegisterUserCount:
		return m.RegisterUserCount()
	case statsdaily.FieldOrderUserCount:
		return m.OrderUserCount()
	case statsdaily.FieldOperationCarCount:
		return m.OperationCarCount()
	case statsdaily.FieldOperationCarDuration:
		return m.OperationCarDuration()
	case statsdaily.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatsDailyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statsdaily.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case statsdaily.FieldY:
		return m.OldY(ctx)
	case statsdaily.FieldYm:
		return m.OldYm(ctx)
	case statsdaily.FieldYmd:
		return m.OldYmd(ctx)
	case statsdaily.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case statsdaily.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case statsdaily.FieldOrderDuration:
		return m.OldOrderDuration(ctx)
	case statsdaily.FieldOrderDistance:
		return m.OldOrderDistance(ctx)
	case statsdaily.FieldRegisterUserCount:
		return m.OldRegisterUserCount(ctx)
	case statsdaily.FieldOrderUserCount:
		return m.OldOrderUserCount(ctx)
	case statsdaily.FieldOperationCarCount:
		return m.OldOperationCarCount(ctx)
	case statsdaily.FieldOperationCarDuration:
		return m.OldOperationCarDuration(ctx)
	case statsdaily.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown StatsDaily field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statsdaily.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case statsdaily.FieldY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case statsdaily.FieldYm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYm(v)
		return nil
	case statsdaily.FieldYmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYmd(v)
		return nil
	case statsdaily.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case statsdaily.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case statsdaily.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDuration(v)
		return nil
	case statsdaily.FieldOrderDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDistance(v)
		return nil
	case statsdaily.FieldRegisterUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterUserCount(v)
		return nil
	case statsdaily.FieldOrderUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderUserCount(v)
		return nil
	case statsdaily.FieldOperationCarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationCarCount(v)
		return nil
	case statsdaily.FieldOperationCarDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationCarDuration(v)
		return nil
	case statsdaily.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDaily field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatsDailyMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, statsdaily.FieldScenicAreaID)
	}
	if m.addorder_amount != nil {
		fields = append(fields, statsdaily.FieldOrderAmount)
	}
	if m.addorder_count != nil {
		fields = append(fields, statsdaily.FieldOrderCount)
	}
	if m.addorder_duration != nil {
		fields = append(fields, statsdaily.FieldOrderDuration)
	}
	if m.addorder_distance != nil {
		fields = append(fields, statsdaily.FieldOrderDistance)
	}
	if m.addregister_user_count != nil {
		fields = append(fields, statsdaily.FieldRegisterUserCount)
	}
	if m.addorder_user_count != nil {
		fields = append(fields, statsdaily.FieldOrderUserCount)
	}
	if m.addoperation_car_count != nil {
		fields = append(fields, statsdaily.FieldOperationCarCount)
	}
	if m.addoperation_car_duration != nil {
		fields = append(fields, statsdaily.FieldOperationCarDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatsDailyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statsdaily.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case statsdaily.FieldOrderAmount:
		return m.AddedOrderAmount()
	case statsdaily.FieldOrderCount:
		return m.AddedOrderCount()
	case statsdaily.FieldOrderDuration:
		return m.AddedOrderDuration()
	case statsdaily.FieldOrderDistance:
		return m.AddedOrderDistance()
	case statsdaily.FieldRegisterUserCount:
		return m.AddedRegisterUserCount()
	case statsdaily.FieldOrderUserCount:
		return m.AddedOrderUserCount()
	case statsdaily.FieldOperationCarCount:
		return m.AddedOperationCarCount()
	case statsdaily.FieldOperationCarDuration:
		return m.AddedOperationCarDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statsdaily.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case statsdaily.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case statsdaily.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	case statsdaily.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDuration(v)
		return nil
	case statsdaily.FieldOrderDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDistance(v)
		return nil
	case statsdaily.FieldRegisterUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterUserCount(v)
		return nil
	case statsdaily.FieldOrderUserCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderUserCount(v)
		return nil
	case statsdaily.FieldOperationCarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationCarCount(v)
		return nil
	case statsdaily.FieldOperationCarDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationCarDuration(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDaily numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatsDailyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatsDailyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatsDailyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatsDaily nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatsDailyMutation) ResetField(name string) error {
	switch name {
	case statsdaily.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case statsdaily.FieldY:
		m.ResetY()
		return nil
	case statsdaily.FieldYm:
		m.ResetYm()
		return nil
	case statsdaily.FieldYmd:
		m.ResetYmd()
		return nil
	case statsdaily.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case statsdaily.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case statsdaily.FieldOrderDuration:
		m.ResetOrderDuration()
		return nil
	case statsdaily.FieldOrderDistance:
		m.ResetOrderDistance()
		return nil
	case statsdaily.FieldRegisterUserCount:
		m.ResetRegisterUserCount()
		return nil
	case statsdaily.FieldOrderUserCount:
		m.ResetOrderUserCount()
		return nil
	case statsdaily.FieldOperationCarCount:
		m.ResetOperationCarCount()
		return nil
	case statsdaily.FieldOperationCarDuration:
		m.ResetOperationCarDuration()
		return nil
	case statsdaily.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown StatsDaily field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatsDailyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatsDailyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatsDailyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatsDailyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatsDailyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatsDailyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatsDailyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StatsDaily unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatsDailyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StatsDaily edge %s", name)
}

// StatsDailyCarMutation represents an operation that mutates the StatsDailyCar nodes in the graph.
type StatsDailyCarMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	scenic_area_id               *int
	addscenic_area_id            *int
	car_id                       *int
	addcar_id                    *int
	y                            *int
	addy                         *int
	m                            *int
	addm                         *int
	d                            *int
	addd                         *int
	week                         *int
	addweek                      *int
	weekday                      *int
	addweekday                   *int
	period                       *int
	addperiod                    *int
	order_count_create           *int
	addorder_count_create        *int
	order_count_finish           *int
	addorder_count_finish        *int
	order_count_cancel           *int
	addorder_count_cancel        *int
	order_amount                 *int
	addorder_amount              *int
	order_duration               *int
	addorder_duration            *int
	order_mileage                *int
	addorder_mileage             *int
	order_score                  *int
	addorder_score               *int
	operation_lock_duration      *float32
	addoperation_lock_duration   *float32
	operation_manual_duration    *float32
	addoperation_manual_duration *float32
	operation_auto_duration      *float32
	addoperation_auto_duration   *float32
	operation_fault_duration     *float32
	addoperation_fault_duration  *float32
	operation_lock_times         *uint32
	addoperation_lock_times      *int32
	operation_manual_times       *uint32
	addoperation_manual_times    *int32
	operation_auto_times         *uint32
	addoperation_auto_times      *int32
	operation_fault_times        *uint32
	addoperation_fault_times     *int32
	operation_manual_mileage     *float32
	addoperation_manual_mileage  *float32
	operation_auto_mileage       *float32
	addoperation_auto_mileage    *float32
	maintain_lock_duration       *float32
	addmaintain_lock_duration    *float32
	maintain_manual_duration     *float32
	addmaintain_manual_duration  *float32
	maintain_auto_duration       *float32
	addmaintain_auto_duration    *float32
	maintain_remote_duration     *float32
	addmaintain_remote_duration  *float32
	maintain_fault_duration      *float32
	addmaintain_fault_duration   *float32
	maintain_lock_times          *uint32
	addmaintain_lock_times       *int32
	maintain_manual_times        *uint32
	addmaintain_manual_times     *int32
	maintain_auto_times          *uint32
	addmaintain_auto_times       *int32
	maintain_remote_times        *uint32
	addmaintain_remote_times     *int32
	maintain_fault_times         *uint32
	addmaintain_fault_times      *int32
	maintain_manual_mileage      *float32
	addmaintain_manual_mileage   *float32
	maintain_auto_mileage        *float32
	addmaintain_auto_mileage     *float32
	maintain_remote_mileage      *float32
	addmaintain_remote_mileage   *float32
	alarm_times                  *uint32
	addalarm_times               *int32
	stats_time                   *time.Time
	create_time                  *time.Time
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*StatsDailyCar, error)
	predicates                   []predicate.StatsDailyCar
}

var _ ent.Mutation = (*StatsDailyCarMutation)(nil)

// statsdailycarOption allows management of the mutation configuration using functional options.
type statsdailycarOption func(*StatsDailyCarMutation)

// newStatsDailyCarMutation creates new mutation for the StatsDailyCar entity.
func newStatsDailyCarMutation(c config, op Op, opts ...statsdailycarOption) *StatsDailyCarMutation {
	m := &StatsDailyCarMutation{
		config:        c,
		op:            op,
		typ:           TypeStatsDailyCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatsDailyCarID sets the ID field of the mutation.
func withStatsDailyCarID(id int) statsdailycarOption {
	return func(m *StatsDailyCarMutation) {
		var (
			err   error
			once  sync.Once
			value *StatsDailyCar
		)
		m.oldValue = func(ctx context.Context) (*StatsDailyCar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatsDailyCar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatsDailyCar sets the old StatsDailyCar of the mutation.
func withStatsDailyCar(node *StatsDailyCar) statsdailycarOption {
	return func(m *StatsDailyCarMutation) {
		m.oldValue = func(context.Context) (*StatsDailyCar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatsDailyCarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatsDailyCarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatsDailyCar entities.
func (m *StatsDailyCarMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatsDailyCarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatsDailyCarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatsDailyCar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *StatsDailyCarMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *StatsDailyCarMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *StatsDailyCarMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *StatsDailyCarMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *StatsDailyCarMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetCarID sets the "car_id" field.
func (m *StatsDailyCarMutation) SetCarID(i int) {
	m.car_id = &i
	m.addcar_id = nil
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *StatsDailyCarMutation) CarID() (r int, exists bool) {
	v := m.car_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// AddCarID adds i to the "car_id" field.
func (m *StatsDailyCarMutation) AddCarID(i int) {
	if m.addcar_id != nil {
		*m.addcar_id += i
	} else {
		m.addcar_id = &i
	}
}

// AddedCarID returns the value that was added to the "car_id" field in this mutation.
func (m *StatsDailyCarMutation) AddedCarID() (r int, exists bool) {
	v := m.addcar_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarID resets all changes to the "car_id" field.
func (m *StatsDailyCarMutation) ResetCarID() {
	m.car_id = nil
	m.addcar_id = nil
}

// SetY sets the "y" field.
func (m *StatsDailyCarMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *StatsDailyCarMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *StatsDailyCarMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *StatsDailyCarMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *StatsDailyCarMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetM sets the "m" field.
func (m *StatsDailyCarMutation) SetM(i int) {
	m.m = &i
	m.addm = nil
}

// M returns the value of the "m" field in the mutation.
func (m *StatsDailyCarMutation) M() (r int, exists bool) {
	v := m.m
	if v == nil {
		return
	}
	return *v, true
}

// OldM returns the old "m" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldM is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldM: %w", err)
	}
	return oldValue.M, nil
}

// AddM adds i to the "m" field.
func (m *StatsDailyCarMutation) AddM(i int) {
	if m.addm != nil {
		*m.addm += i
	} else {
		m.addm = &i
	}
}

// AddedM returns the value that was added to the "m" field in this mutation.
func (m *StatsDailyCarMutation) AddedM() (r int, exists bool) {
	v := m.addm
	if v == nil {
		return
	}
	return *v, true
}

// ResetM resets all changes to the "m" field.
func (m *StatsDailyCarMutation) ResetM() {
	m.m = nil
	m.addm = nil
}

// SetD sets the "d" field.
func (m *StatsDailyCarMutation) SetD(i int) {
	m.d = &i
	m.addd = nil
}

// D returns the value of the "d" field in the mutation.
func (m *StatsDailyCarMutation) D() (r int, exists bool) {
	v := m.d
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "d" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// AddD adds i to the "d" field.
func (m *StatsDailyCarMutation) AddD(i int) {
	if m.addd != nil {
		*m.addd += i
	} else {
		m.addd = &i
	}
}

// AddedD returns the value that was added to the "d" field in this mutation.
func (m *StatsDailyCarMutation) AddedD() (r int, exists bool) {
	v := m.addd
	if v == nil {
		return
	}
	return *v, true
}

// ResetD resets all changes to the "d" field.
func (m *StatsDailyCarMutation) ResetD() {
	m.d = nil
	m.addd = nil
}

// SetWeek sets the "week" field.
func (m *StatsDailyCarMutation) SetWeek(i int) {
	m.week = &i
	m.addweek = nil
}

// Week returns the value of the "week" field in the mutation.
func (m *StatsDailyCarMutation) Week() (r int, exists bool) {
	v := m.week
	if v == nil {
		return
	}
	return *v, true
}

// OldWeek returns the old "week" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldWeek(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeek: %w", err)
	}
	return oldValue.Week, nil
}

// AddWeek adds i to the "week" field.
func (m *StatsDailyCarMutation) AddWeek(i int) {
	if m.addweek != nil {
		*m.addweek += i
	} else {
		m.addweek = &i
	}
}

// AddedWeek returns the value that was added to the "week" field in this mutation.
func (m *StatsDailyCarMutation) AddedWeek() (r int, exists bool) {
	v := m.addweek
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeek resets all changes to the "week" field.
func (m *StatsDailyCarMutation) ResetWeek() {
	m.week = nil
	m.addweek = nil
}

// SetWeekday sets the "weekday" field.
func (m *StatsDailyCarMutation) SetWeekday(i int) {
	m.weekday = &i
	m.addweekday = nil
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *StatsDailyCarMutation) Weekday() (r int, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldWeekday(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// AddWeekday adds i to the "weekday" field.
func (m *StatsDailyCarMutation) AddWeekday(i int) {
	if m.addweekday != nil {
		*m.addweekday += i
	} else {
		m.addweekday = &i
	}
}

// AddedWeekday returns the value that was added to the "weekday" field in this mutation.
func (m *StatsDailyCarMutation) AddedWeekday() (r int, exists bool) {
	v := m.addweekday
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *StatsDailyCarMutation) ResetWeekday() {
	m.weekday = nil
	m.addweekday = nil
}

// SetPeriod sets the "period" field.
func (m *StatsDailyCarMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *StatsDailyCarMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *StatsDailyCarMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *StatsDailyCarMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *StatsDailyCarMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetOrderCountCreate sets the "order_count_create" field.
func (m *StatsDailyCarMutation) SetOrderCountCreate(i int) {
	m.order_count_create = &i
	m.addorder_count_create = nil
}

// OrderCountCreate returns the value of the "order_count_create" field in the mutation.
func (m *StatsDailyCarMutation) OrderCountCreate() (r int, exists bool) {
	v := m.order_count_create
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCreate returns the old "order_count_create" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderCountCreate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCreate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCreate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCreate: %w", err)
	}
	return oldValue.OrderCountCreate, nil
}

// AddOrderCountCreate adds i to the "order_count_create" field.
func (m *StatsDailyCarMutation) AddOrderCountCreate(i int) {
	if m.addorder_count_create != nil {
		*m.addorder_count_create += i
	} else {
		m.addorder_count_create = &i
	}
}

// AddedOrderCountCreate returns the value that was added to the "order_count_create" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderCountCreate() (r int, exists bool) {
	v := m.addorder_count_create
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCreate resets all changes to the "order_count_create" field.
func (m *StatsDailyCarMutation) ResetOrderCountCreate() {
	m.order_count_create = nil
	m.addorder_count_create = nil
}

// SetOrderCountFinish sets the "order_count_finish" field.
func (m *StatsDailyCarMutation) SetOrderCountFinish(i int) {
	m.order_count_finish = &i
	m.addorder_count_finish = nil
}

// OrderCountFinish returns the value of the "order_count_finish" field in the mutation.
func (m *StatsDailyCarMutation) OrderCountFinish() (r int, exists bool) {
	v := m.order_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountFinish returns the old "order_count_finish" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderCountFinish(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountFinish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountFinish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountFinish: %w", err)
	}
	return oldValue.OrderCountFinish, nil
}

// AddOrderCountFinish adds i to the "order_count_finish" field.
func (m *StatsDailyCarMutation) AddOrderCountFinish(i int) {
	if m.addorder_count_finish != nil {
		*m.addorder_count_finish += i
	} else {
		m.addorder_count_finish = &i
	}
}

// AddedOrderCountFinish returns the value that was added to the "order_count_finish" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderCountFinish() (r int, exists bool) {
	v := m.addorder_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountFinish resets all changes to the "order_count_finish" field.
func (m *StatsDailyCarMutation) ResetOrderCountFinish() {
	m.order_count_finish = nil
	m.addorder_count_finish = nil
}

// SetOrderCountCancel sets the "order_count_cancel" field.
func (m *StatsDailyCarMutation) SetOrderCountCancel(i int) {
	m.order_count_cancel = &i
	m.addorder_count_cancel = nil
}

// OrderCountCancel returns the value of the "order_count_cancel" field in the mutation.
func (m *StatsDailyCarMutation) OrderCountCancel() (r int, exists bool) {
	v := m.order_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCancel returns the old "order_count_cancel" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderCountCancel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCancel: %w", err)
	}
	return oldValue.OrderCountCancel, nil
}

// AddOrderCountCancel adds i to the "order_count_cancel" field.
func (m *StatsDailyCarMutation) AddOrderCountCancel(i int) {
	if m.addorder_count_cancel != nil {
		*m.addorder_count_cancel += i
	} else {
		m.addorder_count_cancel = &i
	}
}

// AddedOrderCountCancel returns the value that was added to the "order_count_cancel" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderCountCancel() (r int, exists bool) {
	v := m.addorder_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCancel resets all changes to the "order_count_cancel" field.
func (m *StatsDailyCarMutation) ResetOrderCountCancel() {
	m.order_count_cancel = nil
	m.addorder_count_cancel = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *StatsDailyCarMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *StatsDailyCarMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *StatsDailyCarMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *StatsDailyCarMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderDuration sets the "order_duration" field.
func (m *StatsDailyCarMutation) SetOrderDuration(i int) {
	m.order_duration = &i
	m.addorder_duration = nil
}

// OrderDuration returns the value of the "order_duration" field in the mutation.
func (m *StatsDailyCarMutation) OrderDuration() (r int, exists bool) {
	v := m.order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDuration returns the old "order_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDuration: %w", err)
	}
	return oldValue.OrderDuration, nil
}

// AddOrderDuration adds i to the "order_duration" field.
func (m *StatsDailyCarMutation) AddOrderDuration(i int) {
	if m.addorder_duration != nil {
		*m.addorder_duration += i
	} else {
		m.addorder_duration = &i
	}
}

// AddedOrderDuration returns the value that was added to the "order_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderDuration() (r int, exists bool) {
	v := m.addorder_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDuration resets all changes to the "order_duration" field.
func (m *StatsDailyCarMutation) ResetOrderDuration() {
	m.order_duration = nil
	m.addorder_duration = nil
}

// SetOrderMileage sets the "order_mileage" field.
func (m *StatsDailyCarMutation) SetOrderMileage(i int) {
	m.order_mileage = &i
	m.addorder_mileage = nil
}

// OrderMileage returns the value of the "order_mileage" field in the mutation.
func (m *StatsDailyCarMutation) OrderMileage() (r int, exists bool) {
	v := m.order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMileage returns the old "order_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderMileage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMileage: %w", err)
	}
	return oldValue.OrderMileage, nil
}

// AddOrderMileage adds i to the "order_mileage" field.
func (m *StatsDailyCarMutation) AddOrderMileage(i int) {
	if m.addorder_mileage != nil {
		*m.addorder_mileage += i
	} else {
		m.addorder_mileage = &i
	}
}

// AddedOrderMileage returns the value that was added to the "order_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderMileage() (r int, exists bool) {
	v := m.addorder_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderMileage resets all changes to the "order_mileage" field.
func (m *StatsDailyCarMutation) ResetOrderMileage() {
	m.order_mileage = nil
	m.addorder_mileage = nil
}

// SetOrderScore sets the "order_score" field.
func (m *StatsDailyCarMutation) SetOrderScore(i int) {
	m.order_score = &i
	m.addorder_score = nil
}

// OrderScore returns the value of the "order_score" field in the mutation.
func (m *StatsDailyCarMutation) OrderScore() (r int, exists bool) {
	v := m.order_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderScore returns the old "order_score" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOrderScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderScore: %w", err)
	}
	return oldValue.OrderScore, nil
}

// AddOrderScore adds i to the "order_score" field.
func (m *StatsDailyCarMutation) AddOrderScore(i int) {
	if m.addorder_score != nil {
		*m.addorder_score += i
	} else {
		m.addorder_score = &i
	}
}

// AddedOrderScore returns the value that was added to the "order_score" field in this mutation.
func (m *StatsDailyCarMutation) AddedOrderScore() (r int, exists bool) {
	v := m.addorder_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderScore resets all changes to the "order_score" field.
func (m *StatsDailyCarMutation) ResetOrderScore() {
	m.order_score = nil
	m.addorder_score = nil
}

// SetOperationLockDuration sets the "operation_lock_duration" field.
func (m *StatsDailyCarMutation) SetOperationLockDuration(f float32) {
	m.operation_lock_duration = &f
	m.addoperation_lock_duration = nil
}

// OperationLockDuration returns the value of the "operation_lock_duration" field in the mutation.
func (m *StatsDailyCarMutation) OperationLockDuration() (r float32, exists bool) {
	v := m.operation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockDuration returns the old "operation_lock_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockDuration: %w", err)
	}
	return oldValue.OperationLockDuration, nil
}

// AddOperationLockDuration adds f to the "operation_lock_duration" field.
func (m *StatsDailyCarMutation) AddOperationLockDuration(f float32) {
	if m.addoperation_lock_duration != nil {
		*m.addoperation_lock_duration += f
	} else {
		m.addoperation_lock_duration = &f
	}
}

// AddedOperationLockDuration returns the value that was added to the "operation_lock_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationLockDuration() (r float32, exists bool) {
	v := m.addoperation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockDuration resets all changes to the "operation_lock_duration" field.
func (m *StatsDailyCarMutation) ResetOperationLockDuration() {
	m.operation_lock_duration = nil
	m.addoperation_lock_duration = nil
}

// SetOperationManualDuration sets the "operation_manual_duration" field.
func (m *StatsDailyCarMutation) SetOperationManualDuration(f float32) {
	m.operation_manual_duration = &f
	m.addoperation_manual_duration = nil
}

// OperationManualDuration returns the value of the "operation_manual_duration" field in the mutation.
func (m *StatsDailyCarMutation) OperationManualDuration() (r float32, exists bool) {
	v := m.operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualDuration returns the old "operation_manual_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualDuration: %w", err)
	}
	return oldValue.OperationManualDuration, nil
}

// AddOperationManualDuration adds f to the "operation_manual_duration" field.
func (m *StatsDailyCarMutation) AddOperationManualDuration(f float32) {
	if m.addoperation_manual_duration != nil {
		*m.addoperation_manual_duration += f
	} else {
		m.addoperation_manual_duration = &f
	}
}

// AddedOperationManualDuration returns the value that was added to the "operation_manual_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationManualDuration() (r float32, exists bool) {
	v := m.addoperation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualDuration resets all changes to the "operation_manual_duration" field.
func (m *StatsDailyCarMutation) ResetOperationManualDuration() {
	m.operation_manual_duration = nil
	m.addoperation_manual_duration = nil
}

// SetOperationAutoDuration sets the "operation_auto_duration" field.
func (m *StatsDailyCarMutation) SetOperationAutoDuration(f float32) {
	m.operation_auto_duration = &f
	m.addoperation_auto_duration = nil
}

// OperationAutoDuration returns the value of the "operation_auto_duration" field in the mutation.
func (m *StatsDailyCarMutation) OperationAutoDuration() (r float32, exists bool) {
	v := m.operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoDuration returns the old "operation_auto_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoDuration: %w", err)
	}
	return oldValue.OperationAutoDuration, nil
}

// AddOperationAutoDuration adds f to the "operation_auto_duration" field.
func (m *StatsDailyCarMutation) AddOperationAutoDuration(f float32) {
	if m.addoperation_auto_duration != nil {
		*m.addoperation_auto_duration += f
	} else {
		m.addoperation_auto_duration = &f
	}
}

// AddedOperationAutoDuration returns the value that was added to the "operation_auto_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationAutoDuration() (r float32, exists bool) {
	v := m.addoperation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoDuration resets all changes to the "operation_auto_duration" field.
func (m *StatsDailyCarMutation) ResetOperationAutoDuration() {
	m.operation_auto_duration = nil
	m.addoperation_auto_duration = nil
}

// SetOperationFaultDuration sets the "operation_fault_duration" field.
func (m *StatsDailyCarMutation) SetOperationFaultDuration(f float32) {
	m.operation_fault_duration = &f
	m.addoperation_fault_duration = nil
}

// OperationFaultDuration returns the value of the "operation_fault_duration" field in the mutation.
func (m *StatsDailyCarMutation) OperationFaultDuration() (r float32, exists bool) {
	v := m.operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultDuration returns the old "operation_fault_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultDuration: %w", err)
	}
	return oldValue.OperationFaultDuration, nil
}

// AddOperationFaultDuration adds f to the "operation_fault_duration" field.
func (m *StatsDailyCarMutation) AddOperationFaultDuration(f float32) {
	if m.addoperation_fault_duration != nil {
		*m.addoperation_fault_duration += f
	} else {
		m.addoperation_fault_duration = &f
	}
}

// AddedOperationFaultDuration returns the value that was added to the "operation_fault_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationFaultDuration() (r float32, exists bool) {
	v := m.addoperation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultDuration resets all changes to the "operation_fault_duration" field.
func (m *StatsDailyCarMutation) ResetOperationFaultDuration() {
	m.operation_fault_duration = nil
	m.addoperation_fault_duration = nil
}

// SetOperationLockTimes sets the "operation_lock_times" field.
func (m *StatsDailyCarMutation) SetOperationLockTimes(u uint32) {
	m.operation_lock_times = &u
	m.addoperation_lock_times = nil
}

// OperationLockTimes returns the value of the "operation_lock_times" field in the mutation.
func (m *StatsDailyCarMutation) OperationLockTimes() (r uint32, exists bool) {
	v := m.operation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockTimes returns the old "operation_lock_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockTimes: %w", err)
	}
	return oldValue.OperationLockTimes, nil
}

// AddOperationLockTimes adds u to the "operation_lock_times" field.
func (m *StatsDailyCarMutation) AddOperationLockTimes(u int32) {
	if m.addoperation_lock_times != nil {
		*m.addoperation_lock_times += u
	} else {
		m.addoperation_lock_times = &u
	}
}

// AddedOperationLockTimes returns the value that was added to the "operation_lock_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationLockTimes() (r int32, exists bool) {
	v := m.addoperation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockTimes resets all changes to the "operation_lock_times" field.
func (m *StatsDailyCarMutation) ResetOperationLockTimes() {
	m.operation_lock_times = nil
	m.addoperation_lock_times = nil
}

// SetOperationManualTimes sets the "operation_manual_times" field.
func (m *StatsDailyCarMutation) SetOperationManualTimes(u uint32) {
	m.operation_manual_times = &u
	m.addoperation_manual_times = nil
}

// OperationManualTimes returns the value of the "operation_manual_times" field in the mutation.
func (m *StatsDailyCarMutation) OperationManualTimes() (r uint32, exists bool) {
	v := m.operation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualTimes returns the old "operation_manual_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualTimes: %w", err)
	}
	return oldValue.OperationManualTimes, nil
}

// AddOperationManualTimes adds u to the "operation_manual_times" field.
func (m *StatsDailyCarMutation) AddOperationManualTimes(u int32) {
	if m.addoperation_manual_times != nil {
		*m.addoperation_manual_times += u
	} else {
		m.addoperation_manual_times = &u
	}
}

// AddedOperationManualTimes returns the value that was added to the "operation_manual_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationManualTimes() (r int32, exists bool) {
	v := m.addoperation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualTimes resets all changes to the "operation_manual_times" field.
func (m *StatsDailyCarMutation) ResetOperationManualTimes() {
	m.operation_manual_times = nil
	m.addoperation_manual_times = nil
}

// SetOperationAutoTimes sets the "operation_auto_times" field.
func (m *StatsDailyCarMutation) SetOperationAutoTimes(u uint32) {
	m.operation_auto_times = &u
	m.addoperation_auto_times = nil
}

// OperationAutoTimes returns the value of the "operation_auto_times" field in the mutation.
func (m *StatsDailyCarMutation) OperationAutoTimes() (r uint32, exists bool) {
	v := m.operation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoTimes returns the old "operation_auto_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoTimes: %w", err)
	}
	return oldValue.OperationAutoTimes, nil
}

// AddOperationAutoTimes adds u to the "operation_auto_times" field.
func (m *StatsDailyCarMutation) AddOperationAutoTimes(u int32) {
	if m.addoperation_auto_times != nil {
		*m.addoperation_auto_times += u
	} else {
		m.addoperation_auto_times = &u
	}
}

// AddedOperationAutoTimes returns the value that was added to the "operation_auto_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationAutoTimes() (r int32, exists bool) {
	v := m.addoperation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoTimes resets all changes to the "operation_auto_times" field.
func (m *StatsDailyCarMutation) ResetOperationAutoTimes() {
	m.operation_auto_times = nil
	m.addoperation_auto_times = nil
}

// SetOperationFaultTimes sets the "operation_fault_times" field.
func (m *StatsDailyCarMutation) SetOperationFaultTimes(u uint32) {
	m.operation_fault_times = &u
	m.addoperation_fault_times = nil
}

// OperationFaultTimes returns the value of the "operation_fault_times" field in the mutation.
func (m *StatsDailyCarMutation) OperationFaultTimes() (r uint32, exists bool) {
	v := m.operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultTimes returns the old "operation_fault_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultTimes: %w", err)
	}
	return oldValue.OperationFaultTimes, nil
}

// AddOperationFaultTimes adds u to the "operation_fault_times" field.
func (m *StatsDailyCarMutation) AddOperationFaultTimes(u int32) {
	if m.addoperation_fault_times != nil {
		*m.addoperation_fault_times += u
	} else {
		m.addoperation_fault_times = &u
	}
}

// AddedOperationFaultTimes returns the value that was added to the "operation_fault_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationFaultTimes() (r int32, exists bool) {
	v := m.addoperation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultTimes resets all changes to the "operation_fault_times" field.
func (m *StatsDailyCarMutation) ResetOperationFaultTimes() {
	m.operation_fault_times = nil
	m.addoperation_fault_times = nil
}

// SetOperationManualMileage sets the "operation_manual_mileage" field.
func (m *StatsDailyCarMutation) SetOperationManualMileage(f float32) {
	m.operation_manual_mileage = &f
	m.addoperation_manual_mileage = nil
}

// OperationManualMileage returns the value of the "operation_manual_mileage" field in the mutation.
func (m *StatsDailyCarMutation) OperationManualMileage() (r float32, exists bool) {
	v := m.operation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualMileage returns the old "operation_manual_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualMileage: %w", err)
	}
	return oldValue.OperationManualMileage, nil
}

// AddOperationManualMileage adds f to the "operation_manual_mileage" field.
func (m *StatsDailyCarMutation) AddOperationManualMileage(f float32) {
	if m.addoperation_manual_mileage != nil {
		*m.addoperation_manual_mileage += f
	} else {
		m.addoperation_manual_mileage = &f
	}
}

// AddedOperationManualMileage returns the value that was added to the "operation_manual_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationManualMileage() (r float32, exists bool) {
	v := m.addoperation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualMileage resets all changes to the "operation_manual_mileage" field.
func (m *StatsDailyCarMutation) ResetOperationManualMileage() {
	m.operation_manual_mileage = nil
	m.addoperation_manual_mileage = nil
}

// SetOperationAutoMileage sets the "operation_auto_mileage" field.
func (m *StatsDailyCarMutation) SetOperationAutoMileage(f float32) {
	m.operation_auto_mileage = &f
	m.addoperation_auto_mileage = nil
}

// OperationAutoMileage returns the value of the "operation_auto_mileage" field in the mutation.
func (m *StatsDailyCarMutation) OperationAutoMileage() (r float32, exists bool) {
	v := m.operation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoMileage returns the old "operation_auto_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldOperationAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoMileage: %w", err)
	}
	return oldValue.OperationAutoMileage, nil
}

// AddOperationAutoMileage adds f to the "operation_auto_mileage" field.
func (m *StatsDailyCarMutation) AddOperationAutoMileage(f float32) {
	if m.addoperation_auto_mileage != nil {
		*m.addoperation_auto_mileage += f
	} else {
		m.addoperation_auto_mileage = &f
	}
}

// AddedOperationAutoMileage returns the value that was added to the "operation_auto_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedOperationAutoMileage() (r float32, exists bool) {
	v := m.addoperation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoMileage resets all changes to the "operation_auto_mileage" field.
func (m *StatsDailyCarMutation) ResetOperationAutoMileage() {
	m.operation_auto_mileage = nil
	m.addoperation_auto_mileage = nil
}

// SetMaintainLockDuration sets the "maintain_lock_duration" field.
func (m *StatsDailyCarMutation) SetMaintainLockDuration(f float32) {
	m.maintain_lock_duration = &f
	m.addmaintain_lock_duration = nil
}

// MaintainLockDuration returns the value of the "maintain_lock_duration" field in the mutation.
func (m *StatsDailyCarMutation) MaintainLockDuration() (r float32, exists bool) {
	v := m.maintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockDuration returns the old "maintain_lock_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockDuration: %w", err)
	}
	return oldValue.MaintainLockDuration, nil
}

// AddMaintainLockDuration adds f to the "maintain_lock_duration" field.
func (m *StatsDailyCarMutation) AddMaintainLockDuration(f float32) {
	if m.addmaintain_lock_duration != nil {
		*m.addmaintain_lock_duration += f
	} else {
		m.addmaintain_lock_duration = &f
	}
}

// AddedMaintainLockDuration returns the value that was added to the "maintain_lock_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainLockDuration() (r float32, exists bool) {
	v := m.addmaintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockDuration resets all changes to the "maintain_lock_duration" field.
func (m *StatsDailyCarMutation) ResetMaintainLockDuration() {
	m.maintain_lock_duration = nil
	m.addmaintain_lock_duration = nil
}

// SetMaintainManualDuration sets the "maintain_manual_duration" field.
func (m *StatsDailyCarMutation) SetMaintainManualDuration(f float32) {
	m.maintain_manual_duration = &f
	m.addmaintain_manual_duration = nil
}

// MaintainManualDuration returns the value of the "maintain_manual_duration" field in the mutation.
func (m *StatsDailyCarMutation) MaintainManualDuration() (r float32, exists bool) {
	v := m.maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualDuration returns the old "maintain_manual_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualDuration: %w", err)
	}
	return oldValue.MaintainManualDuration, nil
}

// AddMaintainManualDuration adds f to the "maintain_manual_duration" field.
func (m *StatsDailyCarMutation) AddMaintainManualDuration(f float32) {
	if m.addmaintain_manual_duration != nil {
		*m.addmaintain_manual_duration += f
	} else {
		m.addmaintain_manual_duration = &f
	}
}

// AddedMaintainManualDuration returns the value that was added to the "maintain_manual_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainManualDuration() (r float32, exists bool) {
	v := m.addmaintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualDuration resets all changes to the "maintain_manual_duration" field.
func (m *StatsDailyCarMutation) ResetMaintainManualDuration() {
	m.maintain_manual_duration = nil
	m.addmaintain_manual_duration = nil
}

// SetMaintainAutoDuration sets the "maintain_auto_duration" field.
func (m *StatsDailyCarMutation) SetMaintainAutoDuration(f float32) {
	m.maintain_auto_duration = &f
	m.addmaintain_auto_duration = nil
}

// MaintainAutoDuration returns the value of the "maintain_auto_duration" field in the mutation.
func (m *StatsDailyCarMutation) MaintainAutoDuration() (r float32, exists bool) {
	v := m.maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoDuration returns the old "maintain_auto_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoDuration: %w", err)
	}
	return oldValue.MaintainAutoDuration, nil
}

// AddMaintainAutoDuration adds f to the "maintain_auto_duration" field.
func (m *StatsDailyCarMutation) AddMaintainAutoDuration(f float32) {
	if m.addmaintain_auto_duration != nil {
		*m.addmaintain_auto_duration += f
	} else {
		m.addmaintain_auto_duration = &f
	}
}

// AddedMaintainAutoDuration returns the value that was added to the "maintain_auto_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainAutoDuration() (r float32, exists bool) {
	v := m.addmaintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoDuration resets all changes to the "maintain_auto_duration" field.
func (m *StatsDailyCarMutation) ResetMaintainAutoDuration() {
	m.maintain_auto_duration = nil
	m.addmaintain_auto_duration = nil
}

// SetMaintainRemoteDuration sets the "maintain_remote_duration" field.
func (m *StatsDailyCarMutation) SetMaintainRemoteDuration(f float32) {
	m.maintain_remote_duration = &f
	m.addmaintain_remote_duration = nil
}

// MaintainRemoteDuration returns the value of the "maintain_remote_duration" field in the mutation.
func (m *StatsDailyCarMutation) MaintainRemoteDuration() (r float32, exists bool) {
	v := m.maintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteDuration returns the old "maintain_remote_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainRemoteDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteDuration: %w", err)
	}
	return oldValue.MaintainRemoteDuration, nil
}

// AddMaintainRemoteDuration adds f to the "maintain_remote_duration" field.
func (m *StatsDailyCarMutation) AddMaintainRemoteDuration(f float32) {
	if m.addmaintain_remote_duration != nil {
		*m.addmaintain_remote_duration += f
	} else {
		m.addmaintain_remote_duration = &f
	}
}

// AddedMaintainRemoteDuration returns the value that was added to the "maintain_remote_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainRemoteDuration() (r float32, exists bool) {
	v := m.addmaintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteDuration resets all changes to the "maintain_remote_duration" field.
func (m *StatsDailyCarMutation) ResetMaintainRemoteDuration() {
	m.maintain_remote_duration = nil
	m.addmaintain_remote_duration = nil
}

// SetMaintainFaultDuration sets the "maintain_fault_duration" field.
func (m *StatsDailyCarMutation) SetMaintainFaultDuration(f float32) {
	m.maintain_fault_duration = &f
	m.addmaintain_fault_duration = nil
}

// MaintainFaultDuration returns the value of the "maintain_fault_duration" field in the mutation.
func (m *StatsDailyCarMutation) MaintainFaultDuration() (r float32, exists bool) {
	v := m.maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultDuration returns the old "maintain_fault_duration" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultDuration: %w", err)
	}
	return oldValue.MaintainFaultDuration, nil
}

// AddMaintainFaultDuration adds f to the "maintain_fault_duration" field.
func (m *StatsDailyCarMutation) AddMaintainFaultDuration(f float32) {
	if m.addmaintain_fault_duration != nil {
		*m.addmaintain_fault_duration += f
	} else {
		m.addmaintain_fault_duration = &f
	}
}

// AddedMaintainFaultDuration returns the value that was added to the "maintain_fault_duration" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainFaultDuration() (r float32, exists bool) {
	v := m.addmaintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultDuration resets all changes to the "maintain_fault_duration" field.
func (m *StatsDailyCarMutation) ResetMaintainFaultDuration() {
	m.maintain_fault_duration = nil
	m.addmaintain_fault_duration = nil
}

// SetMaintainLockTimes sets the "maintain_lock_times" field.
func (m *StatsDailyCarMutation) SetMaintainLockTimes(u uint32) {
	m.maintain_lock_times = &u
	m.addmaintain_lock_times = nil
}

// MaintainLockTimes returns the value of the "maintain_lock_times" field in the mutation.
func (m *StatsDailyCarMutation) MaintainLockTimes() (r uint32, exists bool) {
	v := m.maintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockTimes returns the old "maintain_lock_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockTimes: %w", err)
	}
	return oldValue.MaintainLockTimes, nil
}

// AddMaintainLockTimes adds u to the "maintain_lock_times" field.
func (m *StatsDailyCarMutation) AddMaintainLockTimes(u int32) {
	if m.addmaintain_lock_times != nil {
		*m.addmaintain_lock_times += u
	} else {
		m.addmaintain_lock_times = &u
	}
}

// AddedMaintainLockTimes returns the value that was added to the "maintain_lock_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainLockTimes() (r int32, exists bool) {
	v := m.addmaintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockTimes resets all changes to the "maintain_lock_times" field.
func (m *StatsDailyCarMutation) ResetMaintainLockTimes() {
	m.maintain_lock_times = nil
	m.addmaintain_lock_times = nil
}

// SetMaintainManualTimes sets the "maintain_manual_times" field.
func (m *StatsDailyCarMutation) SetMaintainManualTimes(u uint32) {
	m.maintain_manual_times = &u
	m.addmaintain_manual_times = nil
}

// MaintainManualTimes returns the value of the "maintain_manual_times" field in the mutation.
func (m *StatsDailyCarMutation) MaintainManualTimes() (r uint32, exists bool) {
	v := m.maintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualTimes returns the old "maintain_manual_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualTimes: %w", err)
	}
	return oldValue.MaintainManualTimes, nil
}

// AddMaintainManualTimes adds u to the "maintain_manual_times" field.
func (m *StatsDailyCarMutation) AddMaintainManualTimes(u int32) {
	if m.addmaintain_manual_times != nil {
		*m.addmaintain_manual_times += u
	} else {
		m.addmaintain_manual_times = &u
	}
}

// AddedMaintainManualTimes returns the value that was added to the "maintain_manual_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainManualTimes() (r int32, exists bool) {
	v := m.addmaintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualTimes resets all changes to the "maintain_manual_times" field.
func (m *StatsDailyCarMutation) ResetMaintainManualTimes() {
	m.maintain_manual_times = nil
	m.addmaintain_manual_times = nil
}

// SetMaintainAutoTimes sets the "maintain_auto_times" field.
func (m *StatsDailyCarMutation) SetMaintainAutoTimes(u uint32) {
	m.maintain_auto_times = &u
	m.addmaintain_auto_times = nil
}

// MaintainAutoTimes returns the value of the "maintain_auto_times" field in the mutation.
func (m *StatsDailyCarMutation) MaintainAutoTimes() (r uint32, exists bool) {
	v := m.maintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoTimes returns the old "maintain_auto_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoTimes: %w", err)
	}
	return oldValue.MaintainAutoTimes, nil
}

// AddMaintainAutoTimes adds u to the "maintain_auto_times" field.
func (m *StatsDailyCarMutation) AddMaintainAutoTimes(u int32) {
	if m.addmaintain_auto_times != nil {
		*m.addmaintain_auto_times += u
	} else {
		m.addmaintain_auto_times = &u
	}
}

// AddedMaintainAutoTimes returns the value that was added to the "maintain_auto_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainAutoTimes() (r int32, exists bool) {
	v := m.addmaintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoTimes resets all changes to the "maintain_auto_times" field.
func (m *StatsDailyCarMutation) ResetMaintainAutoTimes() {
	m.maintain_auto_times = nil
	m.addmaintain_auto_times = nil
}

// SetMaintainRemoteTimes sets the "maintain_remote_times" field.
func (m *StatsDailyCarMutation) SetMaintainRemoteTimes(u uint32) {
	m.maintain_remote_times = &u
	m.addmaintain_remote_times = nil
}

// MaintainRemoteTimes returns the value of the "maintain_remote_times" field in the mutation.
func (m *StatsDailyCarMutation) MaintainRemoteTimes() (r uint32, exists bool) {
	v := m.maintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteTimes returns the old "maintain_remote_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainRemoteTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteTimes: %w", err)
	}
	return oldValue.MaintainRemoteTimes, nil
}

// AddMaintainRemoteTimes adds u to the "maintain_remote_times" field.
func (m *StatsDailyCarMutation) AddMaintainRemoteTimes(u int32) {
	if m.addmaintain_remote_times != nil {
		*m.addmaintain_remote_times += u
	} else {
		m.addmaintain_remote_times = &u
	}
}

// AddedMaintainRemoteTimes returns the value that was added to the "maintain_remote_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainRemoteTimes() (r int32, exists bool) {
	v := m.addmaintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteTimes resets all changes to the "maintain_remote_times" field.
func (m *StatsDailyCarMutation) ResetMaintainRemoteTimes() {
	m.maintain_remote_times = nil
	m.addmaintain_remote_times = nil
}

// SetMaintainFaultTimes sets the "maintain_fault_times" field.
func (m *StatsDailyCarMutation) SetMaintainFaultTimes(u uint32) {
	m.maintain_fault_times = &u
	m.addmaintain_fault_times = nil
}

// MaintainFaultTimes returns the value of the "maintain_fault_times" field in the mutation.
func (m *StatsDailyCarMutation) MaintainFaultTimes() (r uint32, exists bool) {
	v := m.maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultTimes returns the old "maintain_fault_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultTimes: %w", err)
	}
	return oldValue.MaintainFaultTimes, nil
}

// AddMaintainFaultTimes adds u to the "maintain_fault_times" field.
func (m *StatsDailyCarMutation) AddMaintainFaultTimes(u int32) {
	if m.addmaintain_fault_times != nil {
		*m.addmaintain_fault_times += u
	} else {
		m.addmaintain_fault_times = &u
	}
}

// AddedMaintainFaultTimes returns the value that was added to the "maintain_fault_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainFaultTimes() (r int32, exists bool) {
	v := m.addmaintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultTimes resets all changes to the "maintain_fault_times" field.
func (m *StatsDailyCarMutation) ResetMaintainFaultTimes() {
	m.maintain_fault_times = nil
	m.addmaintain_fault_times = nil
}

// SetMaintainManualMileage sets the "maintain_manual_mileage" field.
func (m *StatsDailyCarMutation) SetMaintainManualMileage(f float32) {
	m.maintain_manual_mileage = &f
	m.addmaintain_manual_mileage = nil
}

// MaintainManualMileage returns the value of the "maintain_manual_mileage" field in the mutation.
func (m *StatsDailyCarMutation) MaintainManualMileage() (r float32, exists bool) {
	v := m.maintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualMileage returns the old "maintain_manual_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualMileage: %w", err)
	}
	return oldValue.MaintainManualMileage, nil
}

// AddMaintainManualMileage adds f to the "maintain_manual_mileage" field.
func (m *StatsDailyCarMutation) AddMaintainManualMileage(f float32) {
	if m.addmaintain_manual_mileage != nil {
		*m.addmaintain_manual_mileage += f
	} else {
		m.addmaintain_manual_mileage = &f
	}
}

// AddedMaintainManualMileage returns the value that was added to the "maintain_manual_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainManualMileage() (r float32, exists bool) {
	v := m.addmaintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualMileage resets all changes to the "maintain_manual_mileage" field.
func (m *StatsDailyCarMutation) ResetMaintainManualMileage() {
	m.maintain_manual_mileage = nil
	m.addmaintain_manual_mileage = nil
}

// SetMaintainAutoMileage sets the "maintain_auto_mileage" field.
func (m *StatsDailyCarMutation) SetMaintainAutoMileage(f float32) {
	m.maintain_auto_mileage = &f
	m.addmaintain_auto_mileage = nil
}

// MaintainAutoMileage returns the value of the "maintain_auto_mileage" field in the mutation.
func (m *StatsDailyCarMutation) MaintainAutoMileage() (r float32, exists bool) {
	v := m.maintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoMileage returns the old "maintain_auto_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoMileage: %w", err)
	}
	return oldValue.MaintainAutoMileage, nil
}

// AddMaintainAutoMileage adds f to the "maintain_auto_mileage" field.
func (m *StatsDailyCarMutation) AddMaintainAutoMileage(f float32) {
	if m.addmaintain_auto_mileage != nil {
		*m.addmaintain_auto_mileage += f
	} else {
		m.addmaintain_auto_mileage = &f
	}
}

// AddedMaintainAutoMileage returns the value that was added to the "maintain_auto_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainAutoMileage() (r float32, exists bool) {
	v := m.addmaintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoMileage resets all changes to the "maintain_auto_mileage" field.
func (m *StatsDailyCarMutation) ResetMaintainAutoMileage() {
	m.maintain_auto_mileage = nil
	m.addmaintain_auto_mileage = nil
}

// SetMaintainRemoteMileage sets the "maintain_remote_mileage" field.
func (m *StatsDailyCarMutation) SetMaintainRemoteMileage(f float32) {
	m.maintain_remote_mileage = &f
	m.addmaintain_remote_mileage = nil
}

// MaintainRemoteMileage returns the value of the "maintain_remote_mileage" field in the mutation.
func (m *StatsDailyCarMutation) MaintainRemoteMileage() (r float32, exists bool) {
	v := m.maintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteMileage returns the old "maintain_remote_mileage" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldMaintainRemoteMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteMileage: %w", err)
	}
	return oldValue.MaintainRemoteMileage, nil
}

// AddMaintainRemoteMileage adds f to the "maintain_remote_mileage" field.
func (m *StatsDailyCarMutation) AddMaintainRemoteMileage(f float32) {
	if m.addmaintain_remote_mileage != nil {
		*m.addmaintain_remote_mileage += f
	} else {
		m.addmaintain_remote_mileage = &f
	}
}

// AddedMaintainRemoteMileage returns the value that was added to the "maintain_remote_mileage" field in this mutation.
func (m *StatsDailyCarMutation) AddedMaintainRemoteMileage() (r float32, exists bool) {
	v := m.addmaintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteMileage resets all changes to the "maintain_remote_mileage" field.
func (m *StatsDailyCarMutation) ResetMaintainRemoteMileage() {
	m.maintain_remote_mileage = nil
	m.addmaintain_remote_mileage = nil
}

// SetAlarmTimes sets the "alarm_times" field.
func (m *StatsDailyCarMutation) SetAlarmTimes(u uint32) {
	m.alarm_times = &u
	m.addalarm_times = nil
}

// AlarmTimes returns the value of the "alarm_times" field in the mutation.
func (m *StatsDailyCarMutation) AlarmTimes() (r uint32, exists bool) {
	v := m.alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmTimes returns the old "alarm_times" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldAlarmTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmTimes: %w", err)
	}
	return oldValue.AlarmTimes, nil
}

// AddAlarmTimes adds u to the "alarm_times" field.
func (m *StatsDailyCarMutation) AddAlarmTimes(u int32) {
	if m.addalarm_times != nil {
		*m.addalarm_times += u
	} else {
		m.addalarm_times = &u
	}
}

// AddedAlarmTimes returns the value that was added to the "alarm_times" field in this mutation.
func (m *StatsDailyCarMutation) AddedAlarmTimes() (r int32, exists bool) {
	v := m.addalarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlarmTimes resets all changes to the "alarm_times" field.
func (m *StatsDailyCarMutation) ResetAlarmTimes() {
	m.alarm_times = nil
	m.addalarm_times = nil
}

// SetStatsTime sets the "stats_time" field.
func (m *StatsDailyCarMutation) SetStatsTime(t time.Time) {
	m.stats_time = &t
}

// StatsTime returns the value of the "stats_time" field in the mutation.
func (m *StatsDailyCarMutation) StatsTime() (r time.Time, exists bool) {
	v := m.stats_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTime returns the old "stats_time" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldStatsTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTime: %w", err)
	}
	return oldValue.StatsTime, nil
}

// ResetStatsTime resets all changes to the "stats_time" field.
func (m *StatsDailyCarMutation) ResetStatsTime() {
	m.stats_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *StatsDailyCarMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatsDailyCarMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatsDailyCar entity.
// If the StatsDailyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyCarMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatsDailyCarMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the StatsDailyCarMutation builder.
func (m *StatsDailyCarMutation) Where(ps ...predicate.StatsDailyCar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatsDailyCarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatsDailyCarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatsDailyCar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatsDailyCarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatsDailyCarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatsDailyCar).
func (m *StatsDailyCarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatsDailyCarMutation) Fields() []string {
	fields := make([]string, 0, 41)
	if m.scenic_area_id != nil {
		fields = append(fields, statsdailycar.FieldScenicAreaID)
	}
	if m.car_id != nil {
		fields = append(fields, statsdailycar.FieldCarID)
	}
	if m.y != nil {
		fields = append(fields, statsdailycar.FieldY)
	}
	if m.m != nil {
		fields = append(fields, statsdailycar.FieldM)
	}
	if m.d != nil {
		fields = append(fields, statsdailycar.FieldD)
	}
	if m.week != nil {
		fields = append(fields, statsdailycar.FieldWeek)
	}
	if m.weekday != nil {
		fields = append(fields, statsdailycar.FieldWeekday)
	}
	if m.period != nil {
		fields = append(fields, statsdailycar.FieldPeriod)
	}
	if m.order_count_create != nil {
		fields = append(fields, statsdailycar.FieldOrderCountCreate)
	}
	if m.order_count_finish != nil {
		fields = append(fields, statsdailycar.FieldOrderCountFinish)
	}
	if m.order_count_cancel != nil {
		fields = append(fields, statsdailycar.FieldOrderCountCancel)
	}
	if m.order_amount != nil {
		fields = append(fields, statsdailycar.FieldOrderAmount)
	}
	if m.order_duration != nil {
		fields = append(fields, statsdailycar.FieldOrderDuration)
	}
	if m.order_mileage != nil {
		fields = append(fields, statsdailycar.FieldOrderMileage)
	}
	if m.order_score != nil {
		fields = append(fields, statsdailycar.FieldOrderScore)
	}
	if m.operation_lock_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationLockDuration)
	}
	if m.operation_manual_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationManualDuration)
	}
	if m.operation_auto_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoDuration)
	}
	if m.operation_fault_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationFaultDuration)
	}
	if m.operation_lock_times != nil {
		fields = append(fields, statsdailycar.FieldOperationLockTimes)
	}
	if m.operation_manual_times != nil {
		fields = append(fields, statsdailycar.FieldOperationManualTimes)
	}
	if m.operation_auto_times != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoTimes)
	}
	if m.operation_fault_times != nil {
		fields = append(fields, statsdailycar.FieldOperationFaultTimes)
	}
	if m.operation_manual_mileage != nil {
		fields = append(fields, statsdailycar.FieldOperationManualMileage)
	}
	if m.operation_auto_mileage != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoMileage)
	}
	if m.maintain_lock_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainLockDuration)
	}
	if m.maintain_manual_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualDuration)
	}
	if m.maintain_auto_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoDuration)
	}
	if m.maintain_remote_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteDuration)
	}
	if m.maintain_fault_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainFaultDuration)
	}
	if m.maintain_lock_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainLockTimes)
	}
	if m.maintain_manual_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualTimes)
	}
	if m.maintain_auto_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoTimes)
	}
	if m.maintain_remote_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteTimes)
	}
	if m.maintain_fault_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainFaultTimes)
	}
	if m.maintain_manual_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualMileage)
	}
	if m.maintain_auto_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoMileage)
	}
	if m.maintain_remote_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteMileage)
	}
	if m.alarm_times != nil {
		fields = append(fields, statsdailycar.FieldAlarmTimes)
	}
	if m.stats_time != nil {
		fields = append(fields, statsdailycar.FieldStatsTime)
	}
	if m.create_time != nil {
		fields = append(fields, statsdailycar.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatsDailyCarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		return m.ScenicAreaID()
	case statsdailycar.FieldCarID:
		return m.CarID()
	case statsdailycar.FieldY:
		return m.Y()
	case statsdailycar.FieldM:
		return m.M()
	case statsdailycar.FieldD:
		return m.D()
	case statsdailycar.FieldWeek:
		return m.Week()
	case statsdailycar.FieldWeekday:
		return m.Weekday()
	case statsdailycar.FieldPeriod:
		return m.Period()
	case statsdailycar.FieldOrderCountCreate:
		return m.OrderCountCreate()
	case statsdailycar.FieldOrderCountFinish:
		return m.OrderCountFinish()
	case statsdailycar.FieldOrderCountCancel:
		return m.OrderCountCancel()
	case statsdailycar.FieldOrderAmount:
		return m.OrderAmount()
	case statsdailycar.FieldOrderDuration:
		return m.OrderDuration()
	case statsdailycar.FieldOrderMileage:
		return m.OrderMileage()
	case statsdailycar.FieldOrderScore:
		return m.OrderScore()
	case statsdailycar.FieldOperationLockDuration:
		return m.OperationLockDuration()
	case statsdailycar.FieldOperationManualDuration:
		return m.OperationManualDuration()
	case statsdailycar.FieldOperationAutoDuration:
		return m.OperationAutoDuration()
	case statsdailycar.FieldOperationFaultDuration:
		return m.OperationFaultDuration()
	case statsdailycar.FieldOperationLockTimes:
		return m.OperationLockTimes()
	case statsdailycar.FieldOperationManualTimes:
		return m.OperationManualTimes()
	case statsdailycar.FieldOperationAutoTimes:
		return m.OperationAutoTimes()
	case statsdailycar.FieldOperationFaultTimes:
		return m.OperationFaultTimes()
	case statsdailycar.FieldOperationManualMileage:
		return m.OperationManualMileage()
	case statsdailycar.FieldOperationAutoMileage:
		return m.OperationAutoMileage()
	case statsdailycar.FieldMaintainLockDuration:
		return m.MaintainLockDuration()
	case statsdailycar.FieldMaintainManualDuration:
		return m.MaintainManualDuration()
	case statsdailycar.FieldMaintainAutoDuration:
		return m.MaintainAutoDuration()
	case statsdailycar.FieldMaintainRemoteDuration:
		return m.MaintainRemoteDuration()
	case statsdailycar.FieldMaintainFaultDuration:
		return m.MaintainFaultDuration()
	case statsdailycar.FieldMaintainLockTimes:
		return m.MaintainLockTimes()
	case statsdailycar.FieldMaintainManualTimes:
		return m.MaintainManualTimes()
	case statsdailycar.FieldMaintainAutoTimes:
		return m.MaintainAutoTimes()
	case statsdailycar.FieldMaintainRemoteTimes:
		return m.MaintainRemoteTimes()
	case statsdailycar.FieldMaintainFaultTimes:
		return m.MaintainFaultTimes()
	case statsdailycar.FieldMaintainManualMileage:
		return m.MaintainManualMileage()
	case statsdailycar.FieldMaintainAutoMileage:
		return m.MaintainAutoMileage()
	case statsdailycar.FieldMaintainRemoteMileage:
		return m.MaintainRemoteMileage()
	case statsdailycar.FieldAlarmTimes:
		return m.AlarmTimes()
	case statsdailycar.FieldStatsTime:
		return m.StatsTime()
	case statsdailycar.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatsDailyCarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case statsdailycar.FieldCarID:
		return m.OldCarID(ctx)
	case statsdailycar.FieldY:
		return m.OldY(ctx)
	case statsdailycar.FieldM:
		return m.OldM(ctx)
	case statsdailycar.FieldD:
		return m.OldD(ctx)
	case statsdailycar.FieldWeek:
		return m.OldWeek(ctx)
	case statsdailycar.FieldWeekday:
		return m.OldWeekday(ctx)
	case statsdailycar.FieldPeriod:
		return m.OldPeriod(ctx)
	case statsdailycar.FieldOrderCountCreate:
		return m.OldOrderCountCreate(ctx)
	case statsdailycar.FieldOrderCountFinish:
		return m.OldOrderCountFinish(ctx)
	case statsdailycar.FieldOrderCountCancel:
		return m.OldOrderCountCancel(ctx)
	case statsdailycar.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case statsdailycar.FieldOrderDuration:
		return m.OldOrderDuration(ctx)
	case statsdailycar.FieldOrderMileage:
		return m.OldOrderMileage(ctx)
	case statsdailycar.FieldOrderScore:
		return m.OldOrderScore(ctx)
	case statsdailycar.FieldOperationLockDuration:
		return m.OldOperationLockDuration(ctx)
	case statsdailycar.FieldOperationManualDuration:
		return m.OldOperationManualDuration(ctx)
	case statsdailycar.FieldOperationAutoDuration:
		return m.OldOperationAutoDuration(ctx)
	case statsdailycar.FieldOperationFaultDuration:
		return m.OldOperationFaultDuration(ctx)
	case statsdailycar.FieldOperationLockTimes:
		return m.OldOperationLockTimes(ctx)
	case statsdailycar.FieldOperationManualTimes:
		return m.OldOperationManualTimes(ctx)
	case statsdailycar.FieldOperationAutoTimes:
		return m.OldOperationAutoTimes(ctx)
	case statsdailycar.FieldOperationFaultTimes:
		return m.OldOperationFaultTimes(ctx)
	case statsdailycar.FieldOperationManualMileage:
		return m.OldOperationManualMileage(ctx)
	case statsdailycar.FieldOperationAutoMileage:
		return m.OldOperationAutoMileage(ctx)
	case statsdailycar.FieldMaintainLockDuration:
		return m.OldMaintainLockDuration(ctx)
	case statsdailycar.FieldMaintainManualDuration:
		return m.OldMaintainManualDuration(ctx)
	case statsdailycar.FieldMaintainAutoDuration:
		return m.OldMaintainAutoDuration(ctx)
	case statsdailycar.FieldMaintainRemoteDuration:
		return m.OldMaintainRemoteDuration(ctx)
	case statsdailycar.FieldMaintainFaultDuration:
		return m.OldMaintainFaultDuration(ctx)
	case statsdailycar.FieldMaintainLockTimes:
		return m.OldMaintainLockTimes(ctx)
	case statsdailycar.FieldMaintainManualTimes:
		return m.OldMaintainManualTimes(ctx)
	case statsdailycar.FieldMaintainAutoTimes:
		return m.OldMaintainAutoTimes(ctx)
	case statsdailycar.FieldMaintainRemoteTimes:
		return m.OldMaintainRemoteTimes(ctx)
	case statsdailycar.FieldMaintainFaultTimes:
		return m.OldMaintainFaultTimes(ctx)
	case statsdailycar.FieldMaintainManualMileage:
		return m.OldMaintainManualMileage(ctx)
	case statsdailycar.FieldMaintainAutoMileage:
		return m.OldMaintainAutoMileage(ctx)
	case statsdailycar.FieldMaintainRemoteMileage:
		return m.OldMaintainRemoteMileage(ctx)
	case statsdailycar.FieldAlarmTimes:
		return m.OldAlarmTimes(ctx)
	case statsdailycar.FieldStatsTime:
		return m.OldStatsTime(ctx)
	case statsdailycar.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown StatsDailyCar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyCarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case statsdailycar.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case statsdailycar.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case statsdailycar.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetM(v)
		return nil
	case statsdailycar.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case statsdailycar.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeek(v)
		return nil
	case statsdailycar.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	case statsdailycar.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case statsdailycar.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCreate(v)
		return nil
	case statsdailycar.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountFinish(v)
		return nil
	case statsdailycar.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCancel(v)
		return nil
	case statsdailycar.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case statsdailycar.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDuration(v)
		return nil
	case statsdailycar.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMileage(v)
		return nil
	case statsdailycar.FieldOrderScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderScore(v)
		return nil
	case statsdailycar.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockDuration(v)
		return nil
	case statsdailycar.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualDuration(v)
		return nil
	case statsdailycar.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoDuration(v)
		return nil
	case statsdailycar.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultDuration(v)
		return nil
	case statsdailycar.FieldOperationLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockTimes(v)
		return nil
	case statsdailycar.FieldOperationManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualTimes(v)
		return nil
	case statsdailycar.FieldOperationAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoTimes(v)
		return nil
	case statsdailycar.FieldOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultTimes(v)
		return nil
	case statsdailycar.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualMileage(v)
		return nil
	case statsdailycar.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoMileage(v)
		return nil
	case statsdailycar.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockDuration(v)
		return nil
	case statsdailycar.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualDuration(v)
		return nil
	case statsdailycar.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoDuration(v)
		return nil
	case statsdailycar.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteDuration(v)
		return nil
	case statsdailycar.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultDuration(v)
		return nil
	case statsdailycar.FieldMaintainLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockTimes(v)
		return nil
	case statsdailycar.FieldMaintainManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualTimes(v)
		return nil
	case statsdailycar.FieldMaintainAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoTimes(v)
		return nil
	case statsdailycar.FieldMaintainRemoteTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteTimes(v)
		return nil
	case statsdailycar.FieldMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultTimes(v)
		return nil
	case statsdailycar.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualMileage(v)
		return nil
	case statsdailycar.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoMileage(v)
		return nil
	case statsdailycar.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteMileage(v)
		return nil
	case statsdailycar.FieldAlarmTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmTimes(v)
		return nil
	case statsdailycar.FieldStatsTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTime(v)
		return nil
	case statsdailycar.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDailyCar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatsDailyCarMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, statsdailycar.FieldScenicAreaID)
	}
	if m.addcar_id != nil {
		fields = append(fields, statsdailycar.FieldCarID)
	}
	if m.addy != nil {
		fields = append(fields, statsdailycar.FieldY)
	}
	if m.addm != nil {
		fields = append(fields, statsdailycar.FieldM)
	}
	if m.addd != nil {
		fields = append(fields, statsdailycar.FieldD)
	}
	if m.addweek != nil {
		fields = append(fields, statsdailycar.FieldWeek)
	}
	if m.addweekday != nil {
		fields = append(fields, statsdailycar.FieldWeekday)
	}
	if m.addperiod != nil {
		fields = append(fields, statsdailycar.FieldPeriod)
	}
	if m.addorder_count_create != nil {
		fields = append(fields, statsdailycar.FieldOrderCountCreate)
	}
	if m.addorder_count_finish != nil {
		fields = append(fields, statsdailycar.FieldOrderCountFinish)
	}
	if m.addorder_count_cancel != nil {
		fields = append(fields, statsdailycar.FieldOrderCountCancel)
	}
	if m.addorder_amount != nil {
		fields = append(fields, statsdailycar.FieldOrderAmount)
	}
	if m.addorder_duration != nil {
		fields = append(fields, statsdailycar.FieldOrderDuration)
	}
	if m.addorder_mileage != nil {
		fields = append(fields, statsdailycar.FieldOrderMileage)
	}
	if m.addorder_score != nil {
		fields = append(fields, statsdailycar.FieldOrderScore)
	}
	if m.addoperation_lock_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationLockDuration)
	}
	if m.addoperation_manual_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationManualDuration)
	}
	if m.addoperation_auto_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoDuration)
	}
	if m.addoperation_fault_duration != nil {
		fields = append(fields, statsdailycar.FieldOperationFaultDuration)
	}
	if m.addoperation_lock_times != nil {
		fields = append(fields, statsdailycar.FieldOperationLockTimes)
	}
	if m.addoperation_manual_times != nil {
		fields = append(fields, statsdailycar.FieldOperationManualTimes)
	}
	if m.addoperation_auto_times != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoTimes)
	}
	if m.addoperation_fault_times != nil {
		fields = append(fields, statsdailycar.FieldOperationFaultTimes)
	}
	if m.addoperation_manual_mileage != nil {
		fields = append(fields, statsdailycar.FieldOperationManualMileage)
	}
	if m.addoperation_auto_mileage != nil {
		fields = append(fields, statsdailycar.FieldOperationAutoMileage)
	}
	if m.addmaintain_lock_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainLockDuration)
	}
	if m.addmaintain_manual_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualDuration)
	}
	if m.addmaintain_auto_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoDuration)
	}
	if m.addmaintain_remote_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteDuration)
	}
	if m.addmaintain_fault_duration != nil {
		fields = append(fields, statsdailycar.FieldMaintainFaultDuration)
	}
	if m.addmaintain_lock_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainLockTimes)
	}
	if m.addmaintain_manual_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualTimes)
	}
	if m.addmaintain_auto_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoTimes)
	}
	if m.addmaintain_remote_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteTimes)
	}
	if m.addmaintain_fault_times != nil {
		fields = append(fields, statsdailycar.FieldMaintainFaultTimes)
	}
	if m.addmaintain_manual_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainManualMileage)
	}
	if m.addmaintain_auto_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainAutoMileage)
	}
	if m.addmaintain_remote_mileage != nil {
		fields = append(fields, statsdailycar.FieldMaintainRemoteMileage)
	}
	if m.addalarm_times != nil {
		fields = append(fields, statsdailycar.FieldAlarmTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatsDailyCarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case statsdailycar.FieldCarID:
		return m.AddedCarID()
	case statsdailycar.FieldY:
		return m.AddedY()
	case statsdailycar.FieldM:
		return m.AddedM()
	case statsdailycar.FieldD:
		return m.AddedD()
	case statsdailycar.FieldWeek:
		return m.AddedWeek()
	case statsdailycar.FieldWeekday:
		return m.AddedWeekday()
	case statsdailycar.FieldPeriod:
		return m.AddedPeriod()
	case statsdailycar.FieldOrderCountCreate:
		return m.AddedOrderCountCreate()
	case statsdailycar.FieldOrderCountFinish:
		return m.AddedOrderCountFinish()
	case statsdailycar.FieldOrderCountCancel:
		return m.AddedOrderCountCancel()
	case statsdailycar.FieldOrderAmount:
		return m.AddedOrderAmount()
	case statsdailycar.FieldOrderDuration:
		return m.AddedOrderDuration()
	case statsdailycar.FieldOrderMileage:
		return m.AddedOrderMileage()
	case statsdailycar.FieldOrderScore:
		return m.AddedOrderScore()
	case statsdailycar.FieldOperationLockDuration:
		return m.AddedOperationLockDuration()
	case statsdailycar.FieldOperationManualDuration:
		return m.AddedOperationManualDuration()
	case statsdailycar.FieldOperationAutoDuration:
		return m.AddedOperationAutoDuration()
	case statsdailycar.FieldOperationFaultDuration:
		return m.AddedOperationFaultDuration()
	case statsdailycar.FieldOperationLockTimes:
		return m.AddedOperationLockTimes()
	case statsdailycar.FieldOperationManualTimes:
		return m.AddedOperationManualTimes()
	case statsdailycar.FieldOperationAutoTimes:
		return m.AddedOperationAutoTimes()
	case statsdailycar.FieldOperationFaultTimes:
		return m.AddedOperationFaultTimes()
	case statsdailycar.FieldOperationManualMileage:
		return m.AddedOperationManualMileage()
	case statsdailycar.FieldOperationAutoMileage:
		return m.AddedOperationAutoMileage()
	case statsdailycar.FieldMaintainLockDuration:
		return m.AddedMaintainLockDuration()
	case statsdailycar.FieldMaintainManualDuration:
		return m.AddedMaintainManualDuration()
	case statsdailycar.FieldMaintainAutoDuration:
		return m.AddedMaintainAutoDuration()
	case statsdailycar.FieldMaintainRemoteDuration:
		return m.AddedMaintainRemoteDuration()
	case statsdailycar.FieldMaintainFaultDuration:
		return m.AddedMaintainFaultDuration()
	case statsdailycar.FieldMaintainLockTimes:
		return m.AddedMaintainLockTimes()
	case statsdailycar.FieldMaintainManualTimes:
		return m.AddedMaintainManualTimes()
	case statsdailycar.FieldMaintainAutoTimes:
		return m.AddedMaintainAutoTimes()
	case statsdailycar.FieldMaintainRemoteTimes:
		return m.AddedMaintainRemoteTimes()
	case statsdailycar.FieldMaintainFaultTimes:
		return m.AddedMaintainFaultTimes()
	case statsdailycar.FieldMaintainManualMileage:
		return m.AddedMaintainManualMileage()
	case statsdailycar.FieldMaintainAutoMileage:
		return m.AddedMaintainAutoMileage()
	case statsdailycar.FieldMaintainRemoteMileage:
		return m.AddedMaintainRemoteMileage()
	case statsdailycar.FieldAlarmTimes:
		return m.AddedAlarmTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyCarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case statsdailycar.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarID(v)
		return nil
	case statsdailycar.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case statsdailycar.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddM(v)
		return nil
	case statsdailycar.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddD(v)
		return nil
	case statsdailycar.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeek(v)
		return nil
	case statsdailycar.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekday(v)
		return nil
	case statsdailycar.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case statsdailycar.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCreate(v)
		return nil
	case statsdailycar.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountFinish(v)
		return nil
	case statsdailycar.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCancel(v)
		return nil
	case statsdailycar.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case statsdailycar.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDuration(v)
		return nil
	case statsdailycar.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderMileage(v)
		return nil
	case statsdailycar.FieldOrderScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderScore(v)
		return nil
	case statsdailycar.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockDuration(v)
		return nil
	case statsdailycar.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualDuration(v)
		return nil
	case statsdailycar.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoDuration(v)
		return nil
	case statsdailycar.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultDuration(v)
		return nil
	case statsdailycar.FieldOperationLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockTimes(v)
		return nil
	case statsdailycar.FieldOperationManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualTimes(v)
		return nil
	case statsdailycar.FieldOperationAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoTimes(v)
		return nil
	case statsdailycar.FieldOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultTimes(v)
		return nil
	case statsdailycar.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualMileage(v)
		return nil
	case statsdailycar.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoMileage(v)
		return nil
	case statsdailycar.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockDuration(v)
		return nil
	case statsdailycar.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualDuration(v)
		return nil
	case statsdailycar.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoDuration(v)
		return nil
	case statsdailycar.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteDuration(v)
		return nil
	case statsdailycar.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultDuration(v)
		return nil
	case statsdailycar.FieldMaintainLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockTimes(v)
		return nil
	case statsdailycar.FieldMaintainManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualTimes(v)
		return nil
	case statsdailycar.FieldMaintainAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoTimes(v)
		return nil
	case statsdailycar.FieldMaintainRemoteTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteTimes(v)
		return nil
	case statsdailycar.FieldMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultTimes(v)
		return nil
	case statsdailycar.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualMileage(v)
		return nil
	case statsdailycar.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoMileage(v)
		return nil
	case statsdailycar.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteMileage(v)
		return nil
	case statsdailycar.FieldAlarmTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlarmTimes(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDailyCar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatsDailyCarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatsDailyCarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatsDailyCarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatsDailyCar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatsDailyCarMutation) ResetField(name string) error {
	switch name {
	case statsdailycar.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case statsdailycar.FieldCarID:
		m.ResetCarID()
		return nil
	case statsdailycar.FieldY:
		m.ResetY()
		return nil
	case statsdailycar.FieldM:
		m.ResetM()
		return nil
	case statsdailycar.FieldD:
		m.ResetD()
		return nil
	case statsdailycar.FieldWeek:
		m.ResetWeek()
		return nil
	case statsdailycar.FieldWeekday:
		m.ResetWeekday()
		return nil
	case statsdailycar.FieldPeriod:
		m.ResetPeriod()
		return nil
	case statsdailycar.FieldOrderCountCreate:
		m.ResetOrderCountCreate()
		return nil
	case statsdailycar.FieldOrderCountFinish:
		m.ResetOrderCountFinish()
		return nil
	case statsdailycar.FieldOrderCountCancel:
		m.ResetOrderCountCancel()
		return nil
	case statsdailycar.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case statsdailycar.FieldOrderDuration:
		m.ResetOrderDuration()
		return nil
	case statsdailycar.FieldOrderMileage:
		m.ResetOrderMileage()
		return nil
	case statsdailycar.FieldOrderScore:
		m.ResetOrderScore()
		return nil
	case statsdailycar.FieldOperationLockDuration:
		m.ResetOperationLockDuration()
		return nil
	case statsdailycar.FieldOperationManualDuration:
		m.ResetOperationManualDuration()
		return nil
	case statsdailycar.FieldOperationAutoDuration:
		m.ResetOperationAutoDuration()
		return nil
	case statsdailycar.FieldOperationFaultDuration:
		m.ResetOperationFaultDuration()
		return nil
	case statsdailycar.FieldOperationLockTimes:
		m.ResetOperationLockTimes()
		return nil
	case statsdailycar.FieldOperationManualTimes:
		m.ResetOperationManualTimes()
		return nil
	case statsdailycar.FieldOperationAutoTimes:
		m.ResetOperationAutoTimes()
		return nil
	case statsdailycar.FieldOperationFaultTimes:
		m.ResetOperationFaultTimes()
		return nil
	case statsdailycar.FieldOperationManualMileage:
		m.ResetOperationManualMileage()
		return nil
	case statsdailycar.FieldOperationAutoMileage:
		m.ResetOperationAutoMileage()
		return nil
	case statsdailycar.FieldMaintainLockDuration:
		m.ResetMaintainLockDuration()
		return nil
	case statsdailycar.FieldMaintainManualDuration:
		m.ResetMaintainManualDuration()
		return nil
	case statsdailycar.FieldMaintainAutoDuration:
		m.ResetMaintainAutoDuration()
		return nil
	case statsdailycar.FieldMaintainRemoteDuration:
		m.ResetMaintainRemoteDuration()
		return nil
	case statsdailycar.FieldMaintainFaultDuration:
		m.ResetMaintainFaultDuration()
		return nil
	case statsdailycar.FieldMaintainLockTimes:
		m.ResetMaintainLockTimes()
		return nil
	case statsdailycar.FieldMaintainManualTimes:
		m.ResetMaintainManualTimes()
		return nil
	case statsdailycar.FieldMaintainAutoTimes:
		m.ResetMaintainAutoTimes()
		return nil
	case statsdailycar.FieldMaintainRemoteTimes:
		m.ResetMaintainRemoteTimes()
		return nil
	case statsdailycar.FieldMaintainFaultTimes:
		m.ResetMaintainFaultTimes()
		return nil
	case statsdailycar.FieldMaintainManualMileage:
		m.ResetMaintainManualMileage()
		return nil
	case statsdailycar.FieldMaintainAutoMileage:
		m.ResetMaintainAutoMileage()
		return nil
	case statsdailycar.FieldMaintainRemoteMileage:
		m.ResetMaintainRemoteMileage()
		return nil
	case statsdailycar.FieldAlarmTimes:
		m.ResetAlarmTimes()
		return nil
	case statsdailycar.FieldStatsTime:
		m.ResetStatsTime()
		return nil
	case statsdailycar.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown StatsDailyCar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatsDailyCarMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatsDailyCarMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatsDailyCarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatsDailyCarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatsDailyCarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatsDailyCarMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatsDailyCarMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StatsDailyCar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatsDailyCarMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StatsDailyCar edge %s", name)
}

// StatsDailyScenicAreaMutation represents an operation that mutates the StatsDailyScenicArea nodes in the graph.
type StatsDailyScenicAreaMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	scenic_area_id                   *int
	addscenic_area_id                *int
	y                                *int
	addy                             *int
	m                                *int
	addm                             *int
	d                                *int
	addd                             *int
	week                             *int
	addweek                          *int
	weekday                          *int
	addweekday                       *int
	period                           *int
	addperiod                        *int
	user_count_login                 *int
	adduser_count_login              *int
	user_count_register              *int
	adduser_count_register           *int
	user_count_order                 *int
	adduser_count_order              *int
	user_count_loginorder            *int
	adduser_count_loginorder         *int
	order_count_create               *int
	addorder_count_create            *int
	order_count_finish               *int
	addorder_count_finish            *int
	order_count_cancel               *int
	addorder_count_cancel            *int
	order_amount                     *int
	addorder_amount                  *int
	order_duration                   *int
	addorder_duration                *int
	order_mileage                    *int
	addorder_mileage                 *int
	car_count_deploy                 *int
	addcar_count_deploy              *int
	car_count_operation              *int
	addcar_count_operation           *int
	car_operation_manual_duration    *float32
	addcar_operation_manual_duration *float32
	car_operation_auto_duration      *float32
	addcar_operation_auto_duration   *float32
	car_operation_normal_duration    *float32
	addcar_operation_normal_duration *float32
	car_operation_fault_duration     *float32
	addcar_operation_fault_duration  *float32
	car_operation_mileage            *float32
	addcar_operation_mileage         *float32
	car_operation_fault_times        *uint32
	addcar_operation_fault_times     *int32
	car_maintain_manual_duration     *float32
	addcar_maintain_manual_duration  *float32
	car_maintain_auto_duration       *float32
	addcar_maintain_auto_duration    *float32
	car_maintain_normal_duration     *float32
	addcar_maintain_normal_duration  *float32
	car_maintain_fault_duration      *float32
	addcar_maintain_fault_duration   *float32
	car_maintain_mileage             *float32
	addcar_maintain_mileage          *float32
	car_maintain_fault_times         *uint32
	addcar_maintain_fault_times      *int32
	car_alarm_times                  *int
	addcar_alarm_times               *int
	stats_time                       *time.Time
	create_time                      *time.Time
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*StatsDailyScenicArea, error)
	predicates                       []predicate.StatsDailyScenicArea
}

var _ ent.Mutation = (*StatsDailyScenicAreaMutation)(nil)

// statsdailyscenicareaOption allows management of the mutation configuration using functional options.
type statsdailyscenicareaOption func(*StatsDailyScenicAreaMutation)

// newStatsDailyScenicAreaMutation creates new mutation for the StatsDailyScenicArea entity.
func newStatsDailyScenicAreaMutation(c config, op Op, opts ...statsdailyscenicareaOption) *StatsDailyScenicAreaMutation {
	m := &StatsDailyScenicAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeStatsDailyScenicArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatsDailyScenicAreaID sets the ID field of the mutation.
func withStatsDailyScenicAreaID(id int) statsdailyscenicareaOption {
	return func(m *StatsDailyScenicAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *StatsDailyScenicArea
		)
		m.oldValue = func(ctx context.Context) (*StatsDailyScenicArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatsDailyScenicArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatsDailyScenicArea sets the old StatsDailyScenicArea of the mutation.
func withStatsDailyScenicArea(node *StatsDailyScenicArea) statsdailyscenicareaOption {
	return func(m *StatsDailyScenicAreaMutation) {
		m.oldValue = func(context.Context) (*StatsDailyScenicArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatsDailyScenicAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatsDailyScenicAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatsDailyScenicArea entities.
func (m *StatsDailyScenicAreaMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatsDailyScenicAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatsDailyScenicAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatsDailyScenicArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *StatsDailyScenicAreaMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *StatsDailyScenicAreaMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *StatsDailyScenicAreaMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *StatsDailyScenicAreaMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetY sets the "y" field.
func (m *StatsDailyScenicAreaMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *StatsDailyScenicAreaMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *StatsDailyScenicAreaMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *StatsDailyScenicAreaMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetM sets the "m" field.
func (m *StatsDailyScenicAreaMutation) SetM(i int) {
	m.m = &i
	m.addm = nil
}

// M returns the value of the "m" field in the mutation.
func (m *StatsDailyScenicAreaMutation) M() (r int, exists bool) {
	v := m.m
	if v == nil {
		return
	}
	return *v, true
}

// OldM returns the old "m" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldM is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldM: %w", err)
	}
	return oldValue.M, nil
}

// AddM adds i to the "m" field.
func (m *StatsDailyScenicAreaMutation) AddM(i int) {
	if m.addm != nil {
		*m.addm += i
	} else {
		m.addm = &i
	}
}

// AddedM returns the value that was added to the "m" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedM() (r int, exists bool) {
	v := m.addm
	if v == nil {
		return
	}
	return *v, true
}

// ResetM resets all changes to the "m" field.
func (m *StatsDailyScenicAreaMutation) ResetM() {
	m.m = nil
	m.addm = nil
}

// SetD sets the "d" field.
func (m *StatsDailyScenicAreaMutation) SetD(i int) {
	m.d = &i
	m.addd = nil
}

// D returns the value of the "d" field in the mutation.
func (m *StatsDailyScenicAreaMutation) D() (r int, exists bool) {
	v := m.d
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "d" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// AddD adds i to the "d" field.
func (m *StatsDailyScenicAreaMutation) AddD(i int) {
	if m.addd != nil {
		*m.addd += i
	} else {
		m.addd = &i
	}
}

// AddedD returns the value that was added to the "d" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedD() (r int, exists bool) {
	v := m.addd
	if v == nil {
		return
	}
	return *v, true
}

// ResetD resets all changes to the "d" field.
func (m *StatsDailyScenicAreaMutation) ResetD() {
	m.d = nil
	m.addd = nil
}

// SetWeek sets the "week" field.
func (m *StatsDailyScenicAreaMutation) SetWeek(i int) {
	m.week = &i
	m.addweek = nil
}

// Week returns the value of the "week" field in the mutation.
func (m *StatsDailyScenicAreaMutation) Week() (r int, exists bool) {
	v := m.week
	if v == nil {
		return
	}
	return *v, true
}

// OldWeek returns the old "week" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldWeek(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeek: %w", err)
	}
	return oldValue.Week, nil
}

// AddWeek adds i to the "week" field.
func (m *StatsDailyScenicAreaMutation) AddWeek(i int) {
	if m.addweek != nil {
		*m.addweek += i
	} else {
		m.addweek = &i
	}
}

// AddedWeek returns the value that was added to the "week" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedWeek() (r int, exists bool) {
	v := m.addweek
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeek resets all changes to the "week" field.
func (m *StatsDailyScenicAreaMutation) ResetWeek() {
	m.week = nil
	m.addweek = nil
}

// SetWeekday sets the "weekday" field.
func (m *StatsDailyScenicAreaMutation) SetWeekday(i int) {
	m.weekday = &i
	m.addweekday = nil
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *StatsDailyScenicAreaMutation) Weekday() (r int, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldWeekday(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// AddWeekday adds i to the "weekday" field.
func (m *StatsDailyScenicAreaMutation) AddWeekday(i int) {
	if m.addweekday != nil {
		*m.addweekday += i
	} else {
		m.addweekday = &i
	}
}

// AddedWeekday returns the value that was added to the "weekday" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedWeekday() (r int, exists bool) {
	v := m.addweekday
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *StatsDailyScenicAreaMutation) ResetWeekday() {
	m.weekday = nil
	m.addweekday = nil
}

// SetPeriod sets the "period" field.
func (m *StatsDailyScenicAreaMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *StatsDailyScenicAreaMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *StatsDailyScenicAreaMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *StatsDailyScenicAreaMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetUserCountLogin sets the "user_count_login" field.
func (m *StatsDailyScenicAreaMutation) SetUserCountLogin(i int) {
	m.user_count_login = &i
	m.adduser_count_login = nil
}

// UserCountLogin returns the value of the "user_count_login" field in the mutation.
func (m *StatsDailyScenicAreaMutation) UserCountLogin() (r int, exists bool) {
	v := m.user_count_login
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountLogin returns the old "user_count_login" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldUserCountLogin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountLogin: %w", err)
	}
	return oldValue.UserCountLogin, nil
}

// AddUserCountLogin adds i to the "user_count_login" field.
func (m *StatsDailyScenicAreaMutation) AddUserCountLogin(i int) {
	if m.adduser_count_login != nil {
		*m.adduser_count_login += i
	} else {
		m.adduser_count_login = &i
	}
}

// AddedUserCountLogin returns the value that was added to the "user_count_login" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedUserCountLogin() (r int, exists bool) {
	v := m.adduser_count_login
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountLogin resets all changes to the "user_count_login" field.
func (m *StatsDailyScenicAreaMutation) ResetUserCountLogin() {
	m.user_count_login = nil
	m.adduser_count_login = nil
}

// SetUserCountRegister sets the "user_count_register" field.
func (m *StatsDailyScenicAreaMutation) SetUserCountRegister(i int) {
	m.user_count_register = &i
	m.adduser_count_register = nil
}

// UserCountRegister returns the value of the "user_count_register" field in the mutation.
func (m *StatsDailyScenicAreaMutation) UserCountRegister() (r int, exists bool) {
	v := m.user_count_register
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountRegister returns the old "user_count_register" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldUserCountRegister(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountRegister: %w", err)
	}
	return oldValue.UserCountRegister, nil
}

// AddUserCountRegister adds i to the "user_count_register" field.
func (m *StatsDailyScenicAreaMutation) AddUserCountRegister(i int) {
	if m.adduser_count_register != nil {
		*m.adduser_count_register += i
	} else {
		m.adduser_count_register = &i
	}
}

// AddedUserCountRegister returns the value that was added to the "user_count_register" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedUserCountRegister() (r int, exists bool) {
	v := m.adduser_count_register
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountRegister resets all changes to the "user_count_register" field.
func (m *StatsDailyScenicAreaMutation) ResetUserCountRegister() {
	m.user_count_register = nil
	m.adduser_count_register = nil
}

// SetUserCountOrder sets the "user_count_order" field.
func (m *StatsDailyScenicAreaMutation) SetUserCountOrder(i int) {
	m.user_count_order = &i
	m.adduser_count_order = nil
}

// UserCountOrder returns the value of the "user_count_order" field in the mutation.
func (m *StatsDailyScenicAreaMutation) UserCountOrder() (r int, exists bool) {
	v := m.user_count_order
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountOrder returns the old "user_count_order" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldUserCountOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountOrder: %w", err)
	}
	return oldValue.UserCountOrder, nil
}

// AddUserCountOrder adds i to the "user_count_order" field.
func (m *StatsDailyScenicAreaMutation) AddUserCountOrder(i int) {
	if m.adduser_count_order != nil {
		*m.adduser_count_order += i
	} else {
		m.adduser_count_order = &i
	}
}

// AddedUserCountOrder returns the value that was added to the "user_count_order" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedUserCountOrder() (r int, exists bool) {
	v := m.adduser_count_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountOrder resets all changes to the "user_count_order" field.
func (m *StatsDailyScenicAreaMutation) ResetUserCountOrder() {
	m.user_count_order = nil
	m.adduser_count_order = nil
}

// SetUserCountLoginorder sets the "user_count_loginorder" field.
func (m *StatsDailyScenicAreaMutation) SetUserCountLoginorder(i int) {
	m.user_count_loginorder = &i
	m.adduser_count_loginorder = nil
}

// UserCountLoginorder returns the value of the "user_count_loginorder" field in the mutation.
func (m *StatsDailyScenicAreaMutation) UserCountLoginorder() (r int, exists bool) {
	v := m.user_count_loginorder
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountLoginorder returns the old "user_count_loginorder" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldUserCountLoginorder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountLoginorder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountLoginorder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountLoginorder: %w", err)
	}
	return oldValue.UserCountLoginorder, nil
}

// AddUserCountLoginorder adds i to the "user_count_loginorder" field.
func (m *StatsDailyScenicAreaMutation) AddUserCountLoginorder(i int) {
	if m.adduser_count_loginorder != nil {
		*m.adduser_count_loginorder += i
	} else {
		m.adduser_count_loginorder = &i
	}
}

// AddedUserCountLoginorder returns the value that was added to the "user_count_loginorder" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedUserCountLoginorder() (r int, exists bool) {
	v := m.adduser_count_loginorder
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountLoginorder resets all changes to the "user_count_loginorder" field.
func (m *StatsDailyScenicAreaMutation) ResetUserCountLoginorder() {
	m.user_count_loginorder = nil
	m.adduser_count_loginorder = nil
}

// SetOrderCountCreate sets the "order_count_create" field.
func (m *StatsDailyScenicAreaMutation) SetOrderCountCreate(i int) {
	m.order_count_create = &i
	m.addorder_count_create = nil
}

// OrderCountCreate returns the value of the "order_count_create" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderCountCreate() (r int, exists bool) {
	v := m.order_count_create
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCreate returns the old "order_count_create" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderCountCreate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCreate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCreate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCreate: %w", err)
	}
	return oldValue.OrderCountCreate, nil
}

// AddOrderCountCreate adds i to the "order_count_create" field.
func (m *StatsDailyScenicAreaMutation) AddOrderCountCreate(i int) {
	if m.addorder_count_create != nil {
		*m.addorder_count_create += i
	} else {
		m.addorder_count_create = &i
	}
}

// AddedOrderCountCreate returns the value that was added to the "order_count_create" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderCountCreate() (r int, exists bool) {
	v := m.addorder_count_create
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCreate resets all changes to the "order_count_create" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderCountCreate() {
	m.order_count_create = nil
	m.addorder_count_create = nil
}

// SetOrderCountFinish sets the "order_count_finish" field.
func (m *StatsDailyScenicAreaMutation) SetOrderCountFinish(i int) {
	m.order_count_finish = &i
	m.addorder_count_finish = nil
}

// OrderCountFinish returns the value of the "order_count_finish" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderCountFinish() (r int, exists bool) {
	v := m.order_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountFinish returns the old "order_count_finish" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderCountFinish(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountFinish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountFinish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountFinish: %w", err)
	}
	return oldValue.OrderCountFinish, nil
}

// AddOrderCountFinish adds i to the "order_count_finish" field.
func (m *StatsDailyScenicAreaMutation) AddOrderCountFinish(i int) {
	if m.addorder_count_finish != nil {
		*m.addorder_count_finish += i
	} else {
		m.addorder_count_finish = &i
	}
}

// AddedOrderCountFinish returns the value that was added to the "order_count_finish" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderCountFinish() (r int, exists bool) {
	v := m.addorder_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountFinish resets all changes to the "order_count_finish" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderCountFinish() {
	m.order_count_finish = nil
	m.addorder_count_finish = nil
}

// SetOrderCountCancel sets the "order_count_cancel" field.
func (m *StatsDailyScenicAreaMutation) SetOrderCountCancel(i int) {
	m.order_count_cancel = &i
	m.addorder_count_cancel = nil
}

// OrderCountCancel returns the value of the "order_count_cancel" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderCountCancel() (r int, exists bool) {
	v := m.order_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCancel returns the old "order_count_cancel" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderCountCancel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCancel: %w", err)
	}
	return oldValue.OrderCountCancel, nil
}

// AddOrderCountCancel adds i to the "order_count_cancel" field.
func (m *StatsDailyScenicAreaMutation) AddOrderCountCancel(i int) {
	if m.addorder_count_cancel != nil {
		*m.addorder_count_cancel += i
	} else {
		m.addorder_count_cancel = &i
	}
}

// AddedOrderCountCancel returns the value that was added to the "order_count_cancel" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderCountCancel() (r int, exists bool) {
	v := m.addorder_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCancel resets all changes to the "order_count_cancel" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderCountCancel() {
	m.order_count_cancel = nil
	m.addorder_count_cancel = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *StatsDailyScenicAreaMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *StatsDailyScenicAreaMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderDuration sets the "order_duration" field.
func (m *StatsDailyScenicAreaMutation) SetOrderDuration(i int) {
	m.order_duration = &i
	m.addorder_duration = nil
}

// OrderDuration returns the value of the "order_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderDuration() (r int, exists bool) {
	v := m.order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDuration returns the old "order_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDuration: %w", err)
	}
	return oldValue.OrderDuration, nil
}

// AddOrderDuration adds i to the "order_duration" field.
func (m *StatsDailyScenicAreaMutation) AddOrderDuration(i int) {
	if m.addorder_duration != nil {
		*m.addorder_duration += i
	} else {
		m.addorder_duration = &i
	}
}

// AddedOrderDuration returns the value that was added to the "order_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderDuration() (r int, exists bool) {
	v := m.addorder_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDuration resets all changes to the "order_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderDuration() {
	m.order_duration = nil
	m.addorder_duration = nil
}

// SetOrderMileage sets the "order_mileage" field.
func (m *StatsDailyScenicAreaMutation) SetOrderMileage(i int) {
	m.order_mileage = &i
	m.addorder_mileage = nil
}

// OrderMileage returns the value of the "order_mileage" field in the mutation.
func (m *StatsDailyScenicAreaMutation) OrderMileage() (r int, exists bool) {
	v := m.order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMileage returns the old "order_mileage" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldOrderMileage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMileage: %w", err)
	}
	return oldValue.OrderMileage, nil
}

// AddOrderMileage adds i to the "order_mileage" field.
func (m *StatsDailyScenicAreaMutation) AddOrderMileage(i int) {
	if m.addorder_mileage != nil {
		*m.addorder_mileage += i
	} else {
		m.addorder_mileage = &i
	}
}

// AddedOrderMileage returns the value that was added to the "order_mileage" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedOrderMileage() (r int, exists bool) {
	v := m.addorder_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderMileage resets all changes to the "order_mileage" field.
func (m *StatsDailyScenicAreaMutation) ResetOrderMileage() {
	m.order_mileage = nil
	m.addorder_mileage = nil
}

// SetCarCountDeploy sets the "car_count_deploy" field.
func (m *StatsDailyScenicAreaMutation) SetCarCountDeploy(i int) {
	m.car_count_deploy = &i
	m.addcar_count_deploy = nil
}

// CarCountDeploy returns the value of the "car_count_deploy" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarCountDeploy() (r int, exists bool) {
	v := m.car_count_deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldCarCountDeploy returns the old "car_count_deploy" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarCountDeploy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarCountDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarCountDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarCountDeploy: %w", err)
	}
	return oldValue.CarCountDeploy, nil
}

// AddCarCountDeploy adds i to the "car_count_deploy" field.
func (m *StatsDailyScenicAreaMutation) AddCarCountDeploy(i int) {
	if m.addcar_count_deploy != nil {
		*m.addcar_count_deploy += i
	} else {
		m.addcar_count_deploy = &i
	}
}

// AddedCarCountDeploy returns the value that was added to the "car_count_deploy" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarCountDeploy() (r int, exists bool) {
	v := m.addcar_count_deploy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarCountDeploy resets all changes to the "car_count_deploy" field.
func (m *StatsDailyScenicAreaMutation) ResetCarCountDeploy() {
	m.car_count_deploy = nil
	m.addcar_count_deploy = nil
}

// SetCarCountOperation sets the "car_count_operation" field.
func (m *StatsDailyScenicAreaMutation) SetCarCountOperation(i int) {
	m.car_count_operation = &i
	m.addcar_count_operation = nil
}

// CarCountOperation returns the value of the "car_count_operation" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarCountOperation() (r int, exists bool) {
	v := m.car_count_operation
	if v == nil {
		return
	}
	return *v, true
}

// OldCarCountOperation returns the old "car_count_operation" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarCountOperation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarCountOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarCountOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarCountOperation: %w", err)
	}
	return oldValue.CarCountOperation, nil
}

// AddCarCountOperation adds i to the "car_count_operation" field.
func (m *StatsDailyScenicAreaMutation) AddCarCountOperation(i int) {
	if m.addcar_count_operation != nil {
		*m.addcar_count_operation += i
	} else {
		m.addcar_count_operation = &i
	}
}

// AddedCarCountOperation returns the value that was added to the "car_count_operation" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarCountOperation() (r int, exists bool) {
	v := m.addcar_count_operation
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarCountOperation resets all changes to the "car_count_operation" field.
func (m *StatsDailyScenicAreaMutation) ResetCarCountOperation() {
	m.car_count_operation = nil
	m.addcar_count_operation = nil
}

// SetCarOperationManualDuration sets the "car_operation_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationManualDuration(f float32) {
	m.car_operation_manual_duration = &f
	m.addcar_operation_manual_duration = nil
}

// CarOperationManualDuration returns the value of the "car_operation_manual_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationManualDuration() (r float32, exists bool) {
	v := m.car_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationManualDuration returns the old "car_operation_manual_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationManualDuration: %w", err)
	}
	return oldValue.CarOperationManualDuration, nil
}

// AddCarOperationManualDuration adds f to the "car_operation_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationManualDuration(f float32) {
	if m.addcar_operation_manual_duration != nil {
		*m.addcar_operation_manual_duration += f
	} else {
		m.addcar_operation_manual_duration = &f
	}
}

// AddedCarOperationManualDuration returns the value that was added to the "car_operation_manual_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationManualDuration() (r float32, exists bool) {
	v := m.addcar_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationManualDuration resets all changes to the "car_operation_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationManualDuration() {
	m.car_operation_manual_duration = nil
	m.addcar_operation_manual_duration = nil
}

// SetCarOperationAutoDuration sets the "car_operation_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationAutoDuration(f float32) {
	m.car_operation_auto_duration = &f
	m.addcar_operation_auto_duration = nil
}

// CarOperationAutoDuration returns the value of the "car_operation_auto_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationAutoDuration() (r float32, exists bool) {
	v := m.car_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationAutoDuration returns the old "car_operation_auto_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationAutoDuration: %w", err)
	}
	return oldValue.CarOperationAutoDuration, nil
}

// AddCarOperationAutoDuration adds f to the "car_operation_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationAutoDuration(f float32) {
	if m.addcar_operation_auto_duration != nil {
		*m.addcar_operation_auto_duration += f
	} else {
		m.addcar_operation_auto_duration = &f
	}
}

// AddedCarOperationAutoDuration returns the value that was added to the "car_operation_auto_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationAutoDuration() (r float32, exists bool) {
	v := m.addcar_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationAutoDuration resets all changes to the "car_operation_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationAutoDuration() {
	m.car_operation_auto_duration = nil
	m.addcar_operation_auto_duration = nil
}

// SetCarOperationNormalDuration sets the "car_operation_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationNormalDuration(f float32) {
	m.car_operation_normal_duration = &f
	m.addcar_operation_normal_duration = nil
}

// CarOperationNormalDuration returns the value of the "car_operation_normal_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationNormalDuration() (r float32, exists bool) {
	v := m.car_operation_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationNormalDuration returns the old "car_operation_normal_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationNormalDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationNormalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationNormalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationNormalDuration: %w", err)
	}
	return oldValue.CarOperationNormalDuration, nil
}

// AddCarOperationNormalDuration adds f to the "car_operation_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationNormalDuration(f float32) {
	if m.addcar_operation_normal_duration != nil {
		*m.addcar_operation_normal_duration += f
	} else {
		m.addcar_operation_normal_duration = &f
	}
}

// AddedCarOperationNormalDuration returns the value that was added to the "car_operation_normal_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationNormalDuration() (r float32, exists bool) {
	v := m.addcar_operation_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationNormalDuration resets all changes to the "car_operation_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationNormalDuration() {
	m.car_operation_normal_duration = nil
	m.addcar_operation_normal_duration = nil
}

// SetCarOperationFaultDuration sets the "car_operation_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationFaultDuration(f float32) {
	m.car_operation_fault_duration = &f
	m.addcar_operation_fault_duration = nil
}

// CarOperationFaultDuration returns the value of the "car_operation_fault_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationFaultDuration() (r float32, exists bool) {
	v := m.car_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationFaultDuration returns the old "car_operation_fault_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationFaultDuration: %w", err)
	}
	return oldValue.CarOperationFaultDuration, nil
}

// AddCarOperationFaultDuration adds f to the "car_operation_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationFaultDuration(f float32) {
	if m.addcar_operation_fault_duration != nil {
		*m.addcar_operation_fault_duration += f
	} else {
		m.addcar_operation_fault_duration = &f
	}
}

// AddedCarOperationFaultDuration returns the value that was added to the "car_operation_fault_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationFaultDuration() (r float32, exists bool) {
	v := m.addcar_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationFaultDuration resets all changes to the "car_operation_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationFaultDuration() {
	m.car_operation_fault_duration = nil
	m.addcar_operation_fault_duration = nil
}

// SetCarOperationMileage sets the "car_operation_mileage" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationMileage(f float32) {
	m.car_operation_mileage = &f
	m.addcar_operation_mileage = nil
}

// CarOperationMileage returns the value of the "car_operation_mileage" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationMileage() (r float32, exists bool) {
	v := m.car_operation_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationMileage returns the old "car_operation_mileage" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationMileage: %w", err)
	}
	return oldValue.CarOperationMileage, nil
}

// AddCarOperationMileage adds f to the "car_operation_mileage" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationMileage(f float32) {
	if m.addcar_operation_mileage != nil {
		*m.addcar_operation_mileage += f
	} else {
		m.addcar_operation_mileage = &f
	}
}

// AddedCarOperationMileage returns the value that was added to the "car_operation_mileage" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationMileage() (r float32, exists bool) {
	v := m.addcar_operation_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationMileage resets all changes to the "car_operation_mileage" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationMileage() {
	m.car_operation_mileage = nil
	m.addcar_operation_mileage = nil
}

// SetCarOperationFaultTimes sets the "car_operation_fault_times" field.
func (m *StatsDailyScenicAreaMutation) SetCarOperationFaultTimes(u uint32) {
	m.car_operation_fault_times = &u
	m.addcar_operation_fault_times = nil
}

// CarOperationFaultTimes returns the value of the "car_operation_fault_times" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarOperationFaultTimes() (r uint32, exists bool) {
	v := m.car_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationFaultTimes returns the old "car_operation_fault_times" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationFaultTimes: %w", err)
	}
	return oldValue.CarOperationFaultTimes, nil
}

// AddCarOperationFaultTimes adds u to the "car_operation_fault_times" field.
func (m *StatsDailyScenicAreaMutation) AddCarOperationFaultTimes(u int32) {
	if m.addcar_operation_fault_times != nil {
		*m.addcar_operation_fault_times += u
	} else {
		m.addcar_operation_fault_times = &u
	}
}

// AddedCarOperationFaultTimes returns the value that was added to the "car_operation_fault_times" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarOperationFaultTimes() (r int32, exists bool) {
	v := m.addcar_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationFaultTimes resets all changes to the "car_operation_fault_times" field.
func (m *StatsDailyScenicAreaMutation) ResetCarOperationFaultTimes() {
	m.car_operation_fault_times = nil
	m.addcar_operation_fault_times = nil
}

// SetCarMaintainManualDuration sets the "car_maintain_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainManualDuration(f float32) {
	m.car_maintain_manual_duration = &f
	m.addcar_maintain_manual_duration = nil
}

// CarMaintainManualDuration returns the value of the "car_maintain_manual_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainManualDuration() (r float32, exists bool) {
	v := m.car_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainManualDuration returns the old "car_maintain_manual_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainManualDuration: %w", err)
	}
	return oldValue.CarMaintainManualDuration, nil
}

// AddCarMaintainManualDuration adds f to the "car_maintain_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainManualDuration(f float32) {
	if m.addcar_maintain_manual_duration != nil {
		*m.addcar_maintain_manual_duration += f
	} else {
		m.addcar_maintain_manual_duration = &f
	}
}

// AddedCarMaintainManualDuration returns the value that was added to the "car_maintain_manual_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainManualDuration() (r float32, exists bool) {
	v := m.addcar_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainManualDuration resets all changes to the "car_maintain_manual_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainManualDuration() {
	m.car_maintain_manual_duration = nil
	m.addcar_maintain_manual_duration = nil
}

// SetCarMaintainAutoDuration sets the "car_maintain_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainAutoDuration(f float32) {
	m.car_maintain_auto_duration = &f
	m.addcar_maintain_auto_duration = nil
}

// CarMaintainAutoDuration returns the value of the "car_maintain_auto_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainAutoDuration() (r float32, exists bool) {
	v := m.car_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainAutoDuration returns the old "car_maintain_auto_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainAutoDuration: %w", err)
	}
	return oldValue.CarMaintainAutoDuration, nil
}

// AddCarMaintainAutoDuration adds f to the "car_maintain_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainAutoDuration(f float32) {
	if m.addcar_maintain_auto_duration != nil {
		*m.addcar_maintain_auto_duration += f
	} else {
		m.addcar_maintain_auto_duration = &f
	}
}

// AddedCarMaintainAutoDuration returns the value that was added to the "car_maintain_auto_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainAutoDuration() (r float32, exists bool) {
	v := m.addcar_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainAutoDuration resets all changes to the "car_maintain_auto_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainAutoDuration() {
	m.car_maintain_auto_duration = nil
	m.addcar_maintain_auto_duration = nil
}

// SetCarMaintainNormalDuration sets the "car_maintain_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainNormalDuration(f float32) {
	m.car_maintain_normal_duration = &f
	m.addcar_maintain_normal_duration = nil
}

// CarMaintainNormalDuration returns the value of the "car_maintain_normal_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainNormalDuration() (r float32, exists bool) {
	v := m.car_maintain_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainNormalDuration returns the old "car_maintain_normal_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainNormalDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainNormalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainNormalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainNormalDuration: %w", err)
	}
	return oldValue.CarMaintainNormalDuration, nil
}

// AddCarMaintainNormalDuration adds f to the "car_maintain_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainNormalDuration(f float32) {
	if m.addcar_maintain_normal_duration != nil {
		*m.addcar_maintain_normal_duration += f
	} else {
		m.addcar_maintain_normal_duration = &f
	}
}

// AddedCarMaintainNormalDuration returns the value that was added to the "car_maintain_normal_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainNormalDuration() (r float32, exists bool) {
	v := m.addcar_maintain_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainNormalDuration resets all changes to the "car_maintain_normal_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainNormalDuration() {
	m.car_maintain_normal_duration = nil
	m.addcar_maintain_normal_duration = nil
}

// SetCarMaintainFaultDuration sets the "car_maintain_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainFaultDuration(f float32) {
	m.car_maintain_fault_duration = &f
	m.addcar_maintain_fault_duration = nil
}

// CarMaintainFaultDuration returns the value of the "car_maintain_fault_duration" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainFaultDuration() (r float32, exists bool) {
	v := m.car_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainFaultDuration returns the old "car_maintain_fault_duration" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainFaultDuration: %w", err)
	}
	return oldValue.CarMaintainFaultDuration, nil
}

// AddCarMaintainFaultDuration adds f to the "car_maintain_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainFaultDuration(f float32) {
	if m.addcar_maintain_fault_duration != nil {
		*m.addcar_maintain_fault_duration += f
	} else {
		m.addcar_maintain_fault_duration = &f
	}
}

// AddedCarMaintainFaultDuration returns the value that was added to the "car_maintain_fault_duration" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainFaultDuration() (r float32, exists bool) {
	v := m.addcar_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainFaultDuration resets all changes to the "car_maintain_fault_duration" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainFaultDuration() {
	m.car_maintain_fault_duration = nil
	m.addcar_maintain_fault_duration = nil
}

// SetCarMaintainMileage sets the "car_maintain_mileage" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainMileage(f float32) {
	m.car_maintain_mileage = &f
	m.addcar_maintain_mileage = nil
}

// CarMaintainMileage returns the value of the "car_maintain_mileage" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainMileage() (r float32, exists bool) {
	v := m.car_maintain_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainMileage returns the old "car_maintain_mileage" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainMileage: %w", err)
	}
	return oldValue.CarMaintainMileage, nil
}

// AddCarMaintainMileage adds f to the "car_maintain_mileage" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainMileage(f float32) {
	if m.addcar_maintain_mileage != nil {
		*m.addcar_maintain_mileage += f
	} else {
		m.addcar_maintain_mileage = &f
	}
}

// AddedCarMaintainMileage returns the value that was added to the "car_maintain_mileage" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainMileage() (r float32, exists bool) {
	v := m.addcar_maintain_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainMileage resets all changes to the "car_maintain_mileage" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainMileage() {
	m.car_maintain_mileage = nil
	m.addcar_maintain_mileage = nil
}

// SetCarMaintainFaultTimes sets the "car_maintain_fault_times" field.
func (m *StatsDailyScenicAreaMutation) SetCarMaintainFaultTimes(u uint32) {
	m.car_maintain_fault_times = &u
	m.addcar_maintain_fault_times = nil
}

// CarMaintainFaultTimes returns the value of the "car_maintain_fault_times" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarMaintainFaultTimes() (r uint32, exists bool) {
	v := m.car_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainFaultTimes returns the old "car_maintain_fault_times" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainFaultTimes: %w", err)
	}
	return oldValue.CarMaintainFaultTimes, nil
}

// AddCarMaintainFaultTimes adds u to the "car_maintain_fault_times" field.
func (m *StatsDailyScenicAreaMutation) AddCarMaintainFaultTimes(u int32) {
	if m.addcar_maintain_fault_times != nil {
		*m.addcar_maintain_fault_times += u
	} else {
		m.addcar_maintain_fault_times = &u
	}
}

// AddedCarMaintainFaultTimes returns the value that was added to the "car_maintain_fault_times" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarMaintainFaultTimes() (r int32, exists bool) {
	v := m.addcar_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainFaultTimes resets all changes to the "car_maintain_fault_times" field.
func (m *StatsDailyScenicAreaMutation) ResetCarMaintainFaultTimes() {
	m.car_maintain_fault_times = nil
	m.addcar_maintain_fault_times = nil
}

// SetCarAlarmTimes sets the "car_alarm_times" field.
func (m *StatsDailyScenicAreaMutation) SetCarAlarmTimes(i int) {
	m.car_alarm_times = &i
	m.addcar_alarm_times = nil
}

// CarAlarmTimes returns the value of the "car_alarm_times" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CarAlarmTimes() (r int, exists bool) {
	v := m.car_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarAlarmTimes returns the old "car_alarm_times" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCarAlarmTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarAlarmTimes: %w", err)
	}
	return oldValue.CarAlarmTimes, nil
}

// AddCarAlarmTimes adds i to the "car_alarm_times" field.
func (m *StatsDailyScenicAreaMutation) AddCarAlarmTimes(i int) {
	if m.addcar_alarm_times != nil {
		*m.addcar_alarm_times += i
	} else {
		m.addcar_alarm_times = &i
	}
}

// AddedCarAlarmTimes returns the value that was added to the "car_alarm_times" field in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedCarAlarmTimes() (r int, exists bool) {
	v := m.addcar_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarAlarmTimes resets all changes to the "car_alarm_times" field.
func (m *StatsDailyScenicAreaMutation) ResetCarAlarmTimes() {
	m.car_alarm_times = nil
	m.addcar_alarm_times = nil
}

// SetStatsTime sets the "stats_time" field.
func (m *StatsDailyScenicAreaMutation) SetStatsTime(t time.Time) {
	m.stats_time = &t
}

// StatsTime returns the value of the "stats_time" field in the mutation.
func (m *StatsDailyScenicAreaMutation) StatsTime() (r time.Time, exists bool) {
	v := m.stats_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTime returns the old "stats_time" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldStatsTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTime: %w", err)
	}
	return oldValue.StatsTime, nil
}

// ResetStatsTime resets all changes to the "stats_time" field.
func (m *StatsDailyScenicAreaMutation) ResetStatsTime() {
	m.stats_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *StatsDailyScenicAreaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatsDailyScenicAreaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatsDailyScenicArea entity.
// If the StatsDailyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsDailyScenicAreaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatsDailyScenicAreaMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the StatsDailyScenicAreaMutation builder.
func (m *StatsDailyScenicAreaMutation) Where(ps ...predicate.StatsDailyScenicArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatsDailyScenicAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatsDailyScenicAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatsDailyScenicArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatsDailyScenicAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatsDailyScenicAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatsDailyScenicArea).
func (m *StatsDailyScenicAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatsDailyScenicAreaMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.scenic_area_id != nil {
		fields = append(fields, statsdailyscenicarea.FieldScenicAreaID)
	}
	if m.y != nil {
		fields = append(fields, statsdailyscenicarea.FieldY)
	}
	if m.m != nil {
		fields = append(fields, statsdailyscenicarea.FieldM)
	}
	if m.d != nil {
		fields = append(fields, statsdailyscenicarea.FieldD)
	}
	if m.week != nil {
		fields = append(fields, statsdailyscenicarea.FieldWeek)
	}
	if m.weekday != nil {
		fields = append(fields, statsdailyscenicarea.FieldWeekday)
	}
	if m.period != nil {
		fields = append(fields, statsdailyscenicarea.FieldPeriod)
	}
	if m.user_count_login != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountLogin)
	}
	if m.user_count_register != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountRegister)
	}
	if m.user_count_order != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountOrder)
	}
	if m.user_count_loginorder != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountLoginorder)
	}
	if m.order_count_create != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountCreate)
	}
	if m.order_count_finish != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountFinish)
	}
	if m.order_count_cancel != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountCancel)
	}
	if m.order_amount != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderAmount)
	}
	if m.order_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderDuration)
	}
	if m.order_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderMileage)
	}
	if m.car_count_deploy != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarCountDeploy)
	}
	if m.car_count_operation != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarCountOperation)
	}
	if m.car_operation_manual_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationManualDuration)
	}
	if m.car_operation_auto_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationAutoDuration)
	}
	if m.car_operation_normal_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationNormalDuration)
	}
	if m.car_operation_fault_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationFaultDuration)
	}
	if m.car_operation_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationMileage)
	}
	if m.car_operation_fault_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationFaultTimes)
	}
	if m.car_maintain_manual_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainManualDuration)
	}
	if m.car_maintain_auto_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainAutoDuration)
	}
	if m.car_maintain_normal_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainNormalDuration)
	}
	if m.car_maintain_fault_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainFaultDuration)
	}
	if m.car_maintain_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainMileage)
	}
	if m.car_maintain_fault_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainFaultTimes)
	}
	if m.car_alarm_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarAlarmTimes)
	}
	if m.stats_time != nil {
		fields = append(fields, statsdailyscenicarea.FieldStatsTime)
	}
	if m.create_time != nil {
		fields = append(fields, statsdailyscenicarea.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatsDailyScenicAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		return m.ScenicAreaID()
	case statsdailyscenicarea.FieldY:
		return m.Y()
	case statsdailyscenicarea.FieldM:
		return m.M()
	case statsdailyscenicarea.FieldD:
		return m.D()
	case statsdailyscenicarea.FieldWeek:
		return m.Week()
	case statsdailyscenicarea.FieldWeekday:
		return m.Weekday()
	case statsdailyscenicarea.FieldPeriod:
		return m.Period()
	case statsdailyscenicarea.FieldUserCountLogin:
		return m.UserCountLogin()
	case statsdailyscenicarea.FieldUserCountRegister:
		return m.UserCountRegister()
	case statsdailyscenicarea.FieldUserCountOrder:
		return m.UserCountOrder()
	case statsdailyscenicarea.FieldUserCountLoginorder:
		return m.UserCountLoginorder()
	case statsdailyscenicarea.FieldOrderCountCreate:
		return m.OrderCountCreate()
	case statsdailyscenicarea.FieldOrderCountFinish:
		return m.OrderCountFinish()
	case statsdailyscenicarea.FieldOrderCountCancel:
		return m.OrderCountCancel()
	case statsdailyscenicarea.FieldOrderAmount:
		return m.OrderAmount()
	case statsdailyscenicarea.FieldOrderDuration:
		return m.OrderDuration()
	case statsdailyscenicarea.FieldOrderMileage:
		return m.OrderMileage()
	case statsdailyscenicarea.FieldCarCountDeploy:
		return m.CarCountDeploy()
	case statsdailyscenicarea.FieldCarCountOperation:
		return m.CarCountOperation()
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		return m.CarOperationManualDuration()
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		return m.CarOperationAutoDuration()
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		return m.CarOperationNormalDuration()
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		return m.CarOperationFaultDuration()
	case statsdailyscenicarea.FieldCarOperationMileage:
		return m.CarOperationMileage()
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		return m.CarOperationFaultTimes()
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		return m.CarMaintainManualDuration()
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		return m.CarMaintainAutoDuration()
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		return m.CarMaintainNormalDuration()
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		return m.CarMaintainFaultDuration()
	case statsdailyscenicarea.FieldCarMaintainMileage:
		return m.CarMaintainMileage()
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		return m.CarMaintainFaultTimes()
	case statsdailyscenicarea.FieldCarAlarmTimes:
		return m.CarAlarmTimes()
	case statsdailyscenicarea.FieldStatsTime:
		return m.StatsTime()
	case statsdailyscenicarea.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatsDailyScenicAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case statsdailyscenicarea.FieldY:
		return m.OldY(ctx)
	case statsdailyscenicarea.FieldM:
		return m.OldM(ctx)
	case statsdailyscenicarea.FieldD:
		return m.OldD(ctx)
	case statsdailyscenicarea.FieldWeek:
		return m.OldWeek(ctx)
	case statsdailyscenicarea.FieldWeekday:
		return m.OldWeekday(ctx)
	case statsdailyscenicarea.FieldPeriod:
		return m.OldPeriod(ctx)
	case statsdailyscenicarea.FieldUserCountLogin:
		return m.OldUserCountLogin(ctx)
	case statsdailyscenicarea.FieldUserCountRegister:
		return m.OldUserCountRegister(ctx)
	case statsdailyscenicarea.FieldUserCountOrder:
		return m.OldUserCountOrder(ctx)
	case statsdailyscenicarea.FieldUserCountLoginorder:
		return m.OldUserCountLoginorder(ctx)
	case statsdailyscenicarea.FieldOrderCountCreate:
		return m.OldOrderCountCreate(ctx)
	case statsdailyscenicarea.FieldOrderCountFinish:
		return m.OldOrderCountFinish(ctx)
	case statsdailyscenicarea.FieldOrderCountCancel:
		return m.OldOrderCountCancel(ctx)
	case statsdailyscenicarea.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case statsdailyscenicarea.FieldOrderDuration:
		return m.OldOrderDuration(ctx)
	case statsdailyscenicarea.FieldOrderMileage:
		return m.OldOrderMileage(ctx)
	case statsdailyscenicarea.FieldCarCountDeploy:
		return m.OldCarCountDeploy(ctx)
	case statsdailyscenicarea.FieldCarCountOperation:
		return m.OldCarCountOperation(ctx)
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		return m.OldCarOperationManualDuration(ctx)
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		return m.OldCarOperationAutoDuration(ctx)
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		return m.OldCarOperationNormalDuration(ctx)
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		return m.OldCarOperationFaultDuration(ctx)
	case statsdailyscenicarea.FieldCarOperationMileage:
		return m.OldCarOperationMileage(ctx)
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		return m.OldCarOperationFaultTimes(ctx)
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		return m.OldCarMaintainManualDuration(ctx)
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		return m.OldCarMaintainAutoDuration(ctx)
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		return m.OldCarMaintainNormalDuration(ctx)
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		return m.OldCarMaintainFaultDuration(ctx)
	case statsdailyscenicarea.FieldCarMaintainMileage:
		return m.OldCarMaintainMileage(ctx)
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		return m.OldCarMaintainFaultTimes(ctx)
	case statsdailyscenicarea.FieldCarAlarmTimes:
		return m.OldCarAlarmTimes(ctx)
	case statsdailyscenicarea.FieldStatsTime:
		return m.OldStatsTime(ctx)
	case statsdailyscenicarea.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown StatsDailyScenicArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyScenicAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case statsdailyscenicarea.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case statsdailyscenicarea.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetM(v)
		return nil
	case statsdailyscenicarea.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case statsdailyscenicarea.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeek(v)
		return nil
	case statsdailyscenicarea.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	case statsdailyscenicarea.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case statsdailyscenicarea.FieldUserCountLogin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountLogin(v)
		return nil
	case statsdailyscenicarea.FieldUserCountRegister:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountRegister(v)
		return nil
	case statsdailyscenicarea.FieldUserCountOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountOrder(v)
		return nil
	case statsdailyscenicarea.FieldUserCountLoginorder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountLoginorder(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCreate(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountFinish(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCancel(v)
		return nil
	case statsdailyscenicarea.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case statsdailyscenicarea.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDuration(v)
		return nil
	case statsdailyscenicarea.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarCountDeploy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarCountDeploy(v)
		return nil
	case statsdailyscenicarea.FieldCarCountOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarCountOperation(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationManualDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationAutoDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationNormalDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationFaultDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationFaultTimes(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainManualDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainAutoDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainNormalDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainFaultDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainFaultTimes(v)
		return nil
	case statsdailyscenicarea.FieldCarAlarmTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarAlarmTimes(v)
		return nil
	case statsdailyscenicarea.FieldStatsTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTime(v)
		return nil
	case statsdailyscenicarea.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDailyScenicArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatsDailyScenicAreaMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, statsdailyscenicarea.FieldScenicAreaID)
	}
	if m.addy != nil {
		fields = append(fields, statsdailyscenicarea.FieldY)
	}
	if m.addm != nil {
		fields = append(fields, statsdailyscenicarea.FieldM)
	}
	if m.addd != nil {
		fields = append(fields, statsdailyscenicarea.FieldD)
	}
	if m.addweek != nil {
		fields = append(fields, statsdailyscenicarea.FieldWeek)
	}
	if m.addweekday != nil {
		fields = append(fields, statsdailyscenicarea.FieldWeekday)
	}
	if m.addperiod != nil {
		fields = append(fields, statsdailyscenicarea.FieldPeriod)
	}
	if m.adduser_count_login != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountLogin)
	}
	if m.adduser_count_register != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountRegister)
	}
	if m.adduser_count_order != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountOrder)
	}
	if m.adduser_count_loginorder != nil {
		fields = append(fields, statsdailyscenicarea.FieldUserCountLoginorder)
	}
	if m.addorder_count_create != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountCreate)
	}
	if m.addorder_count_finish != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountFinish)
	}
	if m.addorder_count_cancel != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderCountCancel)
	}
	if m.addorder_amount != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderAmount)
	}
	if m.addorder_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderDuration)
	}
	if m.addorder_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldOrderMileage)
	}
	if m.addcar_count_deploy != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarCountDeploy)
	}
	if m.addcar_count_operation != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarCountOperation)
	}
	if m.addcar_operation_manual_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationManualDuration)
	}
	if m.addcar_operation_auto_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationAutoDuration)
	}
	if m.addcar_operation_normal_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationNormalDuration)
	}
	if m.addcar_operation_fault_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationFaultDuration)
	}
	if m.addcar_operation_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationMileage)
	}
	if m.addcar_operation_fault_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarOperationFaultTimes)
	}
	if m.addcar_maintain_manual_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainManualDuration)
	}
	if m.addcar_maintain_auto_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainAutoDuration)
	}
	if m.addcar_maintain_normal_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainNormalDuration)
	}
	if m.addcar_maintain_fault_duration != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainFaultDuration)
	}
	if m.addcar_maintain_mileage != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainMileage)
	}
	if m.addcar_maintain_fault_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarMaintainFaultTimes)
	}
	if m.addcar_alarm_times != nil {
		fields = append(fields, statsdailyscenicarea.FieldCarAlarmTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatsDailyScenicAreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case statsdailyscenicarea.FieldY:
		return m.AddedY()
	case statsdailyscenicarea.FieldM:
		return m.AddedM()
	case statsdailyscenicarea.FieldD:
		return m.AddedD()
	case statsdailyscenicarea.FieldWeek:
		return m.AddedWeek()
	case statsdailyscenicarea.FieldWeekday:
		return m.AddedWeekday()
	case statsdailyscenicarea.FieldPeriod:
		return m.AddedPeriod()
	case statsdailyscenicarea.FieldUserCountLogin:
		return m.AddedUserCountLogin()
	case statsdailyscenicarea.FieldUserCountRegister:
		return m.AddedUserCountRegister()
	case statsdailyscenicarea.FieldUserCountOrder:
		return m.AddedUserCountOrder()
	case statsdailyscenicarea.FieldUserCountLoginorder:
		return m.AddedUserCountLoginorder()
	case statsdailyscenicarea.FieldOrderCountCreate:
		return m.AddedOrderCountCreate()
	case statsdailyscenicarea.FieldOrderCountFinish:
		return m.AddedOrderCountFinish()
	case statsdailyscenicarea.FieldOrderCountCancel:
		return m.AddedOrderCountCancel()
	case statsdailyscenicarea.FieldOrderAmount:
		return m.AddedOrderAmount()
	case statsdailyscenicarea.FieldOrderDuration:
		return m.AddedOrderDuration()
	case statsdailyscenicarea.FieldOrderMileage:
		return m.AddedOrderMileage()
	case statsdailyscenicarea.FieldCarCountDeploy:
		return m.AddedCarCountDeploy()
	case statsdailyscenicarea.FieldCarCountOperation:
		return m.AddedCarCountOperation()
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		return m.AddedCarOperationManualDuration()
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		return m.AddedCarOperationAutoDuration()
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		return m.AddedCarOperationNormalDuration()
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		return m.AddedCarOperationFaultDuration()
	case statsdailyscenicarea.FieldCarOperationMileage:
		return m.AddedCarOperationMileage()
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		return m.AddedCarOperationFaultTimes()
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		return m.AddedCarMaintainManualDuration()
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		return m.AddedCarMaintainAutoDuration()
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		return m.AddedCarMaintainNormalDuration()
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		return m.AddedCarMaintainFaultDuration()
	case statsdailyscenicarea.FieldCarMaintainMileage:
		return m.AddedCarMaintainMileage()
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		return m.AddedCarMaintainFaultTimes()
	case statsdailyscenicarea.FieldCarAlarmTimes:
		return m.AddedCarAlarmTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsDailyScenicAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case statsdailyscenicarea.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case statsdailyscenicarea.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddM(v)
		return nil
	case statsdailyscenicarea.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddD(v)
		return nil
	case statsdailyscenicarea.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeek(v)
		return nil
	case statsdailyscenicarea.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekday(v)
		return nil
	case statsdailyscenicarea.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case statsdailyscenicarea.FieldUserCountLogin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountLogin(v)
		return nil
	case statsdailyscenicarea.FieldUserCountRegister:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountRegister(v)
		return nil
	case statsdailyscenicarea.FieldUserCountOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountOrder(v)
		return nil
	case statsdailyscenicarea.FieldUserCountLoginorder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountLoginorder(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCreate(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountFinish(v)
		return nil
	case statsdailyscenicarea.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCancel(v)
		return nil
	case statsdailyscenicarea.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case statsdailyscenicarea.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDuration(v)
		return nil
	case statsdailyscenicarea.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarCountDeploy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarCountDeploy(v)
		return nil
	case statsdailyscenicarea.FieldCarCountOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarCountOperation(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationManualDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationAutoDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationNormalDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationFaultDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationFaultTimes(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainManualDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainAutoDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainNormalDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainFaultDuration(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainMileage(v)
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainFaultTimes(v)
		return nil
	case statsdailyscenicarea.FieldCarAlarmTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarAlarmTimes(v)
		return nil
	}
	return fmt.Errorf("unknown StatsDailyScenicArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatsDailyScenicAreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatsDailyScenicAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatsDailyScenicAreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatsDailyScenicArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatsDailyScenicAreaMutation) ResetField(name string) error {
	switch name {
	case statsdailyscenicarea.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case statsdailyscenicarea.FieldY:
		m.ResetY()
		return nil
	case statsdailyscenicarea.FieldM:
		m.ResetM()
		return nil
	case statsdailyscenicarea.FieldD:
		m.ResetD()
		return nil
	case statsdailyscenicarea.FieldWeek:
		m.ResetWeek()
		return nil
	case statsdailyscenicarea.FieldWeekday:
		m.ResetWeekday()
		return nil
	case statsdailyscenicarea.FieldPeriod:
		m.ResetPeriod()
		return nil
	case statsdailyscenicarea.FieldUserCountLogin:
		m.ResetUserCountLogin()
		return nil
	case statsdailyscenicarea.FieldUserCountRegister:
		m.ResetUserCountRegister()
		return nil
	case statsdailyscenicarea.FieldUserCountOrder:
		m.ResetUserCountOrder()
		return nil
	case statsdailyscenicarea.FieldUserCountLoginorder:
		m.ResetUserCountLoginorder()
		return nil
	case statsdailyscenicarea.FieldOrderCountCreate:
		m.ResetOrderCountCreate()
		return nil
	case statsdailyscenicarea.FieldOrderCountFinish:
		m.ResetOrderCountFinish()
		return nil
	case statsdailyscenicarea.FieldOrderCountCancel:
		m.ResetOrderCountCancel()
		return nil
	case statsdailyscenicarea.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case statsdailyscenicarea.FieldOrderDuration:
		m.ResetOrderDuration()
		return nil
	case statsdailyscenicarea.FieldOrderMileage:
		m.ResetOrderMileage()
		return nil
	case statsdailyscenicarea.FieldCarCountDeploy:
		m.ResetCarCountDeploy()
		return nil
	case statsdailyscenicarea.FieldCarCountOperation:
		m.ResetCarCountOperation()
		return nil
	case statsdailyscenicarea.FieldCarOperationManualDuration:
		m.ResetCarOperationManualDuration()
		return nil
	case statsdailyscenicarea.FieldCarOperationAutoDuration:
		m.ResetCarOperationAutoDuration()
		return nil
	case statsdailyscenicarea.FieldCarOperationNormalDuration:
		m.ResetCarOperationNormalDuration()
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultDuration:
		m.ResetCarOperationFaultDuration()
		return nil
	case statsdailyscenicarea.FieldCarOperationMileage:
		m.ResetCarOperationMileage()
		return nil
	case statsdailyscenicarea.FieldCarOperationFaultTimes:
		m.ResetCarOperationFaultTimes()
		return nil
	case statsdailyscenicarea.FieldCarMaintainManualDuration:
		m.ResetCarMaintainManualDuration()
		return nil
	case statsdailyscenicarea.FieldCarMaintainAutoDuration:
		m.ResetCarMaintainAutoDuration()
		return nil
	case statsdailyscenicarea.FieldCarMaintainNormalDuration:
		m.ResetCarMaintainNormalDuration()
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultDuration:
		m.ResetCarMaintainFaultDuration()
		return nil
	case statsdailyscenicarea.FieldCarMaintainMileage:
		m.ResetCarMaintainMileage()
		return nil
	case statsdailyscenicarea.FieldCarMaintainFaultTimes:
		m.ResetCarMaintainFaultTimes()
		return nil
	case statsdailyscenicarea.FieldCarAlarmTimes:
		m.ResetCarAlarmTimes()
		return nil
	case statsdailyscenicarea.FieldStatsTime:
		m.ResetStatsTime()
		return nil
	case statsdailyscenicarea.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown StatsDailyScenicArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatsDailyScenicAreaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatsDailyScenicAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatsDailyScenicAreaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatsDailyScenicAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatsDailyScenicAreaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatsDailyScenicAreaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StatsDailyScenicArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatsDailyScenicAreaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StatsDailyScenicArea edge %s", name)
}

// StatsHourlyCarMutation represents an operation that mutates the StatsHourlyCar nodes in the graph.
type StatsHourlyCarMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	y                                       *int
	addy                                    *int
	m                                       *int
	addm                                    *int
	d                                       *int
	addd                                    *int
	h                                       *int
	addh                                    *int
	week                                    *int
	addweek                                 *int
	weekday                                 *int
	addweekday                              *int
	period                                  *int
	addperiod                               *int
	order_count_create                      *int
	addorder_count_create                   *int
	order_count_finish                      *int
	addorder_count_finish                   *int
	order_count_cancel                      *int
	addorder_count_cancel                   *int
	order_amount                            *int
	addorder_amount                         *int
	order_duration                          *int
	addorder_duration                       *int
	order_mileage                           *int
	addorder_mileage                        *int
	order_score                             *int
	addorder_score                          *int
	cumulative_operation_lock_duration      *float32
	addcumulative_operation_lock_duration   *float32
	cumulative_operation_manual_duration    *float32
	addcumulative_operation_manual_duration *float32
	cumulative_operation_auto_duration      *float32
	addcumulative_operation_auto_duration   *float32
	cumulative_operation_fault_duration     *float32
	addcumulative_operation_fault_duration  *float32
	cumulative_operation_lock_times         *uint32
	addcumulative_operation_lock_times      *int32
	cumulative_operation_manual_times       *uint32
	addcumulative_operation_manual_times    *int32
	cumulative_operation_auto_times         *uint32
	addcumulative_operation_auto_times      *int32
	cumulative_operation_fault_times        *uint32
	addcumulative_operation_fault_times     *int32
	cumulative_operation_manual_mileage     *float32
	addcumulative_operation_manual_mileage  *float32
	cumulative_operation_auto_mileage       *float32
	addcumulative_operation_auto_mileage    *float32
	cumulative_maintain_lock_duration       *float32
	addcumulative_maintain_lock_duration    *float32
	cumulative_maintain_manual_duration     *float32
	addcumulative_maintain_manual_duration  *float32
	cumulative_maintain_auto_duration       *float32
	addcumulative_maintain_auto_duration    *float32
	cumulative_maintain_remote_duration     *float32
	addcumulative_maintain_remote_duration  *float32
	cumulative_maintain_fault_duration      *float32
	addcumulative_maintain_fault_duration   *float32
	cumulative_maintain_lock_times          *uint32
	addcumulative_maintain_lock_times       *int32
	cumulative_maintain_manual_times        *uint32
	addcumulative_maintain_manual_times     *int32
	cumulative_maintain_auto_times          *uint32
	addcumulative_maintain_auto_times       *int32
	cumulative_maintain_remote_times        *uint32
	addcumulative_maintain_remote_times     *int32
	cumulative_maintain_fault_times         *uint32
	addcumulative_maintain_fault_times      *int32
	cumulative_maintain_manual_mileage      *float32
	addcumulative_maintain_manual_mileage   *float32
	cumulative_maintain_auto_mileage        *float32
	addcumulative_maintain_auto_mileage     *float32
	cumulative_maintain_remote_mileage      *float32
	addcumulative_maintain_remote_mileage   *float32
	cumulative_alarm_times                  *uint32
	addcumulative_alarm_times               *int32
	operation_lock_duration                 *float32
	addoperation_lock_duration              *float32
	operation_manual_duration               *float32
	addoperation_manual_duration            *float32
	operation_auto_duration                 *float32
	addoperation_auto_duration              *float32
	operation_fault_duration                *float32
	addoperation_fault_duration             *float32
	operation_lock_times                    *uint32
	addoperation_lock_times                 *int32
	operation_manual_times                  *uint32
	addoperation_manual_times               *int32
	operation_auto_times                    *uint32
	addoperation_auto_times                 *int32
	operation_fault_times                   *uint32
	addoperation_fault_times                *int32
	operation_manual_mileage                *float32
	addoperation_manual_mileage             *float32
	operation_auto_mileage                  *float32
	addoperation_auto_mileage               *float32
	maintain_lock_duration                  *float32
	addmaintain_lock_duration               *float32
	maintain_manual_duration                *float32
	addmaintain_manual_duration             *float32
	maintain_auto_duration                  *float32
	addmaintain_auto_duration               *float32
	maintain_remote_duration                *float32
	addmaintain_remote_duration             *float32
	maintain_fault_duration                 *float32
	addmaintain_fault_duration              *float32
	maintain_lock_times                     *uint32
	addmaintain_lock_times                  *int32
	maintain_manual_times                   *uint32
	addmaintain_manual_times                *int32
	maintain_auto_times                     *uint32
	addmaintain_auto_times                  *int32
	maintain_remote_times                   *uint32
	addmaintain_remote_times                *int32
	maintain_fault_times                    *uint32
	addmaintain_fault_times                 *int32
	maintain_manual_mileage                 *float32
	addmaintain_manual_mileage              *float32
	maintain_auto_mileage                   *float32
	addmaintain_auto_mileage                *float32
	maintain_remote_mileage                 *float32
	addmaintain_remote_mileage              *float32
	alarm_times                             *uint32
	addalarm_times                          *int32
	stats_time                              *time.Time
	create_time                             *time.Time
	clearedFields                           map[string]struct{}
	background_scenic_area                  *int
	clearedbackground_scenic_area           bool
	car                                     *int
	clearedcar                              bool
	done                                    bool
	oldValue                                func(context.Context) (*StatsHourlyCar, error)
	predicates                              []predicate.StatsHourlyCar
}

var _ ent.Mutation = (*StatsHourlyCarMutation)(nil)

// statshourlycarOption allows management of the mutation configuration using functional options.
type statshourlycarOption func(*StatsHourlyCarMutation)

// newStatsHourlyCarMutation creates new mutation for the StatsHourlyCar entity.
func newStatsHourlyCarMutation(c config, op Op, opts ...statshourlycarOption) *StatsHourlyCarMutation {
	m := &StatsHourlyCarMutation{
		config:        c,
		op:            op,
		typ:           TypeStatsHourlyCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatsHourlyCarID sets the ID field of the mutation.
func withStatsHourlyCarID(id int) statshourlycarOption {
	return func(m *StatsHourlyCarMutation) {
		var (
			err   error
			once  sync.Once
			value *StatsHourlyCar
		)
		m.oldValue = func(ctx context.Context) (*StatsHourlyCar, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatsHourlyCar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatsHourlyCar sets the old StatsHourlyCar of the mutation.
func withStatsHourlyCar(node *StatsHourlyCar) statshourlycarOption {
	return func(m *StatsHourlyCarMutation) {
		m.oldValue = func(context.Context) (*StatsHourlyCar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatsHourlyCarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatsHourlyCarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatsHourlyCar entities.
func (m *StatsHourlyCarMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatsHourlyCarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatsHourlyCarMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatsHourlyCar.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *StatsHourlyCarMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *StatsHourlyCarMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *StatsHourlyCarMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
}

// SetCarID sets the "car_id" field.
func (m *StatsHourlyCarMutation) SetCarID(i int) {
	m.car = &i
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *StatsHourlyCarMutation) CarID() (r int, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ResetCarID resets all changes to the "car_id" field.
func (m *StatsHourlyCarMutation) ResetCarID() {
	m.car = nil
}

// SetY sets the "y" field.
func (m *StatsHourlyCarMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *StatsHourlyCarMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *StatsHourlyCarMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *StatsHourlyCarMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *StatsHourlyCarMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetM sets the "m" field.
func (m *StatsHourlyCarMutation) SetM(i int) {
	m.m = &i
	m.addm = nil
}

// M returns the value of the "m" field in the mutation.
func (m *StatsHourlyCarMutation) M() (r int, exists bool) {
	v := m.m
	if v == nil {
		return
	}
	return *v, true
}

// OldM returns the old "m" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldM is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldM: %w", err)
	}
	return oldValue.M, nil
}

// AddM adds i to the "m" field.
func (m *StatsHourlyCarMutation) AddM(i int) {
	if m.addm != nil {
		*m.addm += i
	} else {
		m.addm = &i
	}
}

// AddedM returns the value that was added to the "m" field in this mutation.
func (m *StatsHourlyCarMutation) AddedM() (r int, exists bool) {
	v := m.addm
	if v == nil {
		return
	}
	return *v, true
}

// ResetM resets all changes to the "m" field.
func (m *StatsHourlyCarMutation) ResetM() {
	m.m = nil
	m.addm = nil
}

// SetD sets the "d" field.
func (m *StatsHourlyCarMutation) SetD(i int) {
	m.d = &i
	m.addd = nil
}

// D returns the value of the "d" field in the mutation.
func (m *StatsHourlyCarMutation) D() (r int, exists bool) {
	v := m.d
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "d" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// AddD adds i to the "d" field.
func (m *StatsHourlyCarMutation) AddD(i int) {
	if m.addd != nil {
		*m.addd += i
	} else {
		m.addd = &i
	}
}

// AddedD returns the value that was added to the "d" field in this mutation.
func (m *StatsHourlyCarMutation) AddedD() (r int, exists bool) {
	v := m.addd
	if v == nil {
		return
	}
	return *v, true
}

// ResetD resets all changes to the "d" field.
func (m *StatsHourlyCarMutation) ResetD() {
	m.d = nil
	m.addd = nil
}

// SetH sets the "h" field.
func (m *StatsHourlyCarMutation) SetH(i int) {
	m.h = &i
	m.addh = nil
}

// H returns the value of the "h" field in the mutation.
func (m *StatsHourlyCarMutation) H() (r int, exists bool) {
	v := m.h
	if v == nil {
		return
	}
	return *v, true
}

// OldH returns the old "h" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldH(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH: %w", err)
	}
	return oldValue.H, nil
}

// AddH adds i to the "h" field.
func (m *StatsHourlyCarMutation) AddH(i int) {
	if m.addh != nil {
		*m.addh += i
	} else {
		m.addh = &i
	}
}

// AddedH returns the value that was added to the "h" field in this mutation.
func (m *StatsHourlyCarMutation) AddedH() (r int, exists bool) {
	v := m.addh
	if v == nil {
		return
	}
	return *v, true
}

// ResetH resets all changes to the "h" field.
func (m *StatsHourlyCarMutation) ResetH() {
	m.h = nil
	m.addh = nil
}

// SetWeek sets the "week" field.
func (m *StatsHourlyCarMutation) SetWeek(i int) {
	m.week = &i
	m.addweek = nil
}

// Week returns the value of the "week" field in the mutation.
func (m *StatsHourlyCarMutation) Week() (r int, exists bool) {
	v := m.week
	if v == nil {
		return
	}
	return *v, true
}

// OldWeek returns the old "week" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldWeek(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeek: %w", err)
	}
	return oldValue.Week, nil
}

// AddWeek adds i to the "week" field.
func (m *StatsHourlyCarMutation) AddWeek(i int) {
	if m.addweek != nil {
		*m.addweek += i
	} else {
		m.addweek = &i
	}
}

// AddedWeek returns the value that was added to the "week" field in this mutation.
func (m *StatsHourlyCarMutation) AddedWeek() (r int, exists bool) {
	v := m.addweek
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeek resets all changes to the "week" field.
func (m *StatsHourlyCarMutation) ResetWeek() {
	m.week = nil
	m.addweek = nil
}

// SetWeekday sets the "weekday" field.
func (m *StatsHourlyCarMutation) SetWeekday(i int) {
	m.weekday = &i
	m.addweekday = nil
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *StatsHourlyCarMutation) Weekday() (r int, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldWeekday(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// AddWeekday adds i to the "weekday" field.
func (m *StatsHourlyCarMutation) AddWeekday(i int) {
	if m.addweekday != nil {
		*m.addweekday += i
	} else {
		m.addweekday = &i
	}
}

// AddedWeekday returns the value that was added to the "weekday" field in this mutation.
func (m *StatsHourlyCarMutation) AddedWeekday() (r int, exists bool) {
	v := m.addweekday
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *StatsHourlyCarMutation) ResetWeekday() {
	m.weekday = nil
	m.addweekday = nil
}

// SetPeriod sets the "period" field.
func (m *StatsHourlyCarMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *StatsHourlyCarMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *StatsHourlyCarMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *StatsHourlyCarMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *StatsHourlyCarMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetOrderCountCreate sets the "order_count_create" field.
func (m *StatsHourlyCarMutation) SetOrderCountCreate(i int) {
	m.order_count_create = &i
	m.addorder_count_create = nil
}

// OrderCountCreate returns the value of the "order_count_create" field in the mutation.
func (m *StatsHourlyCarMutation) OrderCountCreate() (r int, exists bool) {
	v := m.order_count_create
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCreate returns the old "order_count_create" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderCountCreate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCreate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCreate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCreate: %w", err)
	}
	return oldValue.OrderCountCreate, nil
}

// AddOrderCountCreate adds i to the "order_count_create" field.
func (m *StatsHourlyCarMutation) AddOrderCountCreate(i int) {
	if m.addorder_count_create != nil {
		*m.addorder_count_create += i
	} else {
		m.addorder_count_create = &i
	}
}

// AddedOrderCountCreate returns the value that was added to the "order_count_create" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderCountCreate() (r int, exists bool) {
	v := m.addorder_count_create
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCreate resets all changes to the "order_count_create" field.
func (m *StatsHourlyCarMutation) ResetOrderCountCreate() {
	m.order_count_create = nil
	m.addorder_count_create = nil
}

// SetOrderCountFinish sets the "order_count_finish" field.
func (m *StatsHourlyCarMutation) SetOrderCountFinish(i int) {
	m.order_count_finish = &i
	m.addorder_count_finish = nil
}

// OrderCountFinish returns the value of the "order_count_finish" field in the mutation.
func (m *StatsHourlyCarMutation) OrderCountFinish() (r int, exists bool) {
	v := m.order_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountFinish returns the old "order_count_finish" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderCountFinish(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountFinish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountFinish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountFinish: %w", err)
	}
	return oldValue.OrderCountFinish, nil
}

// AddOrderCountFinish adds i to the "order_count_finish" field.
func (m *StatsHourlyCarMutation) AddOrderCountFinish(i int) {
	if m.addorder_count_finish != nil {
		*m.addorder_count_finish += i
	} else {
		m.addorder_count_finish = &i
	}
}

// AddedOrderCountFinish returns the value that was added to the "order_count_finish" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderCountFinish() (r int, exists bool) {
	v := m.addorder_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountFinish resets all changes to the "order_count_finish" field.
func (m *StatsHourlyCarMutation) ResetOrderCountFinish() {
	m.order_count_finish = nil
	m.addorder_count_finish = nil
}

// SetOrderCountCancel sets the "order_count_cancel" field.
func (m *StatsHourlyCarMutation) SetOrderCountCancel(i int) {
	m.order_count_cancel = &i
	m.addorder_count_cancel = nil
}

// OrderCountCancel returns the value of the "order_count_cancel" field in the mutation.
func (m *StatsHourlyCarMutation) OrderCountCancel() (r int, exists bool) {
	v := m.order_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCancel returns the old "order_count_cancel" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderCountCancel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCancel: %w", err)
	}
	return oldValue.OrderCountCancel, nil
}

// AddOrderCountCancel adds i to the "order_count_cancel" field.
func (m *StatsHourlyCarMutation) AddOrderCountCancel(i int) {
	if m.addorder_count_cancel != nil {
		*m.addorder_count_cancel += i
	} else {
		m.addorder_count_cancel = &i
	}
}

// AddedOrderCountCancel returns the value that was added to the "order_count_cancel" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderCountCancel() (r int, exists bool) {
	v := m.addorder_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCancel resets all changes to the "order_count_cancel" field.
func (m *StatsHourlyCarMutation) ResetOrderCountCancel() {
	m.order_count_cancel = nil
	m.addorder_count_cancel = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *StatsHourlyCarMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *StatsHourlyCarMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *StatsHourlyCarMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *StatsHourlyCarMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderDuration sets the "order_duration" field.
func (m *StatsHourlyCarMutation) SetOrderDuration(i int) {
	m.order_duration = &i
	m.addorder_duration = nil
}

// OrderDuration returns the value of the "order_duration" field in the mutation.
func (m *StatsHourlyCarMutation) OrderDuration() (r int, exists bool) {
	v := m.order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDuration returns the old "order_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDuration: %w", err)
	}
	return oldValue.OrderDuration, nil
}

// AddOrderDuration adds i to the "order_duration" field.
func (m *StatsHourlyCarMutation) AddOrderDuration(i int) {
	if m.addorder_duration != nil {
		*m.addorder_duration += i
	} else {
		m.addorder_duration = &i
	}
}

// AddedOrderDuration returns the value that was added to the "order_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderDuration() (r int, exists bool) {
	v := m.addorder_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDuration resets all changes to the "order_duration" field.
func (m *StatsHourlyCarMutation) ResetOrderDuration() {
	m.order_duration = nil
	m.addorder_duration = nil
}

// SetOrderMileage sets the "order_mileage" field.
func (m *StatsHourlyCarMutation) SetOrderMileage(i int) {
	m.order_mileage = &i
	m.addorder_mileage = nil
}

// OrderMileage returns the value of the "order_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) OrderMileage() (r int, exists bool) {
	v := m.order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMileage returns the old "order_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderMileage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMileage: %w", err)
	}
	return oldValue.OrderMileage, nil
}

// AddOrderMileage adds i to the "order_mileage" field.
func (m *StatsHourlyCarMutation) AddOrderMileage(i int) {
	if m.addorder_mileage != nil {
		*m.addorder_mileage += i
	} else {
		m.addorder_mileage = &i
	}
}

// AddedOrderMileage returns the value that was added to the "order_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderMileage() (r int, exists bool) {
	v := m.addorder_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderMileage resets all changes to the "order_mileage" field.
func (m *StatsHourlyCarMutation) ResetOrderMileage() {
	m.order_mileage = nil
	m.addorder_mileage = nil
}

// SetOrderScore sets the "order_score" field.
func (m *StatsHourlyCarMutation) SetOrderScore(i int) {
	m.order_score = &i
	m.addorder_score = nil
}

// OrderScore returns the value of the "order_score" field in the mutation.
func (m *StatsHourlyCarMutation) OrderScore() (r int, exists bool) {
	v := m.order_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderScore returns the old "order_score" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOrderScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderScore: %w", err)
	}
	return oldValue.OrderScore, nil
}

// AddOrderScore adds i to the "order_score" field.
func (m *StatsHourlyCarMutation) AddOrderScore(i int) {
	if m.addorder_score != nil {
		*m.addorder_score += i
	} else {
		m.addorder_score = &i
	}
}

// AddedOrderScore returns the value that was added to the "order_score" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOrderScore() (r int, exists bool) {
	v := m.addorder_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderScore resets all changes to the "order_score" field.
func (m *StatsHourlyCarMutation) ResetOrderScore() {
	m.order_score = nil
	m.addorder_score = nil
}

// SetCumulativeOperationLockDuration sets the "cumulative_operation_lock_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationLockDuration(f float32) {
	m.cumulative_operation_lock_duration = &f
	m.addcumulative_operation_lock_duration = nil
}

// CumulativeOperationLockDuration returns the value of the "cumulative_operation_lock_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationLockDuration() (r float32, exists bool) {
	v := m.cumulative_operation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationLockDuration returns the old "cumulative_operation_lock_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationLockDuration: %w", err)
	}
	return oldValue.CumulativeOperationLockDuration, nil
}

// AddCumulativeOperationLockDuration adds f to the "cumulative_operation_lock_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationLockDuration(f float32) {
	if m.addcumulative_operation_lock_duration != nil {
		*m.addcumulative_operation_lock_duration += f
	} else {
		m.addcumulative_operation_lock_duration = &f
	}
}

// AddedCumulativeOperationLockDuration returns the value that was added to the "cumulative_operation_lock_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationLockDuration() (r float32, exists bool) {
	v := m.addcumulative_operation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationLockDuration resets all changes to the "cumulative_operation_lock_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationLockDuration() {
	m.cumulative_operation_lock_duration = nil
	m.addcumulative_operation_lock_duration = nil
}

// SetCumulativeOperationManualDuration sets the "cumulative_operation_manual_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationManualDuration(f float32) {
	m.cumulative_operation_manual_duration = &f
	m.addcumulative_operation_manual_duration = nil
}

// CumulativeOperationManualDuration returns the value of the "cumulative_operation_manual_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationManualDuration() (r float32, exists bool) {
	v := m.cumulative_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationManualDuration returns the old "cumulative_operation_manual_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationManualDuration: %w", err)
	}
	return oldValue.CumulativeOperationManualDuration, nil
}

// AddCumulativeOperationManualDuration adds f to the "cumulative_operation_manual_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationManualDuration(f float32) {
	if m.addcumulative_operation_manual_duration != nil {
		*m.addcumulative_operation_manual_duration += f
	} else {
		m.addcumulative_operation_manual_duration = &f
	}
}

// AddedCumulativeOperationManualDuration returns the value that was added to the "cumulative_operation_manual_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationManualDuration() (r float32, exists bool) {
	v := m.addcumulative_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationManualDuration resets all changes to the "cumulative_operation_manual_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationManualDuration() {
	m.cumulative_operation_manual_duration = nil
	m.addcumulative_operation_manual_duration = nil
}

// SetCumulativeOperationAutoDuration sets the "cumulative_operation_auto_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationAutoDuration(f float32) {
	m.cumulative_operation_auto_duration = &f
	m.addcumulative_operation_auto_duration = nil
}

// CumulativeOperationAutoDuration returns the value of the "cumulative_operation_auto_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationAutoDuration() (r float32, exists bool) {
	v := m.cumulative_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationAutoDuration returns the old "cumulative_operation_auto_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationAutoDuration: %w", err)
	}
	return oldValue.CumulativeOperationAutoDuration, nil
}

// AddCumulativeOperationAutoDuration adds f to the "cumulative_operation_auto_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationAutoDuration(f float32) {
	if m.addcumulative_operation_auto_duration != nil {
		*m.addcumulative_operation_auto_duration += f
	} else {
		m.addcumulative_operation_auto_duration = &f
	}
}

// AddedCumulativeOperationAutoDuration returns the value that was added to the "cumulative_operation_auto_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationAutoDuration() (r float32, exists bool) {
	v := m.addcumulative_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationAutoDuration resets all changes to the "cumulative_operation_auto_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationAutoDuration() {
	m.cumulative_operation_auto_duration = nil
	m.addcumulative_operation_auto_duration = nil
}

// SetCumulativeOperationFaultDuration sets the "cumulative_operation_fault_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationFaultDuration(f float32) {
	m.cumulative_operation_fault_duration = &f
	m.addcumulative_operation_fault_duration = nil
}

// CumulativeOperationFaultDuration returns the value of the "cumulative_operation_fault_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationFaultDuration() (r float32, exists bool) {
	v := m.cumulative_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationFaultDuration returns the old "cumulative_operation_fault_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationFaultDuration: %w", err)
	}
	return oldValue.CumulativeOperationFaultDuration, nil
}

// AddCumulativeOperationFaultDuration adds f to the "cumulative_operation_fault_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationFaultDuration(f float32) {
	if m.addcumulative_operation_fault_duration != nil {
		*m.addcumulative_operation_fault_duration += f
	} else {
		m.addcumulative_operation_fault_duration = &f
	}
}

// AddedCumulativeOperationFaultDuration returns the value that was added to the "cumulative_operation_fault_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationFaultDuration() (r float32, exists bool) {
	v := m.addcumulative_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationFaultDuration resets all changes to the "cumulative_operation_fault_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationFaultDuration() {
	m.cumulative_operation_fault_duration = nil
	m.addcumulative_operation_fault_duration = nil
}

// SetCumulativeOperationLockTimes sets the "cumulative_operation_lock_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationLockTimes(u uint32) {
	m.cumulative_operation_lock_times = &u
	m.addcumulative_operation_lock_times = nil
}

// CumulativeOperationLockTimes returns the value of the "cumulative_operation_lock_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationLockTimes() (r uint32, exists bool) {
	v := m.cumulative_operation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationLockTimes returns the old "cumulative_operation_lock_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationLockTimes: %w", err)
	}
	return oldValue.CumulativeOperationLockTimes, nil
}

// AddCumulativeOperationLockTimes adds u to the "cumulative_operation_lock_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationLockTimes(u int32) {
	if m.addcumulative_operation_lock_times != nil {
		*m.addcumulative_operation_lock_times += u
	} else {
		m.addcumulative_operation_lock_times = &u
	}
}

// AddedCumulativeOperationLockTimes returns the value that was added to the "cumulative_operation_lock_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationLockTimes() (r int32, exists bool) {
	v := m.addcumulative_operation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationLockTimes resets all changes to the "cumulative_operation_lock_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationLockTimes() {
	m.cumulative_operation_lock_times = nil
	m.addcumulative_operation_lock_times = nil
}

// SetCumulativeOperationManualTimes sets the "cumulative_operation_manual_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationManualTimes(u uint32) {
	m.cumulative_operation_manual_times = &u
	m.addcumulative_operation_manual_times = nil
}

// CumulativeOperationManualTimes returns the value of the "cumulative_operation_manual_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationManualTimes() (r uint32, exists bool) {
	v := m.cumulative_operation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationManualTimes returns the old "cumulative_operation_manual_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationManualTimes: %w", err)
	}
	return oldValue.CumulativeOperationManualTimes, nil
}

// AddCumulativeOperationManualTimes adds u to the "cumulative_operation_manual_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationManualTimes(u int32) {
	if m.addcumulative_operation_manual_times != nil {
		*m.addcumulative_operation_manual_times += u
	} else {
		m.addcumulative_operation_manual_times = &u
	}
}

// AddedCumulativeOperationManualTimes returns the value that was added to the "cumulative_operation_manual_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationManualTimes() (r int32, exists bool) {
	v := m.addcumulative_operation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationManualTimes resets all changes to the "cumulative_operation_manual_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationManualTimes() {
	m.cumulative_operation_manual_times = nil
	m.addcumulative_operation_manual_times = nil
}

// SetCumulativeOperationAutoTimes sets the "cumulative_operation_auto_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationAutoTimes(u uint32) {
	m.cumulative_operation_auto_times = &u
	m.addcumulative_operation_auto_times = nil
}

// CumulativeOperationAutoTimes returns the value of the "cumulative_operation_auto_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationAutoTimes() (r uint32, exists bool) {
	v := m.cumulative_operation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationAutoTimes returns the old "cumulative_operation_auto_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationAutoTimes: %w", err)
	}
	return oldValue.CumulativeOperationAutoTimes, nil
}

// AddCumulativeOperationAutoTimes adds u to the "cumulative_operation_auto_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationAutoTimes(u int32) {
	if m.addcumulative_operation_auto_times != nil {
		*m.addcumulative_operation_auto_times += u
	} else {
		m.addcumulative_operation_auto_times = &u
	}
}

// AddedCumulativeOperationAutoTimes returns the value that was added to the "cumulative_operation_auto_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationAutoTimes() (r int32, exists bool) {
	v := m.addcumulative_operation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationAutoTimes resets all changes to the "cumulative_operation_auto_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationAutoTimes() {
	m.cumulative_operation_auto_times = nil
	m.addcumulative_operation_auto_times = nil
}

// SetCumulativeOperationFaultTimes sets the "cumulative_operation_fault_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationFaultTimes(u uint32) {
	m.cumulative_operation_fault_times = &u
	m.addcumulative_operation_fault_times = nil
}

// CumulativeOperationFaultTimes returns the value of the "cumulative_operation_fault_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationFaultTimes() (r uint32, exists bool) {
	v := m.cumulative_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationFaultTimes returns the old "cumulative_operation_fault_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationFaultTimes: %w", err)
	}
	return oldValue.CumulativeOperationFaultTimes, nil
}

// AddCumulativeOperationFaultTimes adds u to the "cumulative_operation_fault_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationFaultTimes(u int32) {
	if m.addcumulative_operation_fault_times != nil {
		*m.addcumulative_operation_fault_times += u
	} else {
		m.addcumulative_operation_fault_times = &u
	}
}

// AddedCumulativeOperationFaultTimes returns the value that was added to the "cumulative_operation_fault_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationFaultTimes() (r int32, exists bool) {
	v := m.addcumulative_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationFaultTimes resets all changes to the "cumulative_operation_fault_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationFaultTimes() {
	m.cumulative_operation_fault_times = nil
	m.addcumulative_operation_fault_times = nil
}

// SetCumulativeOperationManualMileage sets the "cumulative_operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationManualMileage(f float32) {
	m.cumulative_operation_manual_mileage = &f
	m.addcumulative_operation_manual_mileage = nil
}

// CumulativeOperationManualMileage returns the value of the "cumulative_operation_manual_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationManualMileage() (r float32, exists bool) {
	v := m.cumulative_operation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationManualMileage returns the old "cumulative_operation_manual_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationManualMileage: %w", err)
	}
	return oldValue.CumulativeOperationManualMileage, nil
}

// AddCumulativeOperationManualMileage adds f to the "cumulative_operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationManualMileage(f float32) {
	if m.addcumulative_operation_manual_mileage != nil {
		*m.addcumulative_operation_manual_mileage += f
	} else {
		m.addcumulative_operation_manual_mileage = &f
	}
}

// AddedCumulativeOperationManualMileage returns the value that was added to the "cumulative_operation_manual_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationManualMileage() (r float32, exists bool) {
	v := m.addcumulative_operation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationManualMileage resets all changes to the "cumulative_operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationManualMileage() {
	m.cumulative_operation_manual_mileage = nil
	m.addcumulative_operation_manual_mileage = nil
}

// SetCumulativeOperationAutoMileage sets the "cumulative_operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) SetCumulativeOperationAutoMileage(f float32) {
	m.cumulative_operation_auto_mileage = &f
	m.addcumulative_operation_auto_mileage = nil
}

// CumulativeOperationAutoMileage returns the value of the "cumulative_operation_auto_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeOperationAutoMileage() (r float32, exists bool) {
	v := m.cumulative_operation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeOperationAutoMileage returns the old "cumulative_operation_auto_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeOperationAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeOperationAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeOperationAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeOperationAutoMileage: %w", err)
	}
	return oldValue.CumulativeOperationAutoMileage, nil
}

// AddCumulativeOperationAutoMileage adds f to the "cumulative_operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) AddCumulativeOperationAutoMileage(f float32) {
	if m.addcumulative_operation_auto_mileage != nil {
		*m.addcumulative_operation_auto_mileage += f
	} else {
		m.addcumulative_operation_auto_mileage = &f
	}
}

// AddedCumulativeOperationAutoMileage returns the value that was added to the "cumulative_operation_auto_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeOperationAutoMileage() (r float32, exists bool) {
	v := m.addcumulative_operation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeOperationAutoMileage resets all changes to the "cumulative_operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) ResetCumulativeOperationAutoMileage() {
	m.cumulative_operation_auto_mileage = nil
	m.addcumulative_operation_auto_mileage = nil
}

// SetCumulativeMaintainLockDuration sets the "cumulative_maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainLockDuration(f float32) {
	m.cumulative_maintain_lock_duration = &f
	m.addcumulative_maintain_lock_duration = nil
}

// CumulativeMaintainLockDuration returns the value of the "cumulative_maintain_lock_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainLockDuration() (r float32, exists bool) {
	v := m.cumulative_maintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainLockDuration returns the old "cumulative_maintain_lock_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainLockDuration: %w", err)
	}
	return oldValue.CumulativeMaintainLockDuration, nil
}

// AddCumulativeMaintainLockDuration adds f to the "cumulative_maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainLockDuration(f float32) {
	if m.addcumulative_maintain_lock_duration != nil {
		*m.addcumulative_maintain_lock_duration += f
	} else {
		m.addcumulative_maintain_lock_duration = &f
	}
}

// AddedCumulativeMaintainLockDuration returns the value that was added to the "cumulative_maintain_lock_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainLockDuration() (r float32, exists bool) {
	v := m.addcumulative_maintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainLockDuration resets all changes to the "cumulative_maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainLockDuration() {
	m.cumulative_maintain_lock_duration = nil
	m.addcumulative_maintain_lock_duration = nil
}

// SetCumulativeMaintainManualDuration sets the "cumulative_maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainManualDuration(f float32) {
	m.cumulative_maintain_manual_duration = &f
	m.addcumulative_maintain_manual_duration = nil
}

// CumulativeMaintainManualDuration returns the value of the "cumulative_maintain_manual_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainManualDuration() (r float32, exists bool) {
	v := m.cumulative_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainManualDuration returns the old "cumulative_maintain_manual_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainManualDuration: %w", err)
	}
	return oldValue.CumulativeMaintainManualDuration, nil
}

// AddCumulativeMaintainManualDuration adds f to the "cumulative_maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainManualDuration(f float32) {
	if m.addcumulative_maintain_manual_duration != nil {
		*m.addcumulative_maintain_manual_duration += f
	} else {
		m.addcumulative_maintain_manual_duration = &f
	}
}

// AddedCumulativeMaintainManualDuration returns the value that was added to the "cumulative_maintain_manual_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainManualDuration() (r float32, exists bool) {
	v := m.addcumulative_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainManualDuration resets all changes to the "cumulative_maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainManualDuration() {
	m.cumulative_maintain_manual_duration = nil
	m.addcumulative_maintain_manual_duration = nil
}

// SetCumulativeMaintainAutoDuration sets the "cumulative_maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainAutoDuration(f float32) {
	m.cumulative_maintain_auto_duration = &f
	m.addcumulative_maintain_auto_duration = nil
}

// CumulativeMaintainAutoDuration returns the value of the "cumulative_maintain_auto_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainAutoDuration() (r float32, exists bool) {
	v := m.cumulative_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainAutoDuration returns the old "cumulative_maintain_auto_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainAutoDuration: %w", err)
	}
	return oldValue.CumulativeMaintainAutoDuration, nil
}

// AddCumulativeMaintainAutoDuration adds f to the "cumulative_maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainAutoDuration(f float32) {
	if m.addcumulative_maintain_auto_duration != nil {
		*m.addcumulative_maintain_auto_duration += f
	} else {
		m.addcumulative_maintain_auto_duration = &f
	}
}

// AddedCumulativeMaintainAutoDuration returns the value that was added to the "cumulative_maintain_auto_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainAutoDuration() (r float32, exists bool) {
	v := m.addcumulative_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainAutoDuration resets all changes to the "cumulative_maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainAutoDuration() {
	m.cumulative_maintain_auto_duration = nil
	m.addcumulative_maintain_auto_duration = nil
}

// SetCumulativeMaintainRemoteDuration sets the "cumulative_maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainRemoteDuration(f float32) {
	m.cumulative_maintain_remote_duration = &f
	m.addcumulative_maintain_remote_duration = nil
}

// CumulativeMaintainRemoteDuration returns the value of the "cumulative_maintain_remote_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainRemoteDuration() (r float32, exists bool) {
	v := m.cumulative_maintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainRemoteDuration returns the old "cumulative_maintain_remote_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainRemoteDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainRemoteDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainRemoteDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainRemoteDuration: %w", err)
	}
	return oldValue.CumulativeMaintainRemoteDuration, nil
}

// AddCumulativeMaintainRemoteDuration adds f to the "cumulative_maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainRemoteDuration(f float32) {
	if m.addcumulative_maintain_remote_duration != nil {
		*m.addcumulative_maintain_remote_duration += f
	} else {
		m.addcumulative_maintain_remote_duration = &f
	}
}

// AddedCumulativeMaintainRemoteDuration returns the value that was added to the "cumulative_maintain_remote_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainRemoteDuration() (r float32, exists bool) {
	v := m.addcumulative_maintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainRemoteDuration resets all changes to the "cumulative_maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainRemoteDuration() {
	m.cumulative_maintain_remote_duration = nil
	m.addcumulative_maintain_remote_duration = nil
}

// SetCumulativeMaintainFaultDuration sets the "cumulative_maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainFaultDuration(f float32) {
	m.cumulative_maintain_fault_duration = &f
	m.addcumulative_maintain_fault_duration = nil
}

// CumulativeMaintainFaultDuration returns the value of the "cumulative_maintain_fault_duration" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainFaultDuration() (r float32, exists bool) {
	v := m.cumulative_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainFaultDuration returns the old "cumulative_maintain_fault_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainFaultDuration: %w", err)
	}
	return oldValue.CumulativeMaintainFaultDuration, nil
}

// AddCumulativeMaintainFaultDuration adds f to the "cumulative_maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainFaultDuration(f float32) {
	if m.addcumulative_maintain_fault_duration != nil {
		*m.addcumulative_maintain_fault_duration += f
	} else {
		m.addcumulative_maintain_fault_duration = &f
	}
}

// AddedCumulativeMaintainFaultDuration returns the value that was added to the "cumulative_maintain_fault_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainFaultDuration() (r float32, exists bool) {
	v := m.addcumulative_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainFaultDuration resets all changes to the "cumulative_maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainFaultDuration() {
	m.cumulative_maintain_fault_duration = nil
	m.addcumulative_maintain_fault_duration = nil
}

// SetCumulativeMaintainLockTimes sets the "cumulative_maintain_lock_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainLockTimes(u uint32) {
	m.cumulative_maintain_lock_times = &u
	m.addcumulative_maintain_lock_times = nil
}

// CumulativeMaintainLockTimes returns the value of the "cumulative_maintain_lock_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainLockTimes() (r uint32, exists bool) {
	v := m.cumulative_maintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainLockTimes returns the old "cumulative_maintain_lock_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainLockTimes: %w", err)
	}
	return oldValue.CumulativeMaintainLockTimes, nil
}

// AddCumulativeMaintainLockTimes adds u to the "cumulative_maintain_lock_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainLockTimes(u int32) {
	if m.addcumulative_maintain_lock_times != nil {
		*m.addcumulative_maintain_lock_times += u
	} else {
		m.addcumulative_maintain_lock_times = &u
	}
}

// AddedCumulativeMaintainLockTimes returns the value that was added to the "cumulative_maintain_lock_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainLockTimes() (r int32, exists bool) {
	v := m.addcumulative_maintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainLockTimes resets all changes to the "cumulative_maintain_lock_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainLockTimes() {
	m.cumulative_maintain_lock_times = nil
	m.addcumulative_maintain_lock_times = nil
}

// SetCumulativeMaintainManualTimes sets the "cumulative_maintain_manual_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainManualTimes(u uint32) {
	m.cumulative_maintain_manual_times = &u
	m.addcumulative_maintain_manual_times = nil
}

// CumulativeMaintainManualTimes returns the value of the "cumulative_maintain_manual_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainManualTimes() (r uint32, exists bool) {
	v := m.cumulative_maintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainManualTimes returns the old "cumulative_maintain_manual_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainManualTimes: %w", err)
	}
	return oldValue.CumulativeMaintainManualTimes, nil
}

// AddCumulativeMaintainManualTimes adds u to the "cumulative_maintain_manual_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainManualTimes(u int32) {
	if m.addcumulative_maintain_manual_times != nil {
		*m.addcumulative_maintain_manual_times += u
	} else {
		m.addcumulative_maintain_manual_times = &u
	}
}

// AddedCumulativeMaintainManualTimes returns the value that was added to the "cumulative_maintain_manual_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainManualTimes() (r int32, exists bool) {
	v := m.addcumulative_maintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainManualTimes resets all changes to the "cumulative_maintain_manual_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainManualTimes() {
	m.cumulative_maintain_manual_times = nil
	m.addcumulative_maintain_manual_times = nil
}

// SetCumulativeMaintainAutoTimes sets the "cumulative_maintain_auto_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainAutoTimes(u uint32) {
	m.cumulative_maintain_auto_times = &u
	m.addcumulative_maintain_auto_times = nil
}

// CumulativeMaintainAutoTimes returns the value of the "cumulative_maintain_auto_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainAutoTimes() (r uint32, exists bool) {
	v := m.cumulative_maintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainAutoTimes returns the old "cumulative_maintain_auto_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainAutoTimes: %w", err)
	}
	return oldValue.CumulativeMaintainAutoTimes, nil
}

// AddCumulativeMaintainAutoTimes adds u to the "cumulative_maintain_auto_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainAutoTimes(u int32) {
	if m.addcumulative_maintain_auto_times != nil {
		*m.addcumulative_maintain_auto_times += u
	} else {
		m.addcumulative_maintain_auto_times = &u
	}
}

// AddedCumulativeMaintainAutoTimes returns the value that was added to the "cumulative_maintain_auto_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainAutoTimes() (r int32, exists bool) {
	v := m.addcumulative_maintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainAutoTimes resets all changes to the "cumulative_maintain_auto_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainAutoTimes() {
	m.cumulative_maintain_auto_times = nil
	m.addcumulative_maintain_auto_times = nil
}

// SetCumulativeMaintainRemoteTimes sets the "cumulative_maintain_remote_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainRemoteTimes(u uint32) {
	m.cumulative_maintain_remote_times = &u
	m.addcumulative_maintain_remote_times = nil
}

// CumulativeMaintainRemoteTimes returns the value of the "cumulative_maintain_remote_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainRemoteTimes() (r uint32, exists bool) {
	v := m.cumulative_maintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainRemoteTimes returns the old "cumulative_maintain_remote_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainRemoteTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainRemoteTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainRemoteTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainRemoteTimes: %w", err)
	}
	return oldValue.CumulativeMaintainRemoteTimes, nil
}

// AddCumulativeMaintainRemoteTimes adds u to the "cumulative_maintain_remote_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainRemoteTimes(u int32) {
	if m.addcumulative_maintain_remote_times != nil {
		*m.addcumulative_maintain_remote_times += u
	} else {
		m.addcumulative_maintain_remote_times = &u
	}
}

// AddedCumulativeMaintainRemoteTimes returns the value that was added to the "cumulative_maintain_remote_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainRemoteTimes() (r int32, exists bool) {
	v := m.addcumulative_maintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainRemoteTimes resets all changes to the "cumulative_maintain_remote_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainRemoteTimes() {
	m.cumulative_maintain_remote_times = nil
	m.addcumulative_maintain_remote_times = nil
}

// SetCumulativeMaintainFaultTimes sets the "cumulative_maintain_fault_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainFaultTimes(u uint32) {
	m.cumulative_maintain_fault_times = &u
	m.addcumulative_maintain_fault_times = nil
}

// CumulativeMaintainFaultTimes returns the value of the "cumulative_maintain_fault_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainFaultTimes() (r uint32, exists bool) {
	v := m.cumulative_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainFaultTimes returns the old "cumulative_maintain_fault_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainFaultTimes: %w", err)
	}
	return oldValue.CumulativeMaintainFaultTimes, nil
}

// AddCumulativeMaintainFaultTimes adds u to the "cumulative_maintain_fault_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainFaultTimes(u int32) {
	if m.addcumulative_maintain_fault_times != nil {
		*m.addcumulative_maintain_fault_times += u
	} else {
		m.addcumulative_maintain_fault_times = &u
	}
}

// AddedCumulativeMaintainFaultTimes returns the value that was added to the "cumulative_maintain_fault_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainFaultTimes() (r int32, exists bool) {
	v := m.addcumulative_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainFaultTimes resets all changes to the "cumulative_maintain_fault_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainFaultTimes() {
	m.cumulative_maintain_fault_times = nil
	m.addcumulative_maintain_fault_times = nil
}

// SetCumulativeMaintainManualMileage sets the "cumulative_maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainManualMileage(f float32) {
	m.cumulative_maintain_manual_mileage = &f
	m.addcumulative_maintain_manual_mileage = nil
}

// CumulativeMaintainManualMileage returns the value of the "cumulative_maintain_manual_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainManualMileage() (r float32, exists bool) {
	v := m.cumulative_maintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainManualMileage returns the old "cumulative_maintain_manual_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainManualMileage: %w", err)
	}
	return oldValue.CumulativeMaintainManualMileage, nil
}

// AddCumulativeMaintainManualMileage adds f to the "cumulative_maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainManualMileage(f float32) {
	if m.addcumulative_maintain_manual_mileage != nil {
		*m.addcumulative_maintain_manual_mileage += f
	} else {
		m.addcumulative_maintain_manual_mileage = &f
	}
}

// AddedCumulativeMaintainManualMileage returns the value that was added to the "cumulative_maintain_manual_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainManualMileage() (r float32, exists bool) {
	v := m.addcumulative_maintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainManualMileage resets all changes to the "cumulative_maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainManualMileage() {
	m.cumulative_maintain_manual_mileage = nil
	m.addcumulative_maintain_manual_mileage = nil
}

// SetCumulativeMaintainAutoMileage sets the "cumulative_maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainAutoMileage(f float32) {
	m.cumulative_maintain_auto_mileage = &f
	m.addcumulative_maintain_auto_mileage = nil
}

// CumulativeMaintainAutoMileage returns the value of the "cumulative_maintain_auto_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainAutoMileage() (r float32, exists bool) {
	v := m.cumulative_maintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainAutoMileage returns the old "cumulative_maintain_auto_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainAutoMileage: %w", err)
	}
	return oldValue.CumulativeMaintainAutoMileage, nil
}

// AddCumulativeMaintainAutoMileage adds f to the "cumulative_maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainAutoMileage(f float32) {
	if m.addcumulative_maintain_auto_mileage != nil {
		*m.addcumulative_maintain_auto_mileage += f
	} else {
		m.addcumulative_maintain_auto_mileage = &f
	}
}

// AddedCumulativeMaintainAutoMileage returns the value that was added to the "cumulative_maintain_auto_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainAutoMileage() (r float32, exists bool) {
	v := m.addcumulative_maintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainAutoMileage resets all changes to the "cumulative_maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainAutoMileage() {
	m.cumulative_maintain_auto_mileage = nil
	m.addcumulative_maintain_auto_mileage = nil
}

// SetCumulativeMaintainRemoteMileage sets the "cumulative_maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) SetCumulativeMaintainRemoteMileage(f float32) {
	m.cumulative_maintain_remote_mileage = &f
	m.addcumulative_maintain_remote_mileage = nil
}

// CumulativeMaintainRemoteMileage returns the value of the "cumulative_maintain_remote_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeMaintainRemoteMileage() (r float32, exists bool) {
	v := m.cumulative_maintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeMaintainRemoteMileage returns the old "cumulative_maintain_remote_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeMaintainRemoteMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeMaintainRemoteMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeMaintainRemoteMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeMaintainRemoteMileage: %w", err)
	}
	return oldValue.CumulativeMaintainRemoteMileage, nil
}

// AddCumulativeMaintainRemoteMileage adds f to the "cumulative_maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) AddCumulativeMaintainRemoteMileage(f float32) {
	if m.addcumulative_maintain_remote_mileage != nil {
		*m.addcumulative_maintain_remote_mileage += f
	} else {
		m.addcumulative_maintain_remote_mileage = &f
	}
}

// AddedCumulativeMaintainRemoteMileage returns the value that was added to the "cumulative_maintain_remote_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeMaintainRemoteMileage() (r float32, exists bool) {
	v := m.addcumulative_maintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeMaintainRemoteMileage resets all changes to the "cumulative_maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) ResetCumulativeMaintainRemoteMileage() {
	m.cumulative_maintain_remote_mileage = nil
	m.addcumulative_maintain_remote_mileage = nil
}

// SetCumulativeAlarmTimes sets the "cumulative_alarm_times" field.
func (m *StatsHourlyCarMutation) SetCumulativeAlarmTimes(u uint32) {
	m.cumulative_alarm_times = &u
	m.addcumulative_alarm_times = nil
}

// CumulativeAlarmTimes returns the value of the "cumulative_alarm_times" field in the mutation.
func (m *StatsHourlyCarMutation) CumulativeAlarmTimes() (r uint32, exists bool) {
	v := m.cumulative_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCumulativeAlarmTimes returns the old "cumulative_alarm_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCumulativeAlarmTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCumulativeAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCumulativeAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCumulativeAlarmTimes: %w", err)
	}
	return oldValue.CumulativeAlarmTimes, nil
}

// AddCumulativeAlarmTimes adds u to the "cumulative_alarm_times" field.
func (m *StatsHourlyCarMutation) AddCumulativeAlarmTimes(u int32) {
	if m.addcumulative_alarm_times != nil {
		*m.addcumulative_alarm_times += u
	} else {
		m.addcumulative_alarm_times = &u
	}
}

// AddedCumulativeAlarmTimes returns the value that was added to the "cumulative_alarm_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedCumulativeAlarmTimes() (r int32, exists bool) {
	v := m.addcumulative_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCumulativeAlarmTimes resets all changes to the "cumulative_alarm_times" field.
func (m *StatsHourlyCarMutation) ResetCumulativeAlarmTimes() {
	m.cumulative_alarm_times = nil
	m.addcumulative_alarm_times = nil
}

// SetOperationLockDuration sets the "operation_lock_duration" field.
func (m *StatsHourlyCarMutation) SetOperationLockDuration(f float32) {
	m.operation_lock_duration = &f
	m.addoperation_lock_duration = nil
}

// OperationLockDuration returns the value of the "operation_lock_duration" field in the mutation.
func (m *StatsHourlyCarMutation) OperationLockDuration() (r float32, exists bool) {
	v := m.operation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockDuration returns the old "operation_lock_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockDuration: %w", err)
	}
	return oldValue.OperationLockDuration, nil
}

// AddOperationLockDuration adds f to the "operation_lock_duration" field.
func (m *StatsHourlyCarMutation) AddOperationLockDuration(f float32) {
	if m.addoperation_lock_duration != nil {
		*m.addoperation_lock_duration += f
	} else {
		m.addoperation_lock_duration = &f
	}
}

// AddedOperationLockDuration returns the value that was added to the "operation_lock_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationLockDuration() (r float32, exists bool) {
	v := m.addoperation_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockDuration resets all changes to the "operation_lock_duration" field.
func (m *StatsHourlyCarMutation) ResetOperationLockDuration() {
	m.operation_lock_duration = nil
	m.addoperation_lock_duration = nil
}

// SetOperationManualDuration sets the "operation_manual_duration" field.
func (m *StatsHourlyCarMutation) SetOperationManualDuration(f float32) {
	m.operation_manual_duration = &f
	m.addoperation_manual_duration = nil
}

// OperationManualDuration returns the value of the "operation_manual_duration" field in the mutation.
func (m *StatsHourlyCarMutation) OperationManualDuration() (r float32, exists bool) {
	v := m.operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualDuration returns the old "operation_manual_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualDuration: %w", err)
	}
	return oldValue.OperationManualDuration, nil
}

// AddOperationManualDuration adds f to the "operation_manual_duration" field.
func (m *StatsHourlyCarMutation) AddOperationManualDuration(f float32) {
	if m.addoperation_manual_duration != nil {
		*m.addoperation_manual_duration += f
	} else {
		m.addoperation_manual_duration = &f
	}
}

// AddedOperationManualDuration returns the value that was added to the "operation_manual_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationManualDuration() (r float32, exists bool) {
	v := m.addoperation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualDuration resets all changes to the "operation_manual_duration" field.
func (m *StatsHourlyCarMutation) ResetOperationManualDuration() {
	m.operation_manual_duration = nil
	m.addoperation_manual_duration = nil
}

// SetOperationAutoDuration sets the "operation_auto_duration" field.
func (m *StatsHourlyCarMutation) SetOperationAutoDuration(f float32) {
	m.operation_auto_duration = &f
	m.addoperation_auto_duration = nil
}

// OperationAutoDuration returns the value of the "operation_auto_duration" field in the mutation.
func (m *StatsHourlyCarMutation) OperationAutoDuration() (r float32, exists bool) {
	v := m.operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoDuration returns the old "operation_auto_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoDuration: %w", err)
	}
	return oldValue.OperationAutoDuration, nil
}

// AddOperationAutoDuration adds f to the "operation_auto_duration" field.
func (m *StatsHourlyCarMutation) AddOperationAutoDuration(f float32) {
	if m.addoperation_auto_duration != nil {
		*m.addoperation_auto_duration += f
	} else {
		m.addoperation_auto_duration = &f
	}
}

// AddedOperationAutoDuration returns the value that was added to the "operation_auto_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationAutoDuration() (r float32, exists bool) {
	v := m.addoperation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoDuration resets all changes to the "operation_auto_duration" field.
func (m *StatsHourlyCarMutation) ResetOperationAutoDuration() {
	m.operation_auto_duration = nil
	m.addoperation_auto_duration = nil
}

// SetOperationFaultDuration sets the "operation_fault_duration" field.
func (m *StatsHourlyCarMutation) SetOperationFaultDuration(f float32) {
	m.operation_fault_duration = &f
	m.addoperation_fault_duration = nil
}

// OperationFaultDuration returns the value of the "operation_fault_duration" field in the mutation.
func (m *StatsHourlyCarMutation) OperationFaultDuration() (r float32, exists bool) {
	v := m.operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultDuration returns the old "operation_fault_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultDuration: %w", err)
	}
	return oldValue.OperationFaultDuration, nil
}

// AddOperationFaultDuration adds f to the "operation_fault_duration" field.
func (m *StatsHourlyCarMutation) AddOperationFaultDuration(f float32) {
	if m.addoperation_fault_duration != nil {
		*m.addoperation_fault_duration += f
	} else {
		m.addoperation_fault_duration = &f
	}
}

// AddedOperationFaultDuration returns the value that was added to the "operation_fault_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationFaultDuration() (r float32, exists bool) {
	v := m.addoperation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultDuration resets all changes to the "operation_fault_duration" field.
func (m *StatsHourlyCarMutation) ResetOperationFaultDuration() {
	m.operation_fault_duration = nil
	m.addoperation_fault_duration = nil
}

// SetOperationLockTimes sets the "operation_lock_times" field.
func (m *StatsHourlyCarMutation) SetOperationLockTimes(u uint32) {
	m.operation_lock_times = &u
	m.addoperation_lock_times = nil
}

// OperationLockTimes returns the value of the "operation_lock_times" field in the mutation.
func (m *StatsHourlyCarMutation) OperationLockTimes() (r uint32, exists bool) {
	v := m.operation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationLockTimes returns the old "operation_lock_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationLockTimes: %w", err)
	}
	return oldValue.OperationLockTimes, nil
}

// AddOperationLockTimes adds u to the "operation_lock_times" field.
func (m *StatsHourlyCarMutation) AddOperationLockTimes(u int32) {
	if m.addoperation_lock_times != nil {
		*m.addoperation_lock_times += u
	} else {
		m.addoperation_lock_times = &u
	}
}

// AddedOperationLockTimes returns the value that was added to the "operation_lock_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationLockTimes() (r int32, exists bool) {
	v := m.addoperation_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationLockTimes resets all changes to the "operation_lock_times" field.
func (m *StatsHourlyCarMutation) ResetOperationLockTimes() {
	m.operation_lock_times = nil
	m.addoperation_lock_times = nil
}

// SetOperationManualTimes sets the "operation_manual_times" field.
func (m *StatsHourlyCarMutation) SetOperationManualTimes(u uint32) {
	m.operation_manual_times = &u
	m.addoperation_manual_times = nil
}

// OperationManualTimes returns the value of the "operation_manual_times" field in the mutation.
func (m *StatsHourlyCarMutation) OperationManualTimes() (r uint32, exists bool) {
	v := m.operation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualTimes returns the old "operation_manual_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualTimes: %w", err)
	}
	return oldValue.OperationManualTimes, nil
}

// AddOperationManualTimes adds u to the "operation_manual_times" field.
func (m *StatsHourlyCarMutation) AddOperationManualTimes(u int32) {
	if m.addoperation_manual_times != nil {
		*m.addoperation_manual_times += u
	} else {
		m.addoperation_manual_times = &u
	}
}

// AddedOperationManualTimes returns the value that was added to the "operation_manual_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationManualTimes() (r int32, exists bool) {
	v := m.addoperation_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualTimes resets all changes to the "operation_manual_times" field.
func (m *StatsHourlyCarMutation) ResetOperationManualTimes() {
	m.operation_manual_times = nil
	m.addoperation_manual_times = nil
}

// SetOperationAutoTimes sets the "operation_auto_times" field.
func (m *StatsHourlyCarMutation) SetOperationAutoTimes(u uint32) {
	m.operation_auto_times = &u
	m.addoperation_auto_times = nil
}

// OperationAutoTimes returns the value of the "operation_auto_times" field in the mutation.
func (m *StatsHourlyCarMutation) OperationAutoTimes() (r uint32, exists bool) {
	v := m.operation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoTimes returns the old "operation_auto_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoTimes: %w", err)
	}
	return oldValue.OperationAutoTimes, nil
}

// AddOperationAutoTimes adds u to the "operation_auto_times" field.
func (m *StatsHourlyCarMutation) AddOperationAutoTimes(u int32) {
	if m.addoperation_auto_times != nil {
		*m.addoperation_auto_times += u
	} else {
		m.addoperation_auto_times = &u
	}
}

// AddedOperationAutoTimes returns the value that was added to the "operation_auto_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationAutoTimes() (r int32, exists bool) {
	v := m.addoperation_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoTimes resets all changes to the "operation_auto_times" field.
func (m *StatsHourlyCarMutation) ResetOperationAutoTimes() {
	m.operation_auto_times = nil
	m.addoperation_auto_times = nil
}

// SetOperationFaultTimes sets the "operation_fault_times" field.
func (m *StatsHourlyCarMutation) SetOperationFaultTimes(u uint32) {
	m.operation_fault_times = &u
	m.addoperation_fault_times = nil
}

// OperationFaultTimes returns the value of the "operation_fault_times" field in the mutation.
func (m *StatsHourlyCarMutation) OperationFaultTimes() (r uint32, exists bool) {
	v := m.operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationFaultTimes returns the old "operation_fault_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationFaultTimes: %w", err)
	}
	return oldValue.OperationFaultTimes, nil
}

// AddOperationFaultTimes adds u to the "operation_fault_times" field.
func (m *StatsHourlyCarMutation) AddOperationFaultTimes(u int32) {
	if m.addoperation_fault_times != nil {
		*m.addoperation_fault_times += u
	} else {
		m.addoperation_fault_times = &u
	}
}

// AddedOperationFaultTimes returns the value that was added to the "operation_fault_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationFaultTimes() (r int32, exists bool) {
	v := m.addoperation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationFaultTimes resets all changes to the "operation_fault_times" field.
func (m *StatsHourlyCarMutation) ResetOperationFaultTimes() {
	m.operation_fault_times = nil
	m.addoperation_fault_times = nil
}

// SetOperationManualMileage sets the "operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) SetOperationManualMileage(f float32) {
	m.operation_manual_mileage = &f
	m.addoperation_manual_mileage = nil
}

// OperationManualMileage returns the value of the "operation_manual_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) OperationManualMileage() (r float32, exists bool) {
	v := m.operation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationManualMileage returns the old "operation_manual_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationManualMileage: %w", err)
	}
	return oldValue.OperationManualMileage, nil
}

// AddOperationManualMileage adds f to the "operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) AddOperationManualMileage(f float32) {
	if m.addoperation_manual_mileage != nil {
		*m.addoperation_manual_mileage += f
	} else {
		m.addoperation_manual_mileage = &f
	}
}

// AddedOperationManualMileage returns the value that was added to the "operation_manual_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationManualMileage() (r float32, exists bool) {
	v := m.addoperation_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationManualMileage resets all changes to the "operation_manual_mileage" field.
func (m *StatsHourlyCarMutation) ResetOperationManualMileage() {
	m.operation_manual_mileage = nil
	m.addoperation_manual_mileage = nil
}

// SetOperationAutoMileage sets the "operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) SetOperationAutoMileage(f float32) {
	m.operation_auto_mileage = &f
	m.addoperation_auto_mileage = nil
}

// OperationAutoMileage returns the value of the "operation_auto_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) OperationAutoMileage() (r float32, exists bool) {
	v := m.operation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationAutoMileage returns the old "operation_auto_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldOperationAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationAutoMileage: %w", err)
	}
	return oldValue.OperationAutoMileage, nil
}

// AddOperationAutoMileage adds f to the "operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) AddOperationAutoMileage(f float32) {
	if m.addoperation_auto_mileage != nil {
		*m.addoperation_auto_mileage += f
	} else {
		m.addoperation_auto_mileage = &f
	}
}

// AddedOperationAutoMileage returns the value that was added to the "operation_auto_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedOperationAutoMileage() (r float32, exists bool) {
	v := m.addoperation_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperationAutoMileage resets all changes to the "operation_auto_mileage" field.
func (m *StatsHourlyCarMutation) ResetOperationAutoMileage() {
	m.operation_auto_mileage = nil
	m.addoperation_auto_mileage = nil
}

// SetMaintainLockDuration sets the "maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) SetMaintainLockDuration(f float32) {
	m.maintain_lock_duration = &f
	m.addmaintain_lock_duration = nil
}

// MaintainLockDuration returns the value of the "maintain_lock_duration" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainLockDuration() (r float32, exists bool) {
	v := m.maintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockDuration returns the old "maintain_lock_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainLockDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockDuration: %w", err)
	}
	return oldValue.MaintainLockDuration, nil
}

// AddMaintainLockDuration adds f to the "maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) AddMaintainLockDuration(f float32) {
	if m.addmaintain_lock_duration != nil {
		*m.addmaintain_lock_duration += f
	} else {
		m.addmaintain_lock_duration = &f
	}
}

// AddedMaintainLockDuration returns the value that was added to the "maintain_lock_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainLockDuration() (r float32, exists bool) {
	v := m.addmaintain_lock_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockDuration resets all changes to the "maintain_lock_duration" field.
func (m *StatsHourlyCarMutation) ResetMaintainLockDuration() {
	m.maintain_lock_duration = nil
	m.addmaintain_lock_duration = nil
}

// SetMaintainManualDuration sets the "maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) SetMaintainManualDuration(f float32) {
	m.maintain_manual_duration = &f
	m.addmaintain_manual_duration = nil
}

// MaintainManualDuration returns the value of the "maintain_manual_duration" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainManualDuration() (r float32, exists bool) {
	v := m.maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualDuration returns the old "maintain_manual_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualDuration: %w", err)
	}
	return oldValue.MaintainManualDuration, nil
}

// AddMaintainManualDuration adds f to the "maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) AddMaintainManualDuration(f float32) {
	if m.addmaintain_manual_duration != nil {
		*m.addmaintain_manual_duration += f
	} else {
		m.addmaintain_manual_duration = &f
	}
}

// AddedMaintainManualDuration returns the value that was added to the "maintain_manual_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainManualDuration() (r float32, exists bool) {
	v := m.addmaintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualDuration resets all changes to the "maintain_manual_duration" field.
func (m *StatsHourlyCarMutation) ResetMaintainManualDuration() {
	m.maintain_manual_duration = nil
	m.addmaintain_manual_duration = nil
}

// SetMaintainAutoDuration sets the "maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) SetMaintainAutoDuration(f float32) {
	m.maintain_auto_duration = &f
	m.addmaintain_auto_duration = nil
}

// MaintainAutoDuration returns the value of the "maintain_auto_duration" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainAutoDuration() (r float32, exists bool) {
	v := m.maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoDuration returns the old "maintain_auto_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoDuration: %w", err)
	}
	return oldValue.MaintainAutoDuration, nil
}

// AddMaintainAutoDuration adds f to the "maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) AddMaintainAutoDuration(f float32) {
	if m.addmaintain_auto_duration != nil {
		*m.addmaintain_auto_duration += f
	} else {
		m.addmaintain_auto_duration = &f
	}
}

// AddedMaintainAutoDuration returns the value that was added to the "maintain_auto_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainAutoDuration() (r float32, exists bool) {
	v := m.addmaintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoDuration resets all changes to the "maintain_auto_duration" field.
func (m *StatsHourlyCarMutation) ResetMaintainAutoDuration() {
	m.maintain_auto_duration = nil
	m.addmaintain_auto_duration = nil
}

// SetMaintainRemoteDuration sets the "maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) SetMaintainRemoteDuration(f float32) {
	m.maintain_remote_duration = &f
	m.addmaintain_remote_duration = nil
}

// MaintainRemoteDuration returns the value of the "maintain_remote_duration" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainRemoteDuration() (r float32, exists bool) {
	v := m.maintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteDuration returns the old "maintain_remote_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainRemoteDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteDuration: %w", err)
	}
	return oldValue.MaintainRemoteDuration, nil
}

// AddMaintainRemoteDuration adds f to the "maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) AddMaintainRemoteDuration(f float32) {
	if m.addmaintain_remote_duration != nil {
		*m.addmaintain_remote_duration += f
	} else {
		m.addmaintain_remote_duration = &f
	}
}

// AddedMaintainRemoteDuration returns the value that was added to the "maintain_remote_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainRemoteDuration() (r float32, exists bool) {
	v := m.addmaintain_remote_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteDuration resets all changes to the "maintain_remote_duration" field.
func (m *StatsHourlyCarMutation) ResetMaintainRemoteDuration() {
	m.maintain_remote_duration = nil
	m.addmaintain_remote_duration = nil
}

// SetMaintainFaultDuration sets the "maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) SetMaintainFaultDuration(f float32) {
	m.maintain_fault_duration = &f
	m.addmaintain_fault_duration = nil
}

// MaintainFaultDuration returns the value of the "maintain_fault_duration" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainFaultDuration() (r float32, exists bool) {
	v := m.maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultDuration returns the old "maintain_fault_duration" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultDuration: %w", err)
	}
	return oldValue.MaintainFaultDuration, nil
}

// AddMaintainFaultDuration adds f to the "maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) AddMaintainFaultDuration(f float32) {
	if m.addmaintain_fault_duration != nil {
		*m.addmaintain_fault_duration += f
	} else {
		m.addmaintain_fault_duration = &f
	}
}

// AddedMaintainFaultDuration returns the value that was added to the "maintain_fault_duration" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainFaultDuration() (r float32, exists bool) {
	v := m.addmaintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultDuration resets all changes to the "maintain_fault_duration" field.
func (m *StatsHourlyCarMutation) ResetMaintainFaultDuration() {
	m.maintain_fault_duration = nil
	m.addmaintain_fault_duration = nil
}

// SetMaintainLockTimes sets the "maintain_lock_times" field.
func (m *StatsHourlyCarMutation) SetMaintainLockTimes(u uint32) {
	m.maintain_lock_times = &u
	m.addmaintain_lock_times = nil
}

// MaintainLockTimes returns the value of the "maintain_lock_times" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainLockTimes() (r uint32, exists bool) {
	v := m.maintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainLockTimes returns the old "maintain_lock_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainLockTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainLockTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainLockTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainLockTimes: %w", err)
	}
	return oldValue.MaintainLockTimes, nil
}

// AddMaintainLockTimes adds u to the "maintain_lock_times" field.
func (m *StatsHourlyCarMutation) AddMaintainLockTimes(u int32) {
	if m.addmaintain_lock_times != nil {
		*m.addmaintain_lock_times += u
	} else {
		m.addmaintain_lock_times = &u
	}
}

// AddedMaintainLockTimes returns the value that was added to the "maintain_lock_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainLockTimes() (r int32, exists bool) {
	v := m.addmaintain_lock_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainLockTimes resets all changes to the "maintain_lock_times" field.
func (m *StatsHourlyCarMutation) ResetMaintainLockTimes() {
	m.maintain_lock_times = nil
	m.addmaintain_lock_times = nil
}

// SetMaintainManualTimes sets the "maintain_manual_times" field.
func (m *StatsHourlyCarMutation) SetMaintainManualTimes(u uint32) {
	m.maintain_manual_times = &u
	m.addmaintain_manual_times = nil
}

// MaintainManualTimes returns the value of the "maintain_manual_times" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainManualTimes() (r uint32, exists bool) {
	v := m.maintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualTimes returns the old "maintain_manual_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainManualTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualTimes: %w", err)
	}
	return oldValue.MaintainManualTimes, nil
}

// AddMaintainManualTimes adds u to the "maintain_manual_times" field.
func (m *StatsHourlyCarMutation) AddMaintainManualTimes(u int32) {
	if m.addmaintain_manual_times != nil {
		*m.addmaintain_manual_times += u
	} else {
		m.addmaintain_manual_times = &u
	}
}

// AddedMaintainManualTimes returns the value that was added to the "maintain_manual_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainManualTimes() (r int32, exists bool) {
	v := m.addmaintain_manual_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualTimes resets all changes to the "maintain_manual_times" field.
func (m *StatsHourlyCarMutation) ResetMaintainManualTimes() {
	m.maintain_manual_times = nil
	m.addmaintain_manual_times = nil
}

// SetMaintainAutoTimes sets the "maintain_auto_times" field.
func (m *StatsHourlyCarMutation) SetMaintainAutoTimes(u uint32) {
	m.maintain_auto_times = &u
	m.addmaintain_auto_times = nil
}

// MaintainAutoTimes returns the value of the "maintain_auto_times" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainAutoTimes() (r uint32, exists bool) {
	v := m.maintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoTimes returns the old "maintain_auto_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainAutoTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoTimes: %w", err)
	}
	return oldValue.MaintainAutoTimes, nil
}

// AddMaintainAutoTimes adds u to the "maintain_auto_times" field.
func (m *StatsHourlyCarMutation) AddMaintainAutoTimes(u int32) {
	if m.addmaintain_auto_times != nil {
		*m.addmaintain_auto_times += u
	} else {
		m.addmaintain_auto_times = &u
	}
}

// AddedMaintainAutoTimes returns the value that was added to the "maintain_auto_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainAutoTimes() (r int32, exists bool) {
	v := m.addmaintain_auto_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoTimes resets all changes to the "maintain_auto_times" field.
func (m *StatsHourlyCarMutation) ResetMaintainAutoTimes() {
	m.maintain_auto_times = nil
	m.addmaintain_auto_times = nil
}

// SetMaintainRemoteTimes sets the "maintain_remote_times" field.
func (m *StatsHourlyCarMutation) SetMaintainRemoteTimes(u uint32) {
	m.maintain_remote_times = &u
	m.addmaintain_remote_times = nil
}

// MaintainRemoteTimes returns the value of the "maintain_remote_times" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainRemoteTimes() (r uint32, exists bool) {
	v := m.maintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteTimes returns the old "maintain_remote_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainRemoteTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteTimes: %w", err)
	}
	return oldValue.MaintainRemoteTimes, nil
}

// AddMaintainRemoteTimes adds u to the "maintain_remote_times" field.
func (m *StatsHourlyCarMutation) AddMaintainRemoteTimes(u int32) {
	if m.addmaintain_remote_times != nil {
		*m.addmaintain_remote_times += u
	} else {
		m.addmaintain_remote_times = &u
	}
}

// AddedMaintainRemoteTimes returns the value that was added to the "maintain_remote_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainRemoteTimes() (r int32, exists bool) {
	v := m.addmaintain_remote_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteTimes resets all changes to the "maintain_remote_times" field.
func (m *StatsHourlyCarMutation) ResetMaintainRemoteTimes() {
	m.maintain_remote_times = nil
	m.addmaintain_remote_times = nil
}

// SetMaintainFaultTimes sets the "maintain_fault_times" field.
func (m *StatsHourlyCarMutation) SetMaintainFaultTimes(u uint32) {
	m.maintain_fault_times = &u
	m.addmaintain_fault_times = nil
}

// MaintainFaultTimes returns the value of the "maintain_fault_times" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainFaultTimes() (r uint32, exists bool) {
	v := m.maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainFaultTimes returns the old "maintain_fault_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainFaultTimes: %w", err)
	}
	return oldValue.MaintainFaultTimes, nil
}

// AddMaintainFaultTimes adds u to the "maintain_fault_times" field.
func (m *StatsHourlyCarMutation) AddMaintainFaultTimes(u int32) {
	if m.addmaintain_fault_times != nil {
		*m.addmaintain_fault_times += u
	} else {
		m.addmaintain_fault_times = &u
	}
}

// AddedMaintainFaultTimes returns the value that was added to the "maintain_fault_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainFaultTimes() (r int32, exists bool) {
	v := m.addmaintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainFaultTimes resets all changes to the "maintain_fault_times" field.
func (m *StatsHourlyCarMutation) ResetMaintainFaultTimes() {
	m.maintain_fault_times = nil
	m.addmaintain_fault_times = nil
}

// SetMaintainManualMileage sets the "maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) SetMaintainManualMileage(f float32) {
	m.maintain_manual_mileage = &f
	m.addmaintain_manual_mileage = nil
}

// MaintainManualMileage returns the value of the "maintain_manual_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainManualMileage() (r float32, exists bool) {
	v := m.maintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainManualMileage returns the old "maintain_manual_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainManualMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainManualMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainManualMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainManualMileage: %w", err)
	}
	return oldValue.MaintainManualMileage, nil
}

// AddMaintainManualMileage adds f to the "maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) AddMaintainManualMileage(f float32) {
	if m.addmaintain_manual_mileage != nil {
		*m.addmaintain_manual_mileage += f
	} else {
		m.addmaintain_manual_mileage = &f
	}
}

// AddedMaintainManualMileage returns the value that was added to the "maintain_manual_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainManualMileage() (r float32, exists bool) {
	v := m.addmaintain_manual_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainManualMileage resets all changes to the "maintain_manual_mileage" field.
func (m *StatsHourlyCarMutation) ResetMaintainManualMileage() {
	m.maintain_manual_mileage = nil
	m.addmaintain_manual_mileage = nil
}

// SetMaintainAutoMileage sets the "maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) SetMaintainAutoMileage(f float32) {
	m.maintain_auto_mileage = &f
	m.addmaintain_auto_mileage = nil
}

// MaintainAutoMileage returns the value of the "maintain_auto_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainAutoMileage() (r float32, exists bool) {
	v := m.maintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainAutoMileage returns the old "maintain_auto_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainAutoMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainAutoMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainAutoMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainAutoMileage: %w", err)
	}
	return oldValue.MaintainAutoMileage, nil
}

// AddMaintainAutoMileage adds f to the "maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) AddMaintainAutoMileage(f float32) {
	if m.addmaintain_auto_mileage != nil {
		*m.addmaintain_auto_mileage += f
	} else {
		m.addmaintain_auto_mileage = &f
	}
}

// AddedMaintainAutoMileage returns the value that was added to the "maintain_auto_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainAutoMileage() (r float32, exists bool) {
	v := m.addmaintain_auto_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainAutoMileage resets all changes to the "maintain_auto_mileage" field.
func (m *StatsHourlyCarMutation) ResetMaintainAutoMileage() {
	m.maintain_auto_mileage = nil
	m.addmaintain_auto_mileage = nil
}

// SetMaintainRemoteMileage sets the "maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) SetMaintainRemoteMileage(f float32) {
	m.maintain_remote_mileage = &f
	m.addmaintain_remote_mileage = nil
}

// MaintainRemoteMileage returns the value of the "maintain_remote_mileage" field in the mutation.
func (m *StatsHourlyCarMutation) MaintainRemoteMileage() (r float32, exists bool) {
	v := m.maintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainRemoteMileage returns the old "maintain_remote_mileage" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldMaintainRemoteMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainRemoteMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainRemoteMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainRemoteMileage: %w", err)
	}
	return oldValue.MaintainRemoteMileage, nil
}

// AddMaintainRemoteMileage adds f to the "maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) AddMaintainRemoteMileage(f float32) {
	if m.addmaintain_remote_mileage != nil {
		*m.addmaintain_remote_mileage += f
	} else {
		m.addmaintain_remote_mileage = &f
	}
}

// AddedMaintainRemoteMileage returns the value that was added to the "maintain_remote_mileage" field in this mutation.
func (m *StatsHourlyCarMutation) AddedMaintainRemoteMileage() (r float32, exists bool) {
	v := m.addmaintain_remote_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainRemoteMileage resets all changes to the "maintain_remote_mileage" field.
func (m *StatsHourlyCarMutation) ResetMaintainRemoteMileage() {
	m.maintain_remote_mileage = nil
	m.addmaintain_remote_mileage = nil
}

// SetAlarmTimes sets the "alarm_times" field.
func (m *StatsHourlyCarMutation) SetAlarmTimes(u uint32) {
	m.alarm_times = &u
	m.addalarm_times = nil
}

// AlarmTimes returns the value of the "alarm_times" field in the mutation.
func (m *StatsHourlyCarMutation) AlarmTimes() (r uint32, exists bool) {
	v := m.alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmTimes returns the old "alarm_times" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldAlarmTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmTimes: %w", err)
	}
	return oldValue.AlarmTimes, nil
}

// AddAlarmTimes adds u to the "alarm_times" field.
func (m *StatsHourlyCarMutation) AddAlarmTimes(u int32) {
	if m.addalarm_times != nil {
		*m.addalarm_times += u
	} else {
		m.addalarm_times = &u
	}
}

// AddedAlarmTimes returns the value that was added to the "alarm_times" field in this mutation.
func (m *StatsHourlyCarMutation) AddedAlarmTimes() (r int32, exists bool) {
	v := m.addalarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlarmTimes resets all changes to the "alarm_times" field.
func (m *StatsHourlyCarMutation) ResetAlarmTimes() {
	m.alarm_times = nil
	m.addalarm_times = nil
}

// SetStatsTime sets the "stats_time" field.
func (m *StatsHourlyCarMutation) SetStatsTime(t time.Time) {
	m.stats_time = &t
}

// StatsTime returns the value of the "stats_time" field in the mutation.
func (m *StatsHourlyCarMutation) StatsTime() (r time.Time, exists bool) {
	v := m.stats_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTime returns the old "stats_time" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldStatsTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTime: %w", err)
	}
	return oldValue.StatsTime, nil
}

// ResetStatsTime resets all changes to the "stats_time" field.
func (m *StatsHourlyCarMutation) ResetStatsTime() {
	m.stats_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *StatsHourlyCarMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatsHourlyCarMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatsHourlyCar entity.
// If the StatsHourlyCar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyCarMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatsHourlyCarMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *StatsHourlyCarMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *StatsHourlyCarMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[statshourlycar.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *StatsHourlyCarMutation) BackgroundScenicAreaCleared() bool {
	return m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *StatsHourlyCarMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *StatsHourlyCarMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *StatsHourlyCarMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// ClearCar clears the "car" edge to the Car entity.
func (m *StatsHourlyCarMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[statshourlycar.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *StatsHourlyCarMutation) CarCleared() bool {
	return m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *StatsHourlyCarMutation) CarIDs() (ids []int) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *StatsHourlyCarMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// Where appends a list predicates to the StatsHourlyCarMutation builder.
func (m *StatsHourlyCarMutation) Where(ps ...predicate.StatsHourlyCar) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatsHourlyCarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatsHourlyCarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatsHourlyCar, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatsHourlyCarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatsHourlyCarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatsHourlyCar).
func (m *StatsHourlyCarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatsHourlyCarMutation) Fields() []string {
	fields := make([]string, 0, 66)
	if m.background_scenic_area != nil {
		fields = append(fields, statshourlycar.FieldScenicAreaID)
	}
	if m.car != nil {
		fields = append(fields, statshourlycar.FieldCarID)
	}
	if m.y != nil {
		fields = append(fields, statshourlycar.FieldY)
	}
	if m.m != nil {
		fields = append(fields, statshourlycar.FieldM)
	}
	if m.d != nil {
		fields = append(fields, statshourlycar.FieldD)
	}
	if m.h != nil {
		fields = append(fields, statshourlycar.FieldH)
	}
	if m.week != nil {
		fields = append(fields, statshourlycar.FieldWeek)
	}
	if m.weekday != nil {
		fields = append(fields, statshourlycar.FieldWeekday)
	}
	if m.period != nil {
		fields = append(fields, statshourlycar.FieldPeriod)
	}
	if m.order_count_create != nil {
		fields = append(fields, statshourlycar.FieldOrderCountCreate)
	}
	if m.order_count_finish != nil {
		fields = append(fields, statshourlycar.FieldOrderCountFinish)
	}
	if m.order_count_cancel != nil {
		fields = append(fields, statshourlycar.FieldOrderCountCancel)
	}
	if m.order_amount != nil {
		fields = append(fields, statshourlycar.FieldOrderAmount)
	}
	if m.order_duration != nil {
		fields = append(fields, statshourlycar.FieldOrderDuration)
	}
	if m.order_mileage != nil {
		fields = append(fields, statshourlycar.FieldOrderMileage)
	}
	if m.order_score != nil {
		fields = append(fields, statshourlycar.FieldOrderScore)
	}
	if m.cumulative_operation_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationLockDuration)
	}
	if m.cumulative_operation_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualDuration)
	}
	if m.cumulative_operation_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoDuration)
	}
	if m.cumulative_operation_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationFaultDuration)
	}
	if m.cumulative_operation_lock_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationLockTimes)
	}
	if m.cumulative_operation_manual_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualTimes)
	}
	if m.cumulative_operation_auto_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoTimes)
	}
	if m.cumulative_operation_fault_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationFaultTimes)
	}
	if m.cumulative_operation_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualMileage)
	}
	if m.cumulative_operation_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoMileage)
	}
	if m.cumulative_maintain_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainLockDuration)
	}
	if m.cumulative_maintain_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualDuration)
	}
	if m.cumulative_maintain_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoDuration)
	}
	if m.cumulative_maintain_remote_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteDuration)
	}
	if m.cumulative_maintain_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainFaultDuration)
	}
	if m.cumulative_maintain_lock_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainLockTimes)
	}
	if m.cumulative_maintain_manual_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualTimes)
	}
	if m.cumulative_maintain_auto_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoTimes)
	}
	if m.cumulative_maintain_remote_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteTimes)
	}
	if m.cumulative_maintain_fault_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainFaultTimes)
	}
	if m.cumulative_maintain_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualMileage)
	}
	if m.cumulative_maintain_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoMileage)
	}
	if m.cumulative_maintain_remote_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteMileage)
	}
	if m.cumulative_alarm_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeAlarmTimes)
	}
	if m.operation_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationLockDuration)
	}
	if m.operation_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationManualDuration)
	}
	if m.operation_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoDuration)
	}
	if m.operation_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationFaultDuration)
	}
	if m.operation_lock_times != nil {
		fields = append(fields, statshourlycar.FieldOperationLockTimes)
	}
	if m.operation_manual_times != nil {
		fields = append(fields, statshourlycar.FieldOperationManualTimes)
	}
	if m.operation_auto_times != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoTimes)
	}
	if m.operation_fault_times != nil {
		fields = append(fields, statshourlycar.FieldOperationFaultTimes)
	}
	if m.operation_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldOperationManualMileage)
	}
	if m.operation_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoMileage)
	}
	if m.maintain_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainLockDuration)
	}
	if m.maintain_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualDuration)
	}
	if m.maintain_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoDuration)
	}
	if m.maintain_remote_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteDuration)
	}
	if m.maintain_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainFaultDuration)
	}
	if m.maintain_lock_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainLockTimes)
	}
	if m.maintain_manual_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualTimes)
	}
	if m.maintain_auto_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoTimes)
	}
	if m.maintain_remote_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteTimes)
	}
	if m.maintain_fault_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainFaultTimes)
	}
	if m.maintain_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualMileage)
	}
	if m.maintain_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoMileage)
	}
	if m.maintain_remote_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteMileage)
	}
	if m.alarm_times != nil {
		fields = append(fields, statshourlycar.FieldAlarmTimes)
	}
	if m.stats_time != nil {
		fields = append(fields, statshourlycar.FieldStatsTime)
	}
	if m.create_time != nil {
		fields = append(fields, statshourlycar.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatsHourlyCarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statshourlycar.FieldScenicAreaID:
		return m.ScenicAreaID()
	case statshourlycar.FieldCarID:
		return m.CarID()
	case statshourlycar.FieldY:
		return m.Y()
	case statshourlycar.FieldM:
		return m.M()
	case statshourlycar.FieldD:
		return m.D()
	case statshourlycar.FieldH:
		return m.H()
	case statshourlycar.FieldWeek:
		return m.Week()
	case statshourlycar.FieldWeekday:
		return m.Weekday()
	case statshourlycar.FieldPeriod:
		return m.Period()
	case statshourlycar.FieldOrderCountCreate:
		return m.OrderCountCreate()
	case statshourlycar.FieldOrderCountFinish:
		return m.OrderCountFinish()
	case statshourlycar.FieldOrderCountCancel:
		return m.OrderCountCancel()
	case statshourlycar.FieldOrderAmount:
		return m.OrderAmount()
	case statshourlycar.FieldOrderDuration:
		return m.OrderDuration()
	case statshourlycar.FieldOrderMileage:
		return m.OrderMileage()
	case statshourlycar.FieldOrderScore:
		return m.OrderScore()
	case statshourlycar.FieldCumulativeOperationLockDuration:
		return m.CumulativeOperationLockDuration()
	case statshourlycar.FieldCumulativeOperationManualDuration:
		return m.CumulativeOperationManualDuration()
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		return m.CumulativeOperationAutoDuration()
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		return m.CumulativeOperationFaultDuration()
	case statshourlycar.FieldCumulativeOperationLockTimes:
		return m.CumulativeOperationLockTimes()
	case statshourlycar.FieldCumulativeOperationManualTimes:
		return m.CumulativeOperationManualTimes()
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		return m.CumulativeOperationAutoTimes()
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		return m.CumulativeOperationFaultTimes()
	case statshourlycar.FieldCumulativeOperationManualMileage:
		return m.CumulativeOperationManualMileage()
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		return m.CumulativeOperationAutoMileage()
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		return m.CumulativeMaintainLockDuration()
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		return m.CumulativeMaintainManualDuration()
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		return m.CumulativeMaintainAutoDuration()
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		return m.CumulativeMaintainRemoteDuration()
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		return m.CumulativeMaintainFaultDuration()
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		return m.CumulativeMaintainLockTimes()
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		return m.CumulativeMaintainManualTimes()
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		return m.CumulativeMaintainAutoTimes()
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		return m.CumulativeMaintainRemoteTimes()
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		return m.CumulativeMaintainFaultTimes()
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		return m.CumulativeMaintainManualMileage()
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		return m.CumulativeMaintainAutoMileage()
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		return m.CumulativeMaintainRemoteMileage()
	case statshourlycar.FieldCumulativeAlarmTimes:
		return m.CumulativeAlarmTimes()
	case statshourlycar.FieldOperationLockDuration:
		return m.OperationLockDuration()
	case statshourlycar.FieldOperationManualDuration:
		return m.OperationManualDuration()
	case statshourlycar.FieldOperationAutoDuration:
		return m.OperationAutoDuration()
	case statshourlycar.FieldOperationFaultDuration:
		return m.OperationFaultDuration()
	case statshourlycar.FieldOperationLockTimes:
		return m.OperationLockTimes()
	case statshourlycar.FieldOperationManualTimes:
		return m.OperationManualTimes()
	case statshourlycar.FieldOperationAutoTimes:
		return m.OperationAutoTimes()
	case statshourlycar.FieldOperationFaultTimes:
		return m.OperationFaultTimes()
	case statshourlycar.FieldOperationManualMileage:
		return m.OperationManualMileage()
	case statshourlycar.FieldOperationAutoMileage:
		return m.OperationAutoMileage()
	case statshourlycar.FieldMaintainLockDuration:
		return m.MaintainLockDuration()
	case statshourlycar.FieldMaintainManualDuration:
		return m.MaintainManualDuration()
	case statshourlycar.FieldMaintainAutoDuration:
		return m.MaintainAutoDuration()
	case statshourlycar.FieldMaintainRemoteDuration:
		return m.MaintainRemoteDuration()
	case statshourlycar.FieldMaintainFaultDuration:
		return m.MaintainFaultDuration()
	case statshourlycar.FieldMaintainLockTimes:
		return m.MaintainLockTimes()
	case statshourlycar.FieldMaintainManualTimes:
		return m.MaintainManualTimes()
	case statshourlycar.FieldMaintainAutoTimes:
		return m.MaintainAutoTimes()
	case statshourlycar.FieldMaintainRemoteTimes:
		return m.MaintainRemoteTimes()
	case statshourlycar.FieldMaintainFaultTimes:
		return m.MaintainFaultTimes()
	case statshourlycar.FieldMaintainManualMileage:
		return m.MaintainManualMileage()
	case statshourlycar.FieldMaintainAutoMileage:
		return m.MaintainAutoMileage()
	case statshourlycar.FieldMaintainRemoteMileage:
		return m.MaintainRemoteMileage()
	case statshourlycar.FieldAlarmTimes:
		return m.AlarmTimes()
	case statshourlycar.FieldStatsTime:
		return m.StatsTime()
	case statshourlycar.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatsHourlyCarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statshourlycar.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case statshourlycar.FieldCarID:
		return m.OldCarID(ctx)
	case statshourlycar.FieldY:
		return m.OldY(ctx)
	case statshourlycar.FieldM:
		return m.OldM(ctx)
	case statshourlycar.FieldD:
		return m.OldD(ctx)
	case statshourlycar.FieldH:
		return m.OldH(ctx)
	case statshourlycar.FieldWeek:
		return m.OldWeek(ctx)
	case statshourlycar.FieldWeekday:
		return m.OldWeekday(ctx)
	case statshourlycar.FieldPeriod:
		return m.OldPeriod(ctx)
	case statshourlycar.FieldOrderCountCreate:
		return m.OldOrderCountCreate(ctx)
	case statshourlycar.FieldOrderCountFinish:
		return m.OldOrderCountFinish(ctx)
	case statshourlycar.FieldOrderCountCancel:
		return m.OldOrderCountCancel(ctx)
	case statshourlycar.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case statshourlycar.FieldOrderDuration:
		return m.OldOrderDuration(ctx)
	case statshourlycar.FieldOrderMileage:
		return m.OldOrderMileage(ctx)
	case statshourlycar.FieldOrderScore:
		return m.OldOrderScore(ctx)
	case statshourlycar.FieldCumulativeOperationLockDuration:
		return m.OldCumulativeOperationLockDuration(ctx)
	case statshourlycar.FieldCumulativeOperationManualDuration:
		return m.OldCumulativeOperationManualDuration(ctx)
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		return m.OldCumulativeOperationAutoDuration(ctx)
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		return m.OldCumulativeOperationFaultDuration(ctx)
	case statshourlycar.FieldCumulativeOperationLockTimes:
		return m.OldCumulativeOperationLockTimes(ctx)
	case statshourlycar.FieldCumulativeOperationManualTimes:
		return m.OldCumulativeOperationManualTimes(ctx)
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		return m.OldCumulativeOperationAutoTimes(ctx)
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		return m.OldCumulativeOperationFaultTimes(ctx)
	case statshourlycar.FieldCumulativeOperationManualMileage:
		return m.OldCumulativeOperationManualMileage(ctx)
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		return m.OldCumulativeOperationAutoMileage(ctx)
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		return m.OldCumulativeMaintainLockDuration(ctx)
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		return m.OldCumulativeMaintainManualDuration(ctx)
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		return m.OldCumulativeMaintainAutoDuration(ctx)
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		return m.OldCumulativeMaintainRemoteDuration(ctx)
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		return m.OldCumulativeMaintainFaultDuration(ctx)
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		return m.OldCumulativeMaintainLockTimes(ctx)
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		return m.OldCumulativeMaintainManualTimes(ctx)
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		return m.OldCumulativeMaintainAutoTimes(ctx)
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		return m.OldCumulativeMaintainRemoteTimes(ctx)
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		return m.OldCumulativeMaintainFaultTimes(ctx)
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		return m.OldCumulativeMaintainManualMileage(ctx)
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		return m.OldCumulativeMaintainAutoMileage(ctx)
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		return m.OldCumulativeMaintainRemoteMileage(ctx)
	case statshourlycar.FieldCumulativeAlarmTimes:
		return m.OldCumulativeAlarmTimes(ctx)
	case statshourlycar.FieldOperationLockDuration:
		return m.OldOperationLockDuration(ctx)
	case statshourlycar.FieldOperationManualDuration:
		return m.OldOperationManualDuration(ctx)
	case statshourlycar.FieldOperationAutoDuration:
		return m.OldOperationAutoDuration(ctx)
	case statshourlycar.FieldOperationFaultDuration:
		return m.OldOperationFaultDuration(ctx)
	case statshourlycar.FieldOperationLockTimes:
		return m.OldOperationLockTimes(ctx)
	case statshourlycar.FieldOperationManualTimes:
		return m.OldOperationManualTimes(ctx)
	case statshourlycar.FieldOperationAutoTimes:
		return m.OldOperationAutoTimes(ctx)
	case statshourlycar.FieldOperationFaultTimes:
		return m.OldOperationFaultTimes(ctx)
	case statshourlycar.FieldOperationManualMileage:
		return m.OldOperationManualMileage(ctx)
	case statshourlycar.FieldOperationAutoMileage:
		return m.OldOperationAutoMileage(ctx)
	case statshourlycar.FieldMaintainLockDuration:
		return m.OldMaintainLockDuration(ctx)
	case statshourlycar.FieldMaintainManualDuration:
		return m.OldMaintainManualDuration(ctx)
	case statshourlycar.FieldMaintainAutoDuration:
		return m.OldMaintainAutoDuration(ctx)
	case statshourlycar.FieldMaintainRemoteDuration:
		return m.OldMaintainRemoteDuration(ctx)
	case statshourlycar.FieldMaintainFaultDuration:
		return m.OldMaintainFaultDuration(ctx)
	case statshourlycar.FieldMaintainLockTimes:
		return m.OldMaintainLockTimes(ctx)
	case statshourlycar.FieldMaintainManualTimes:
		return m.OldMaintainManualTimes(ctx)
	case statshourlycar.FieldMaintainAutoTimes:
		return m.OldMaintainAutoTimes(ctx)
	case statshourlycar.FieldMaintainRemoteTimes:
		return m.OldMaintainRemoteTimes(ctx)
	case statshourlycar.FieldMaintainFaultTimes:
		return m.OldMaintainFaultTimes(ctx)
	case statshourlycar.FieldMaintainManualMileage:
		return m.OldMaintainManualMileage(ctx)
	case statshourlycar.FieldMaintainAutoMileage:
		return m.OldMaintainAutoMileage(ctx)
	case statshourlycar.FieldMaintainRemoteMileage:
		return m.OldMaintainRemoteMileage(ctx)
	case statshourlycar.FieldAlarmTimes:
		return m.OldAlarmTimes(ctx)
	case statshourlycar.FieldStatsTime:
		return m.OldStatsTime(ctx)
	case statshourlycar.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown StatsHourlyCar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsHourlyCarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statshourlycar.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case statshourlycar.FieldCarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case statshourlycar.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case statshourlycar.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetM(v)
		return nil
	case statshourlycar.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case statshourlycar.FieldH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH(v)
		return nil
	case statshourlycar.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeek(v)
		return nil
	case statshourlycar.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	case statshourlycar.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case statshourlycar.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCreate(v)
		return nil
	case statshourlycar.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountFinish(v)
		return nil
	case statshourlycar.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCancel(v)
		return nil
	case statshourlycar.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case statshourlycar.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDuration(v)
		return nil
	case statshourlycar.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMileage(v)
		return nil
	case statshourlycar.FieldOrderScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderScore(v)
		return nil
	case statshourlycar.FieldCumulativeOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationLockDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationManualDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationAutoDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationFaultDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationLockTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationManualTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationAutoTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationFaultTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationManualMileage(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeOperationAutoMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainLockDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainManualDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainAutoDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainRemoteDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainFaultDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainLockTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainManualTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainAutoTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainRemoteTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainFaultTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainManualMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainAutoMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeMaintainRemoteMileage(v)
		return nil
	case statshourlycar.FieldCumulativeAlarmTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCumulativeAlarmTimes(v)
		return nil
	case statshourlycar.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockDuration(v)
		return nil
	case statshourlycar.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualDuration(v)
		return nil
	case statshourlycar.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoDuration(v)
		return nil
	case statshourlycar.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultDuration(v)
		return nil
	case statshourlycar.FieldOperationLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationLockTimes(v)
		return nil
	case statshourlycar.FieldOperationManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualTimes(v)
		return nil
	case statshourlycar.FieldOperationAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoTimes(v)
		return nil
	case statshourlycar.FieldOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationFaultTimes(v)
		return nil
	case statshourlycar.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationManualMileage(v)
		return nil
	case statshourlycar.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationAutoMileage(v)
		return nil
	case statshourlycar.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockDuration(v)
		return nil
	case statshourlycar.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualDuration(v)
		return nil
	case statshourlycar.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoDuration(v)
		return nil
	case statshourlycar.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteDuration(v)
		return nil
	case statshourlycar.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultDuration(v)
		return nil
	case statshourlycar.FieldMaintainLockTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainLockTimes(v)
		return nil
	case statshourlycar.FieldMaintainManualTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualTimes(v)
		return nil
	case statshourlycar.FieldMaintainAutoTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoTimes(v)
		return nil
	case statshourlycar.FieldMaintainRemoteTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteTimes(v)
		return nil
	case statshourlycar.FieldMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainFaultTimes(v)
		return nil
	case statshourlycar.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainManualMileage(v)
		return nil
	case statshourlycar.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainAutoMileage(v)
		return nil
	case statshourlycar.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainRemoteMileage(v)
		return nil
	case statshourlycar.FieldAlarmTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmTimes(v)
		return nil
	case statshourlycar.FieldStatsTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTime(v)
		return nil
	case statshourlycar.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyCar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatsHourlyCarMutation) AddedFields() []string {
	var fields []string
	if m.addy != nil {
		fields = append(fields, statshourlycar.FieldY)
	}
	if m.addm != nil {
		fields = append(fields, statshourlycar.FieldM)
	}
	if m.addd != nil {
		fields = append(fields, statshourlycar.FieldD)
	}
	if m.addh != nil {
		fields = append(fields, statshourlycar.FieldH)
	}
	if m.addweek != nil {
		fields = append(fields, statshourlycar.FieldWeek)
	}
	if m.addweekday != nil {
		fields = append(fields, statshourlycar.FieldWeekday)
	}
	if m.addperiod != nil {
		fields = append(fields, statshourlycar.FieldPeriod)
	}
	if m.addorder_count_create != nil {
		fields = append(fields, statshourlycar.FieldOrderCountCreate)
	}
	if m.addorder_count_finish != nil {
		fields = append(fields, statshourlycar.FieldOrderCountFinish)
	}
	if m.addorder_count_cancel != nil {
		fields = append(fields, statshourlycar.FieldOrderCountCancel)
	}
	if m.addorder_amount != nil {
		fields = append(fields, statshourlycar.FieldOrderAmount)
	}
	if m.addorder_duration != nil {
		fields = append(fields, statshourlycar.FieldOrderDuration)
	}
	if m.addorder_mileage != nil {
		fields = append(fields, statshourlycar.FieldOrderMileage)
	}
	if m.addorder_score != nil {
		fields = append(fields, statshourlycar.FieldOrderScore)
	}
	if m.addcumulative_operation_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationLockDuration)
	}
	if m.addcumulative_operation_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualDuration)
	}
	if m.addcumulative_operation_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoDuration)
	}
	if m.addcumulative_operation_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationFaultDuration)
	}
	if m.addcumulative_operation_lock_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationLockTimes)
	}
	if m.addcumulative_operation_manual_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualTimes)
	}
	if m.addcumulative_operation_auto_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoTimes)
	}
	if m.addcumulative_operation_fault_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationFaultTimes)
	}
	if m.addcumulative_operation_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationManualMileage)
	}
	if m.addcumulative_operation_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeOperationAutoMileage)
	}
	if m.addcumulative_maintain_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainLockDuration)
	}
	if m.addcumulative_maintain_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualDuration)
	}
	if m.addcumulative_maintain_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoDuration)
	}
	if m.addcumulative_maintain_remote_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteDuration)
	}
	if m.addcumulative_maintain_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainFaultDuration)
	}
	if m.addcumulative_maintain_lock_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainLockTimes)
	}
	if m.addcumulative_maintain_manual_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualTimes)
	}
	if m.addcumulative_maintain_auto_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoTimes)
	}
	if m.addcumulative_maintain_remote_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteTimes)
	}
	if m.addcumulative_maintain_fault_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainFaultTimes)
	}
	if m.addcumulative_maintain_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainManualMileage)
	}
	if m.addcumulative_maintain_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainAutoMileage)
	}
	if m.addcumulative_maintain_remote_mileage != nil {
		fields = append(fields, statshourlycar.FieldCumulativeMaintainRemoteMileage)
	}
	if m.addcumulative_alarm_times != nil {
		fields = append(fields, statshourlycar.FieldCumulativeAlarmTimes)
	}
	if m.addoperation_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationLockDuration)
	}
	if m.addoperation_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationManualDuration)
	}
	if m.addoperation_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoDuration)
	}
	if m.addoperation_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldOperationFaultDuration)
	}
	if m.addoperation_lock_times != nil {
		fields = append(fields, statshourlycar.FieldOperationLockTimes)
	}
	if m.addoperation_manual_times != nil {
		fields = append(fields, statshourlycar.FieldOperationManualTimes)
	}
	if m.addoperation_auto_times != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoTimes)
	}
	if m.addoperation_fault_times != nil {
		fields = append(fields, statshourlycar.FieldOperationFaultTimes)
	}
	if m.addoperation_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldOperationManualMileage)
	}
	if m.addoperation_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldOperationAutoMileage)
	}
	if m.addmaintain_lock_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainLockDuration)
	}
	if m.addmaintain_manual_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualDuration)
	}
	if m.addmaintain_auto_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoDuration)
	}
	if m.addmaintain_remote_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteDuration)
	}
	if m.addmaintain_fault_duration != nil {
		fields = append(fields, statshourlycar.FieldMaintainFaultDuration)
	}
	if m.addmaintain_lock_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainLockTimes)
	}
	if m.addmaintain_manual_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualTimes)
	}
	if m.addmaintain_auto_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoTimes)
	}
	if m.addmaintain_remote_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteTimes)
	}
	if m.addmaintain_fault_times != nil {
		fields = append(fields, statshourlycar.FieldMaintainFaultTimes)
	}
	if m.addmaintain_manual_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainManualMileage)
	}
	if m.addmaintain_auto_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainAutoMileage)
	}
	if m.addmaintain_remote_mileage != nil {
		fields = append(fields, statshourlycar.FieldMaintainRemoteMileage)
	}
	if m.addalarm_times != nil {
		fields = append(fields, statshourlycar.FieldAlarmTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatsHourlyCarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statshourlycar.FieldY:
		return m.AddedY()
	case statshourlycar.FieldM:
		return m.AddedM()
	case statshourlycar.FieldD:
		return m.AddedD()
	case statshourlycar.FieldH:
		return m.AddedH()
	case statshourlycar.FieldWeek:
		return m.AddedWeek()
	case statshourlycar.FieldWeekday:
		return m.AddedWeekday()
	case statshourlycar.FieldPeriod:
		return m.AddedPeriod()
	case statshourlycar.FieldOrderCountCreate:
		return m.AddedOrderCountCreate()
	case statshourlycar.FieldOrderCountFinish:
		return m.AddedOrderCountFinish()
	case statshourlycar.FieldOrderCountCancel:
		return m.AddedOrderCountCancel()
	case statshourlycar.FieldOrderAmount:
		return m.AddedOrderAmount()
	case statshourlycar.FieldOrderDuration:
		return m.AddedOrderDuration()
	case statshourlycar.FieldOrderMileage:
		return m.AddedOrderMileage()
	case statshourlycar.FieldOrderScore:
		return m.AddedOrderScore()
	case statshourlycar.FieldCumulativeOperationLockDuration:
		return m.AddedCumulativeOperationLockDuration()
	case statshourlycar.FieldCumulativeOperationManualDuration:
		return m.AddedCumulativeOperationManualDuration()
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		return m.AddedCumulativeOperationAutoDuration()
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		return m.AddedCumulativeOperationFaultDuration()
	case statshourlycar.FieldCumulativeOperationLockTimes:
		return m.AddedCumulativeOperationLockTimes()
	case statshourlycar.FieldCumulativeOperationManualTimes:
		return m.AddedCumulativeOperationManualTimes()
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		return m.AddedCumulativeOperationAutoTimes()
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		return m.AddedCumulativeOperationFaultTimes()
	case statshourlycar.FieldCumulativeOperationManualMileage:
		return m.AddedCumulativeOperationManualMileage()
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		return m.AddedCumulativeOperationAutoMileage()
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		return m.AddedCumulativeMaintainLockDuration()
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		return m.AddedCumulativeMaintainManualDuration()
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		return m.AddedCumulativeMaintainAutoDuration()
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		return m.AddedCumulativeMaintainRemoteDuration()
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		return m.AddedCumulativeMaintainFaultDuration()
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		return m.AddedCumulativeMaintainLockTimes()
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		return m.AddedCumulativeMaintainManualTimes()
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		return m.AddedCumulativeMaintainAutoTimes()
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		return m.AddedCumulativeMaintainRemoteTimes()
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		return m.AddedCumulativeMaintainFaultTimes()
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		return m.AddedCumulativeMaintainManualMileage()
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		return m.AddedCumulativeMaintainAutoMileage()
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		return m.AddedCumulativeMaintainRemoteMileage()
	case statshourlycar.FieldCumulativeAlarmTimes:
		return m.AddedCumulativeAlarmTimes()
	case statshourlycar.FieldOperationLockDuration:
		return m.AddedOperationLockDuration()
	case statshourlycar.FieldOperationManualDuration:
		return m.AddedOperationManualDuration()
	case statshourlycar.FieldOperationAutoDuration:
		return m.AddedOperationAutoDuration()
	case statshourlycar.FieldOperationFaultDuration:
		return m.AddedOperationFaultDuration()
	case statshourlycar.FieldOperationLockTimes:
		return m.AddedOperationLockTimes()
	case statshourlycar.FieldOperationManualTimes:
		return m.AddedOperationManualTimes()
	case statshourlycar.FieldOperationAutoTimes:
		return m.AddedOperationAutoTimes()
	case statshourlycar.FieldOperationFaultTimes:
		return m.AddedOperationFaultTimes()
	case statshourlycar.FieldOperationManualMileage:
		return m.AddedOperationManualMileage()
	case statshourlycar.FieldOperationAutoMileage:
		return m.AddedOperationAutoMileage()
	case statshourlycar.FieldMaintainLockDuration:
		return m.AddedMaintainLockDuration()
	case statshourlycar.FieldMaintainManualDuration:
		return m.AddedMaintainManualDuration()
	case statshourlycar.FieldMaintainAutoDuration:
		return m.AddedMaintainAutoDuration()
	case statshourlycar.FieldMaintainRemoteDuration:
		return m.AddedMaintainRemoteDuration()
	case statshourlycar.FieldMaintainFaultDuration:
		return m.AddedMaintainFaultDuration()
	case statshourlycar.FieldMaintainLockTimes:
		return m.AddedMaintainLockTimes()
	case statshourlycar.FieldMaintainManualTimes:
		return m.AddedMaintainManualTimes()
	case statshourlycar.FieldMaintainAutoTimes:
		return m.AddedMaintainAutoTimes()
	case statshourlycar.FieldMaintainRemoteTimes:
		return m.AddedMaintainRemoteTimes()
	case statshourlycar.FieldMaintainFaultTimes:
		return m.AddedMaintainFaultTimes()
	case statshourlycar.FieldMaintainManualMileage:
		return m.AddedMaintainManualMileage()
	case statshourlycar.FieldMaintainAutoMileage:
		return m.AddedMaintainAutoMileage()
	case statshourlycar.FieldMaintainRemoteMileage:
		return m.AddedMaintainRemoteMileage()
	case statshourlycar.FieldAlarmTimes:
		return m.AddedAlarmTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsHourlyCarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statshourlycar.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case statshourlycar.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddM(v)
		return nil
	case statshourlycar.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddD(v)
		return nil
	case statshourlycar.FieldH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddH(v)
		return nil
	case statshourlycar.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeek(v)
		return nil
	case statshourlycar.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekday(v)
		return nil
	case statshourlycar.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case statshourlycar.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCreate(v)
		return nil
	case statshourlycar.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountFinish(v)
		return nil
	case statshourlycar.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCancel(v)
		return nil
	case statshourlycar.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case statshourlycar.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDuration(v)
		return nil
	case statshourlycar.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderMileage(v)
		return nil
	case statshourlycar.FieldOrderScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderScore(v)
		return nil
	case statshourlycar.FieldCumulativeOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationLockDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationManualDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationAutoDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationFaultDuration(v)
		return nil
	case statshourlycar.FieldCumulativeOperationLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationLockTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationManualTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationAutoTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationFaultTimes(v)
		return nil
	case statshourlycar.FieldCumulativeOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationManualMileage(v)
		return nil
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeOperationAutoMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainLockDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainManualDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainAutoDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainRemoteDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainFaultDuration(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainLockTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainManualTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainAutoTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainRemoteTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainFaultTimes(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainManualMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainAutoMileage(v)
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeMaintainRemoteMileage(v)
		return nil
	case statshourlycar.FieldCumulativeAlarmTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCumulativeAlarmTimes(v)
		return nil
	case statshourlycar.FieldOperationLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockDuration(v)
		return nil
	case statshourlycar.FieldOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualDuration(v)
		return nil
	case statshourlycar.FieldOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoDuration(v)
		return nil
	case statshourlycar.FieldOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultDuration(v)
		return nil
	case statshourlycar.FieldOperationLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationLockTimes(v)
		return nil
	case statshourlycar.FieldOperationManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualTimes(v)
		return nil
	case statshourlycar.FieldOperationAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoTimes(v)
		return nil
	case statshourlycar.FieldOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationFaultTimes(v)
		return nil
	case statshourlycar.FieldOperationManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationManualMileage(v)
		return nil
	case statshourlycar.FieldOperationAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperationAutoMileage(v)
		return nil
	case statshourlycar.FieldMaintainLockDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockDuration(v)
		return nil
	case statshourlycar.FieldMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualDuration(v)
		return nil
	case statshourlycar.FieldMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoDuration(v)
		return nil
	case statshourlycar.FieldMaintainRemoteDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteDuration(v)
		return nil
	case statshourlycar.FieldMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultDuration(v)
		return nil
	case statshourlycar.FieldMaintainLockTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainLockTimes(v)
		return nil
	case statshourlycar.FieldMaintainManualTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualTimes(v)
		return nil
	case statshourlycar.FieldMaintainAutoTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoTimes(v)
		return nil
	case statshourlycar.FieldMaintainRemoteTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteTimes(v)
		return nil
	case statshourlycar.FieldMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainFaultTimes(v)
		return nil
	case statshourlycar.FieldMaintainManualMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainManualMileage(v)
		return nil
	case statshourlycar.FieldMaintainAutoMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainAutoMileage(v)
		return nil
	case statshourlycar.FieldMaintainRemoteMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainRemoteMileage(v)
		return nil
	case statshourlycar.FieldAlarmTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlarmTimes(v)
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyCar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatsHourlyCarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatsHourlyCarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatsHourlyCarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatsHourlyCar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatsHourlyCarMutation) ResetField(name string) error {
	switch name {
	case statshourlycar.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case statshourlycar.FieldCarID:
		m.ResetCarID()
		return nil
	case statshourlycar.FieldY:
		m.ResetY()
		return nil
	case statshourlycar.FieldM:
		m.ResetM()
		return nil
	case statshourlycar.FieldD:
		m.ResetD()
		return nil
	case statshourlycar.FieldH:
		m.ResetH()
		return nil
	case statshourlycar.FieldWeek:
		m.ResetWeek()
		return nil
	case statshourlycar.FieldWeekday:
		m.ResetWeekday()
		return nil
	case statshourlycar.FieldPeriod:
		m.ResetPeriod()
		return nil
	case statshourlycar.FieldOrderCountCreate:
		m.ResetOrderCountCreate()
		return nil
	case statshourlycar.FieldOrderCountFinish:
		m.ResetOrderCountFinish()
		return nil
	case statshourlycar.FieldOrderCountCancel:
		m.ResetOrderCountCancel()
		return nil
	case statshourlycar.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case statshourlycar.FieldOrderDuration:
		m.ResetOrderDuration()
		return nil
	case statshourlycar.FieldOrderMileage:
		m.ResetOrderMileage()
		return nil
	case statshourlycar.FieldOrderScore:
		m.ResetOrderScore()
		return nil
	case statshourlycar.FieldCumulativeOperationLockDuration:
		m.ResetCumulativeOperationLockDuration()
		return nil
	case statshourlycar.FieldCumulativeOperationManualDuration:
		m.ResetCumulativeOperationManualDuration()
		return nil
	case statshourlycar.FieldCumulativeOperationAutoDuration:
		m.ResetCumulativeOperationAutoDuration()
		return nil
	case statshourlycar.FieldCumulativeOperationFaultDuration:
		m.ResetCumulativeOperationFaultDuration()
		return nil
	case statshourlycar.FieldCumulativeOperationLockTimes:
		m.ResetCumulativeOperationLockTimes()
		return nil
	case statshourlycar.FieldCumulativeOperationManualTimes:
		m.ResetCumulativeOperationManualTimes()
		return nil
	case statshourlycar.FieldCumulativeOperationAutoTimes:
		m.ResetCumulativeOperationAutoTimes()
		return nil
	case statshourlycar.FieldCumulativeOperationFaultTimes:
		m.ResetCumulativeOperationFaultTimes()
		return nil
	case statshourlycar.FieldCumulativeOperationManualMileage:
		m.ResetCumulativeOperationManualMileage()
		return nil
	case statshourlycar.FieldCumulativeOperationAutoMileage:
		m.ResetCumulativeOperationAutoMileage()
		return nil
	case statshourlycar.FieldCumulativeMaintainLockDuration:
		m.ResetCumulativeMaintainLockDuration()
		return nil
	case statshourlycar.FieldCumulativeMaintainManualDuration:
		m.ResetCumulativeMaintainManualDuration()
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoDuration:
		m.ResetCumulativeMaintainAutoDuration()
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteDuration:
		m.ResetCumulativeMaintainRemoteDuration()
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultDuration:
		m.ResetCumulativeMaintainFaultDuration()
		return nil
	case statshourlycar.FieldCumulativeMaintainLockTimes:
		m.ResetCumulativeMaintainLockTimes()
		return nil
	case statshourlycar.FieldCumulativeMaintainManualTimes:
		m.ResetCumulativeMaintainManualTimes()
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoTimes:
		m.ResetCumulativeMaintainAutoTimes()
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteTimes:
		m.ResetCumulativeMaintainRemoteTimes()
		return nil
	case statshourlycar.FieldCumulativeMaintainFaultTimes:
		m.ResetCumulativeMaintainFaultTimes()
		return nil
	case statshourlycar.FieldCumulativeMaintainManualMileage:
		m.ResetCumulativeMaintainManualMileage()
		return nil
	case statshourlycar.FieldCumulativeMaintainAutoMileage:
		m.ResetCumulativeMaintainAutoMileage()
		return nil
	case statshourlycar.FieldCumulativeMaintainRemoteMileage:
		m.ResetCumulativeMaintainRemoteMileage()
		return nil
	case statshourlycar.FieldCumulativeAlarmTimes:
		m.ResetCumulativeAlarmTimes()
		return nil
	case statshourlycar.FieldOperationLockDuration:
		m.ResetOperationLockDuration()
		return nil
	case statshourlycar.FieldOperationManualDuration:
		m.ResetOperationManualDuration()
		return nil
	case statshourlycar.FieldOperationAutoDuration:
		m.ResetOperationAutoDuration()
		return nil
	case statshourlycar.FieldOperationFaultDuration:
		m.ResetOperationFaultDuration()
		return nil
	case statshourlycar.FieldOperationLockTimes:
		m.ResetOperationLockTimes()
		return nil
	case statshourlycar.FieldOperationManualTimes:
		m.ResetOperationManualTimes()
		return nil
	case statshourlycar.FieldOperationAutoTimes:
		m.ResetOperationAutoTimes()
		return nil
	case statshourlycar.FieldOperationFaultTimes:
		m.ResetOperationFaultTimes()
		return nil
	case statshourlycar.FieldOperationManualMileage:
		m.ResetOperationManualMileage()
		return nil
	case statshourlycar.FieldOperationAutoMileage:
		m.ResetOperationAutoMileage()
		return nil
	case statshourlycar.FieldMaintainLockDuration:
		m.ResetMaintainLockDuration()
		return nil
	case statshourlycar.FieldMaintainManualDuration:
		m.ResetMaintainManualDuration()
		return nil
	case statshourlycar.FieldMaintainAutoDuration:
		m.ResetMaintainAutoDuration()
		return nil
	case statshourlycar.FieldMaintainRemoteDuration:
		m.ResetMaintainRemoteDuration()
		return nil
	case statshourlycar.FieldMaintainFaultDuration:
		m.ResetMaintainFaultDuration()
		return nil
	case statshourlycar.FieldMaintainLockTimes:
		m.ResetMaintainLockTimes()
		return nil
	case statshourlycar.FieldMaintainManualTimes:
		m.ResetMaintainManualTimes()
		return nil
	case statshourlycar.FieldMaintainAutoTimes:
		m.ResetMaintainAutoTimes()
		return nil
	case statshourlycar.FieldMaintainRemoteTimes:
		m.ResetMaintainRemoteTimes()
		return nil
	case statshourlycar.FieldMaintainFaultTimes:
		m.ResetMaintainFaultTimes()
		return nil
	case statshourlycar.FieldMaintainManualMileage:
		m.ResetMaintainManualMileage()
		return nil
	case statshourlycar.FieldMaintainAutoMileage:
		m.ResetMaintainAutoMileage()
		return nil
	case statshourlycar.FieldMaintainRemoteMileage:
		m.ResetMaintainRemoteMileage()
		return nil
	case statshourlycar.FieldAlarmTimes:
		m.ResetAlarmTimes()
		return nil
	case statshourlycar.FieldStatsTime:
		m.ResetStatsTime()
		return nil
	case statshourlycar.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyCar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatsHourlyCarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.background_scenic_area != nil {
		edges = append(edges, statshourlycar.EdgeBackgroundScenicArea)
	}
	if m.car != nil {
		edges = append(edges, statshourlycar.EdgeCar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatsHourlyCarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statshourlycar.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	case statshourlycar.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatsHourlyCarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatsHourlyCarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatsHourlyCarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbackground_scenic_area {
		edges = append(edges, statshourlycar.EdgeBackgroundScenicArea)
	}
	if m.clearedcar {
		edges = append(edges, statshourlycar.EdgeCar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatsHourlyCarMutation) EdgeCleared(name string) bool {
	switch name {
	case statshourlycar.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	case statshourlycar.EdgeCar:
		return m.clearedcar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatsHourlyCarMutation) ClearEdge(name string) error {
	switch name {
	case statshourlycar.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	case statshourlycar.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyCar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatsHourlyCarMutation) ResetEdge(name string) error {
	switch name {
	case statshourlycar.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	case statshourlycar.EdgeCar:
		m.ResetCar()
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyCar edge %s", name)
}

// StatsHourlyScenicAreaMutation represents an operation that mutates the StatsHourlyScenicArea nodes in the graph.
type StatsHourlyScenicAreaMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	scenic_area_id                   *int
	addscenic_area_id                *int
	y                                *int
	addy                             *int
	m                                *int
	addm                             *int
	d                                *int
	addd                             *int
	h                                *int
	addh                             *int
	week                             *int
	addweek                          *int
	weekday                          *int
	addweekday                       *int
	period                           *int
	addperiod                        *int
	user_count_login                 *int
	adduser_count_login              *int
	user_count_register              *int
	adduser_count_register           *int
	user_count_order                 *int
	adduser_count_order              *int
	order_count_create               *int
	addorder_count_create            *int
	order_count_finish               *int
	addorder_count_finish            *int
	order_count_cancel               *int
	addorder_count_cancel            *int
	order_amount                     *int
	addorder_amount                  *int
	order_duration                   *int
	addorder_duration                *int
	order_mileage                    *int
	addorder_mileage                 *int
	car_count_deploy                 *int
	addcar_count_deploy              *int
	car_count_operation              *int
	addcar_count_operation           *int
	car_operation_manual_duration    *float32
	addcar_operation_manual_duration *float32
	car_operation_auto_duration      *float32
	addcar_operation_auto_duration   *float32
	car_operation_normal_duration    *float32
	addcar_operation_normal_duration *float32
	car_operation_fault_duration     *float32
	addcar_operation_fault_duration  *float32
	car_operation_mileage            *float32
	addcar_operation_mileage         *float32
	car_operation_fault_times        *uint32
	addcar_operation_fault_times     *int32
	car_maintain_manual_duration     *float32
	addcar_maintain_manual_duration  *float32
	car_maintain_auto_duration       *float32
	addcar_maintain_auto_duration    *float32
	car_maintain_normal_duration     *float32
	addcar_maintain_normal_duration  *float32
	car_maintain_fault_duration      *float32
	addcar_maintain_fault_duration   *float32
	car_maintain_mileage             *float32
	addcar_maintain_mileage          *float32
	car_maintain_fault_times         *uint32
	addcar_maintain_fault_times      *int32
	car_alarm_times                  *uint32
	addcar_alarm_times               *int32
	stats_time                       *time.Time
	create_time                      *time.Time
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*StatsHourlyScenicArea, error)
	predicates                       []predicate.StatsHourlyScenicArea
}

var _ ent.Mutation = (*StatsHourlyScenicAreaMutation)(nil)

// statshourlyscenicareaOption allows management of the mutation configuration using functional options.
type statshourlyscenicareaOption func(*StatsHourlyScenicAreaMutation)

// newStatsHourlyScenicAreaMutation creates new mutation for the StatsHourlyScenicArea entity.
func newStatsHourlyScenicAreaMutation(c config, op Op, opts ...statshourlyscenicareaOption) *StatsHourlyScenicAreaMutation {
	m := &StatsHourlyScenicAreaMutation{
		config:        c,
		op:            op,
		typ:           TypeStatsHourlyScenicArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatsHourlyScenicAreaID sets the ID field of the mutation.
func withStatsHourlyScenicAreaID(id int) statshourlyscenicareaOption {
	return func(m *StatsHourlyScenicAreaMutation) {
		var (
			err   error
			once  sync.Once
			value *StatsHourlyScenicArea
		)
		m.oldValue = func(ctx context.Context) (*StatsHourlyScenicArea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatsHourlyScenicArea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatsHourlyScenicArea sets the old StatsHourlyScenicArea of the mutation.
func withStatsHourlyScenicArea(node *StatsHourlyScenicArea) statshourlyscenicareaOption {
	return func(m *StatsHourlyScenicAreaMutation) {
		m.oldValue = func(context.Context) (*StatsHourlyScenicArea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatsHourlyScenicAreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatsHourlyScenicAreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatsHourlyScenicArea entities.
func (m *StatsHourlyScenicAreaMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatsHourlyScenicAreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatsHourlyScenicAreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatsHourlyScenicArea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *StatsHourlyScenicAreaMutation) SetScenicAreaID(i int) {
	m.scenic_area_id = &i
	m.addscenic_area_id = nil
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) ScenicAreaID() (r int, exists bool) {
	v := m.scenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// AddScenicAreaID adds i to the "scenic_area_id" field.
func (m *StatsHourlyScenicAreaMutation) AddScenicAreaID(i int) {
	if m.addscenic_area_id != nil {
		*m.addscenic_area_id += i
	} else {
		m.addscenic_area_id = &i
	}
}

// AddedScenicAreaID returns the value that was added to the "scenic_area_id" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedScenicAreaID() (r int, exists bool) {
	v := m.addscenic_area_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *StatsHourlyScenicAreaMutation) ResetScenicAreaID() {
	m.scenic_area_id = nil
	m.addscenic_area_id = nil
}

// SetY sets the "y" field.
func (m *StatsHourlyScenicAreaMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *StatsHourlyScenicAreaMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *StatsHourlyScenicAreaMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetM sets the "m" field.
func (m *StatsHourlyScenicAreaMutation) SetM(i int) {
	m.m = &i
	m.addm = nil
}

// M returns the value of the "m" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) M() (r int, exists bool) {
	v := m.m
	if v == nil {
		return
	}
	return *v, true
}

// OldM returns the old "m" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldM is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldM: %w", err)
	}
	return oldValue.M, nil
}

// AddM adds i to the "m" field.
func (m *StatsHourlyScenicAreaMutation) AddM(i int) {
	if m.addm != nil {
		*m.addm += i
	} else {
		m.addm = &i
	}
}

// AddedM returns the value that was added to the "m" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedM() (r int, exists bool) {
	v := m.addm
	if v == nil {
		return
	}
	return *v, true
}

// ResetM resets all changes to the "m" field.
func (m *StatsHourlyScenicAreaMutation) ResetM() {
	m.m = nil
	m.addm = nil
}

// SetD sets the "d" field.
func (m *StatsHourlyScenicAreaMutation) SetD(i int) {
	m.d = &i
	m.addd = nil
}

// D returns the value of the "d" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) D() (r int, exists bool) {
	v := m.d
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "d" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldD(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// AddD adds i to the "d" field.
func (m *StatsHourlyScenicAreaMutation) AddD(i int) {
	if m.addd != nil {
		*m.addd += i
	} else {
		m.addd = &i
	}
}

// AddedD returns the value that was added to the "d" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedD() (r int, exists bool) {
	v := m.addd
	if v == nil {
		return
	}
	return *v, true
}

// ResetD resets all changes to the "d" field.
func (m *StatsHourlyScenicAreaMutation) ResetD() {
	m.d = nil
	m.addd = nil
}

// SetH sets the "h" field.
func (m *StatsHourlyScenicAreaMutation) SetH(i int) {
	m.h = &i
	m.addh = nil
}

// H returns the value of the "h" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) H() (r int, exists bool) {
	v := m.h
	if v == nil {
		return
	}
	return *v, true
}

// OldH returns the old "h" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldH(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH: %w", err)
	}
	return oldValue.H, nil
}

// AddH adds i to the "h" field.
func (m *StatsHourlyScenicAreaMutation) AddH(i int) {
	if m.addh != nil {
		*m.addh += i
	} else {
		m.addh = &i
	}
}

// AddedH returns the value that was added to the "h" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedH() (r int, exists bool) {
	v := m.addh
	if v == nil {
		return
	}
	return *v, true
}

// ResetH resets all changes to the "h" field.
func (m *StatsHourlyScenicAreaMutation) ResetH() {
	m.h = nil
	m.addh = nil
}

// SetWeek sets the "week" field.
func (m *StatsHourlyScenicAreaMutation) SetWeek(i int) {
	m.week = &i
	m.addweek = nil
}

// Week returns the value of the "week" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) Week() (r int, exists bool) {
	v := m.week
	if v == nil {
		return
	}
	return *v, true
}

// OldWeek returns the old "week" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldWeek(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeek: %w", err)
	}
	return oldValue.Week, nil
}

// AddWeek adds i to the "week" field.
func (m *StatsHourlyScenicAreaMutation) AddWeek(i int) {
	if m.addweek != nil {
		*m.addweek += i
	} else {
		m.addweek = &i
	}
}

// AddedWeek returns the value that was added to the "week" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedWeek() (r int, exists bool) {
	v := m.addweek
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeek resets all changes to the "week" field.
func (m *StatsHourlyScenicAreaMutation) ResetWeek() {
	m.week = nil
	m.addweek = nil
}

// SetWeekday sets the "weekday" field.
func (m *StatsHourlyScenicAreaMutation) SetWeekday(i int) {
	m.weekday = &i
	m.addweekday = nil
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) Weekday() (r int, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldWeekday(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// AddWeekday adds i to the "weekday" field.
func (m *StatsHourlyScenicAreaMutation) AddWeekday(i int) {
	if m.addweekday != nil {
		*m.addweekday += i
	} else {
		m.addweekday = &i
	}
}

// AddedWeekday returns the value that was added to the "weekday" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedWeekday() (r int, exists bool) {
	v := m.addweekday
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *StatsHourlyScenicAreaMutation) ResetWeekday() {
	m.weekday = nil
	m.addweekday = nil
}

// SetPeriod sets the "period" field.
func (m *StatsHourlyScenicAreaMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *StatsHourlyScenicAreaMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *StatsHourlyScenicAreaMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetUserCountLogin sets the "user_count_login" field.
func (m *StatsHourlyScenicAreaMutation) SetUserCountLogin(i int) {
	m.user_count_login = &i
	m.adduser_count_login = nil
}

// UserCountLogin returns the value of the "user_count_login" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) UserCountLogin() (r int, exists bool) {
	v := m.user_count_login
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountLogin returns the old "user_count_login" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldUserCountLogin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountLogin: %w", err)
	}
	return oldValue.UserCountLogin, nil
}

// AddUserCountLogin adds i to the "user_count_login" field.
func (m *StatsHourlyScenicAreaMutation) AddUserCountLogin(i int) {
	if m.adduser_count_login != nil {
		*m.adduser_count_login += i
	} else {
		m.adduser_count_login = &i
	}
}

// AddedUserCountLogin returns the value that was added to the "user_count_login" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedUserCountLogin() (r int, exists bool) {
	v := m.adduser_count_login
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountLogin resets all changes to the "user_count_login" field.
func (m *StatsHourlyScenicAreaMutation) ResetUserCountLogin() {
	m.user_count_login = nil
	m.adduser_count_login = nil
}

// SetUserCountRegister sets the "user_count_register" field.
func (m *StatsHourlyScenicAreaMutation) SetUserCountRegister(i int) {
	m.user_count_register = &i
	m.adduser_count_register = nil
}

// UserCountRegister returns the value of the "user_count_register" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) UserCountRegister() (r int, exists bool) {
	v := m.user_count_register
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountRegister returns the old "user_count_register" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldUserCountRegister(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountRegister: %w", err)
	}
	return oldValue.UserCountRegister, nil
}

// AddUserCountRegister adds i to the "user_count_register" field.
func (m *StatsHourlyScenicAreaMutation) AddUserCountRegister(i int) {
	if m.adduser_count_register != nil {
		*m.adduser_count_register += i
	} else {
		m.adduser_count_register = &i
	}
}

// AddedUserCountRegister returns the value that was added to the "user_count_register" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedUserCountRegister() (r int, exists bool) {
	v := m.adduser_count_register
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountRegister resets all changes to the "user_count_register" field.
func (m *StatsHourlyScenicAreaMutation) ResetUserCountRegister() {
	m.user_count_register = nil
	m.adduser_count_register = nil
}

// SetUserCountOrder sets the "user_count_order" field.
func (m *StatsHourlyScenicAreaMutation) SetUserCountOrder(i int) {
	m.user_count_order = &i
	m.adduser_count_order = nil
}

// UserCountOrder returns the value of the "user_count_order" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) UserCountOrder() (r int, exists bool) {
	v := m.user_count_order
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCountOrder returns the old "user_count_order" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldUserCountOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCountOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCountOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCountOrder: %w", err)
	}
	return oldValue.UserCountOrder, nil
}

// AddUserCountOrder adds i to the "user_count_order" field.
func (m *StatsHourlyScenicAreaMutation) AddUserCountOrder(i int) {
	if m.adduser_count_order != nil {
		*m.adduser_count_order += i
	} else {
		m.adduser_count_order = &i
	}
}

// AddedUserCountOrder returns the value that was added to the "user_count_order" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedUserCountOrder() (r int, exists bool) {
	v := m.adduser_count_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCountOrder resets all changes to the "user_count_order" field.
func (m *StatsHourlyScenicAreaMutation) ResetUserCountOrder() {
	m.user_count_order = nil
	m.adduser_count_order = nil
}

// SetOrderCountCreate sets the "order_count_create" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderCountCreate(i int) {
	m.order_count_create = &i
	m.addorder_count_create = nil
}

// OrderCountCreate returns the value of the "order_count_create" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderCountCreate() (r int, exists bool) {
	v := m.order_count_create
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCreate returns the old "order_count_create" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderCountCreate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCreate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCreate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCreate: %w", err)
	}
	return oldValue.OrderCountCreate, nil
}

// AddOrderCountCreate adds i to the "order_count_create" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderCountCreate(i int) {
	if m.addorder_count_create != nil {
		*m.addorder_count_create += i
	} else {
		m.addorder_count_create = &i
	}
}

// AddedOrderCountCreate returns the value that was added to the "order_count_create" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderCountCreate() (r int, exists bool) {
	v := m.addorder_count_create
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCreate resets all changes to the "order_count_create" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderCountCreate() {
	m.order_count_create = nil
	m.addorder_count_create = nil
}

// SetOrderCountFinish sets the "order_count_finish" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderCountFinish(i int) {
	m.order_count_finish = &i
	m.addorder_count_finish = nil
}

// OrderCountFinish returns the value of the "order_count_finish" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderCountFinish() (r int, exists bool) {
	v := m.order_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountFinish returns the old "order_count_finish" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderCountFinish(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountFinish is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountFinish requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountFinish: %w", err)
	}
	return oldValue.OrderCountFinish, nil
}

// AddOrderCountFinish adds i to the "order_count_finish" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderCountFinish(i int) {
	if m.addorder_count_finish != nil {
		*m.addorder_count_finish += i
	} else {
		m.addorder_count_finish = &i
	}
}

// AddedOrderCountFinish returns the value that was added to the "order_count_finish" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderCountFinish() (r int, exists bool) {
	v := m.addorder_count_finish
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountFinish resets all changes to the "order_count_finish" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderCountFinish() {
	m.order_count_finish = nil
	m.addorder_count_finish = nil
}

// SetOrderCountCancel sets the "order_count_cancel" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderCountCancel(i int) {
	m.order_count_cancel = &i
	m.addorder_count_cancel = nil
}

// OrderCountCancel returns the value of the "order_count_cancel" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderCountCancel() (r int, exists bool) {
	v := m.order_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCountCancel returns the old "order_count_cancel" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderCountCancel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCountCancel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCountCancel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCountCancel: %w", err)
	}
	return oldValue.OrderCountCancel, nil
}

// AddOrderCountCancel adds i to the "order_count_cancel" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderCountCancel(i int) {
	if m.addorder_count_cancel != nil {
		*m.addorder_count_cancel += i
	} else {
		m.addorder_count_cancel = &i
	}
}

// AddedOrderCountCancel returns the value that was added to the "order_count_cancel" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderCountCancel() (r int, exists bool) {
	v := m.addorder_count_cancel
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCountCancel resets all changes to the "order_count_cancel" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderCountCancel() {
	m.order_count_cancel = nil
	m.addorder_count_cancel = nil
}

// SetOrderAmount sets the "order_amount" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderAmount(i int) {
	m.order_amount = &i
	m.addorder_amount = nil
}

// OrderAmount returns the value of the "order_amount" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderAmount() (r int, exists bool) {
	v := m.order_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAmount returns the old "order_amount" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAmount: %w", err)
	}
	return oldValue.OrderAmount, nil
}

// AddOrderAmount adds i to the "order_amount" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderAmount(i int) {
	if m.addorder_amount != nil {
		*m.addorder_amount += i
	} else {
		m.addorder_amount = &i
	}
}

// AddedOrderAmount returns the value that was added to the "order_amount" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderAmount() (r int, exists bool) {
	v := m.addorder_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderAmount resets all changes to the "order_amount" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderAmount() {
	m.order_amount = nil
	m.addorder_amount = nil
}

// SetOrderDuration sets the "order_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderDuration(i int) {
	m.order_duration = &i
	m.addorder_duration = nil
}

// OrderDuration returns the value of the "order_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderDuration() (r int, exists bool) {
	v := m.order_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDuration returns the old "order_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDuration: %w", err)
	}
	return oldValue.OrderDuration, nil
}

// AddOrderDuration adds i to the "order_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderDuration(i int) {
	if m.addorder_duration != nil {
		*m.addorder_duration += i
	} else {
		m.addorder_duration = &i
	}
}

// AddedOrderDuration returns the value that was added to the "order_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderDuration() (r int, exists bool) {
	v := m.addorder_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDuration resets all changes to the "order_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderDuration() {
	m.order_duration = nil
	m.addorder_duration = nil
}

// SetOrderMileage sets the "order_mileage" field.
func (m *StatsHourlyScenicAreaMutation) SetOrderMileage(i int) {
	m.order_mileage = &i
	m.addorder_mileage = nil
}

// OrderMileage returns the value of the "order_mileage" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) OrderMileage() (r int, exists bool) {
	v := m.order_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderMileage returns the old "order_mileage" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldOrderMileage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderMileage: %w", err)
	}
	return oldValue.OrderMileage, nil
}

// AddOrderMileage adds i to the "order_mileage" field.
func (m *StatsHourlyScenicAreaMutation) AddOrderMileage(i int) {
	if m.addorder_mileage != nil {
		*m.addorder_mileage += i
	} else {
		m.addorder_mileage = &i
	}
}

// AddedOrderMileage returns the value that was added to the "order_mileage" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedOrderMileage() (r int, exists bool) {
	v := m.addorder_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderMileage resets all changes to the "order_mileage" field.
func (m *StatsHourlyScenicAreaMutation) ResetOrderMileage() {
	m.order_mileage = nil
	m.addorder_mileage = nil
}

// SetCarCountDeploy sets the "car_count_deploy" field.
func (m *StatsHourlyScenicAreaMutation) SetCarCountDeploy(i int) {
	m.car_count_deploy = &i
	m.addcar_count_deploy = nil
}

// CarCountDeploy returns the value of the "car_count_deploy" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarCountDeploy() (r int, exists bool) {
	v := m.car_count_deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldCarCountDeploy returns the old "car_count_deploy" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarCountDeploy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarCountDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarCountDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarCountDeploy: %w", err)
	}
	return oldValue.CarCountDeploy, nil
}

// AddCarCountDeploy adds i to the "car_count_deploy" field.
func (m *StatsHourlyScenicAreaMutation) AddCarCountDeploy(i int) {
	if m.addcar_count_deploy != nil {
		*m.addcar_count_deploy += i
	} else {
		m.addcar_count_deploy = &i
	}
}

// AddedCarCountDeploy returns the value that was added to the "car_count_deploy" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarCountDeploy() (r int, exists bool) {
	v := m.addcar_count_deploy
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarCountDeploy resets all changes to the "car_count_deploy" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarCountDeploy() {
	m.car_count_deploy = nil
	m.addcar_count_deploy = nil
}

// SetCarCountOperation sets the "car_count_operation" field.
func (m *StatsHourlyScenicAreaMutation) SetCarCountOperation(i int) {
	m.car_count_operation = &i
	m.addcar_count_operation = nil
}

// CarCountOperation returns the value of the "car_count_operation" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarCountOperation() (r int, exists bool) {
	v := m.car_count_operation
	if v == nil {
		return
	}
	return *v, true
}

// OldCarCountOperation returns the old "car_count_operation" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarCountOperation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarCountOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarCountOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarCountOperation: %w", err)
	}
	return oldValue.CarCountOperation, nil
}

// AddCarCountOperation adds i to the "car_count_operation" field.
func (m *StatsHourlyScenicAreaMutation) AddCarCountOperation(i int) {
	if m.addcar_count_operation != nil {
		*m.addcar_count_operation += i
	} else {
		m.addcar_count_operation = &i
	}
}

// AddedCarCountOperation returns the value that was added to the "car_count_operation" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarCountOperation() (r int, exists bool) {
	v := m.addcar_count_operation
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarCountOperation resets all changes to the "car_count_operation" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarCountOperation() {
	m.car_count_operation = nil
	m.addcar_count_operation = nil
}

// SetCarOperationManualDuration sets the "car_operation_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationManualDuration(f float32) {
	m.car_operation_manual_duration = &f
	m.addcar_operation_manual_duration = nil
}

// CarOperationManualDuration returns the value of the "car_operation_manual_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationManualDuration() (r float32, exists bool) {
	v := m.car_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationManualDuration returns the old "car_operation_manual_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationManualDuration: %w", err)
	}
	return oldValue.CarOperationManualDuration, nil
}

// AddCarOperationManualDuration adds f to the "car_operation_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationManualDuration(f float32) {
	if m.addcar_operation_manual_duration != nil {
		*m.addcar_operation_manual_duration += f
	} else {
		m.addcar_operation_manual_duration = &f
	}
}

// AddedCarOperationManualDuration returns the value that was added to the "car_operation_manual_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationManualDuration() (r float32, exists bool) {
	v := m.addcar_operation_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationManualDuration resets all changes to the "car_operation_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationManualDuration() {
	m.car_operation_manual_duration = nil
	m.addcar_operation_manual_duration = nil
}

// SetCarOperationAutoDuration sets the "car_operation_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationAutoDuration(f float32) {
	m.car_operation_auto_duration = &f
	m.addcar_operation_auto_duration = nil
}

// CarOperationAutoDuration returns the value of the "car_operation_auto_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationAutoDuration() (r float32, exists bool) {
	v := m.car_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationAutoDuration returns the old "car_operation_auto_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationAutoDuration: %w", err)
	}
	return oldValue.CarOperationAutoDuration, nil
}

// AddCarOperationAutoDuration adds f to the "car_operation_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationAutoDuration(f float32) {
	if m.addcar_operation_auto_duration != nil {
		*m.addcar_operation_auto_duration += f
	} else {
		m.addcar_operation_auto_duration = &f
	}
}

// AddedCarOperationAutoDuration returns the value that was added to the "car_operation_auto_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationAutoDuration() (r float32, exists bool) {
	v := m.addcar_operation_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationAutoDuration resets all changes to the "car_operation_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationAutoDuration() {
	m.car_operation_auto_duration = nil
	m.addcar_operation_auto_duration = nil
}

// SetCarOperationNormalDuration sets the "car_operation_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationNormalDuration(f float32) {
	m.car_operation_normal_duration = &f
	m.addcar_operation_normal_duration = nil
}

// CarOperationNormalDuration returns the value of the "car_operation_normal_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationNormalDuration() (r float32, exists bool) {
	v := m.car_operation_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationNormalDuration returns the old "car_operation_normal_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationNormalDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationNormalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationNormalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationNormalDuration: %w", err)
	}
	return oldValue.CarOperationNormalDuration, nil
}

// AddCarOperationNormalDuration adds f to the "car_operation_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationNormalDuration(f float32) {
	if m.addcar_operation_normal_duration != nil {
		*m.addcar_operation_normal_duration += f
	} else {
		m.addcar_operation_normal_duration = &f
	}
}

// AddedCarOperationNormalDuration returns the value that was added to the "car_operation_normal_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationNormalDuration() (r float32, exists bool) {
	v := m.addcar_operation_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationNormalDuration resets all changes to the "car_operation_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationNormalDuration() {
	m.car_operation_normal_duration = nil
	m.addcar_operation_normal_duration = nil
}

// SetCarOperationFaultDuration sets the "car_operation_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationFaultDuration(f float32) {
	m.car_operation_fault_duration = &f
	m.addcar_operation_fault_duration = nil
}

// CarOperationFaultDuration returns the value of the "car_operation_fault_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationFaultDuration() (r float32, exists bool) {
	v := m.car_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationFaultDuration returns the old "car_operation_fault_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationFaultDuration: %w", err)
	}
	return oldValue.CarOperationFaultDuration, nil
}

// AddCarOperationFaultDuration adds f to the "car_operation_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationFaultDuration(f float32) {
	if m.addcar_operation_fault_duration != nil {
		*m.addcar_operation_fault_duration += f
	} else {
		m.addcar_operation_fault_duration = &f
	}
}

// AddedCarOperationFaultDuration returns the value that was added to the "car_operation_fault_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationFaultDuration() (r float32, exists bool) {
	v := m.addcar_operation_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationFaultDuration resets all changes to the "car_operation_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationFaultDuration() {
	m.car_operation_fault_duration = nil
	m.addcar_operation_fault_duration = nil
}

// SetCarOperationMileage sets the "car_operation_mileage" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationMileage(f float32) {
	m.car_operation_mileage = &f
	m.addcar_operation_mileage = nil
}

// CarOperationMileage returns the value of the "car_operation_mileage" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationMileage() (r float32, exists bool) {
	v := m.car_operation_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationMileage returns the old "car_operation_mileage" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationMileage: %w", err)
	}
	return oldValue.CarOperationMileage, nil
}

// AddCarOperationMileage adds f to the "car_operation_mileage" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationMileage(f float32) {
	if m.addcar_operation_mileage != nil {
		*m.addcar_operation_mileage += f
	} else {
		m.addcar_operation_mileage = &f
	}
}

// AddedCarOperationMileage returns the value that was added to the "car_operation_mileage" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationMileage() (r float32, exists bool) {
	v := m.addcar_operation_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationMileage resets all changes to the "car_operation_mileage" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationMileage() {
	m.car_operation_mileage = nil
	m.addcar_operation_mileage = nil
}

// SetCarOperationFaultTimes sets the "car_operation_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) SetCarOperationFaultTimes(u uint32) {
	m.car_operation_fault_times = &u
	m.addcar_operation_fault_times = nil
}

// CarOperationFaultTimes returns the value of the "car_operation_fault_times" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarOperationFaultTimes() (r uint32, exists bool) {
	v := m.car_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarOperationFaultTimes returns the old "car_operation_fault_times" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarOperationFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarOperationFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarOperationFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarOperationFaultTimes: %w", err)
	}
	return oldValue.CarOperationFaultTimes, nil
}

// AddCarOperationFaultTimes adds u to the "car_operation_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) AddCarOperationFaultTimes(u int32) {
	if m.addcar_operation_fault_times != nil {
		*m.addcar_operation_fault_times += u
	} else {
		m.addcar_operation_fault_times = &u
	}
}

// AddedCarOperationFaultTimes returns the value that was added to the "car_operation_fault_times" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarOperationFaultTimes() (r int32, exists bool) {
	v := m.addcar_operation_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarOperationFaultTimes resets all changes to the "car_operation_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarOperationFaultTimes() {
	m.car_operation_fault_times = nil
	m.addcar_operation_fault_times = nil
}

// SetCarMaintainManualDuration sets the "car_maintain_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainManualDuration(f float32) {
	m.car_maintain_manual_duration = &f
	m.addcar_maintain_manual_duration = nil
}

// CarMaintainManualDuration returns the value of the "car_maintain_manual_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainManualDuration() (r float32, exists bool) {
	v := m.car_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainManualDuration returns the old "car_maintain_manual_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainManualDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainManualDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainManualDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainManualDuration: %w", err)
	}
	return oldValue.CarMaintainManualDuration, nil
}

// AddCarMaintainManualDuration adds f to the "car_maintain_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainManualDuration(f float32) {
	if m.addcar_maintain_manual_duration != nil {
		*m.addcar_maintain_manual_duration += f
	} else {
		m.addcar_maintain_manual_duration = &f
	}
}

// AddedCarMaintainManualDuration returns the value that was added to the "car_maintain_manual_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainManualDuration() (r float32, exists bool) {
	v := m.addcar_maintain_manual_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainManualDuration resets all changes to the "car_maintain_manual_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainManualDuration() {
	m.car_maintain_manual_duration = nil
	m.addcar_maintain_manual_duration = nil
}

// SetCarMaintainAutoDuration sets the "car_maintain_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainAutoDuration(f float32) {
	m.car_maintain_auto_duration = &f
	m.addcar_maintain_auto_duration = nil
}

// CarMaintainAutoDuration returns the value of the "car_maintain_auto_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainAutoDuration() (r float32, exists bool) {
	v := m.car_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainAutoDuration returns the old "car_maintain_auto_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainAutoDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainAutoDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainAutoDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainAutoDuration: %w", err)
	}
	return oldValue.CarMaintainAutoDuration, nil
}

// AddCarMaintainAutoDuration adds f to the "car_maintain_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainAutoDuration(f float32) {
	if m.addcar_maintain_auto_duration != nil {
		*m.addcar_maintain_auto_duration += f
	} else {
		m.addcar_maintain_auto_duration = &f
	}
}

// AddedCarMaintainAutoDuration returns the value that was added to the "car_maintain_auto_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainAutoDuration() (r float32, exists bool) {
	v := m.addcar_maintain_auto_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainAutoDuration resets all changes to the "car_maintain_auto_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainAutoDuration() {
	m.car_maintain_auto_duration = nil
	m.addcar_maintain_auto_duration = nil
}

// SetCarMaintainNormalDuration sets the "car_maintain_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainNormalDuration(f float32) {
	m.car_maintain_normal_duration = &f
	m.addcar_maintain_normal_duration = nil
}

// CarMaintainNormalDuration returns the value of the "car_maintain_normal_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainNormalDuration() (r float32, exists bool) {
	v := m.car_maintain_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainNormalDuration returns the old "car_maintain_normal_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainNormalDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainNormalDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainNormalDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainNormalDuration: %w", err)
	}
	return oldValue.CarMaintainNormalDuration, nil
}

// AddCarMaintainNormalDuration adds f to the "car_maintain_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainNormalDuration(f float32) {
	if m.addcar_maintain_normal_duration != nil {
		*m.addcar_maintain_normal_duration += f
	} else {
		m.addcar_maintain_normal_duration = &f
	}
}

// AddedCarMaintainNormalDuration returns the value that was added to the "car_maintain_normal_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainNormalDuration() (r float32, exists bool) {
	v := m.addcar_maintain_normal_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainNormalDuration resets all changes to the "car_maintain_normal_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainNormalDuration() {
	m.car_maintain_normal_duration = nil
	m.addcar_maintain_normal_duration = nil
}

// SetCarMaintainFaultDuration sets the "car_maintain_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainFaultDuration(f float32) {
	m.car_maintain_fault_duration = &f
	m.addcar_maintain_fault_duration = nil
}

// CarMaintainFaultDuration returns the value of the "car_maintain_fault_duration" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainFaultDuration() (r float32, exists bool) {
	v := m.car_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainFaultDuration returns the old "car_maintain_fault_duration" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainFaultDuration(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainFaultDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainFaultDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainFaultDuration: %w", err)
	}
	return oldValue.CarMaintainFaultDuration, nil
}

// AddCarMaintainFaultDuration adds f to the "car_maintain_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainFaultDuration(f float32) {
	if m.addcar_maintain_fault_duration != nil {
		*m.addcar_maintain_fault_duration += f
	} else {
		m.addcar_maintain_fault_duration = &f
	}
}

// AddedCarMaintainFaultDuration returns the value that was added to the "car_maintain_fault_duration" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainFaultDuration() (r float32, exists bool) {
	v := m.addcar_maintain_fault_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainFaultDuration resets all changes to the "car_maintain_fault_duration" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainFaultDuration() {
	m.car_maintain_fault_duration = nil
	m.addcar_maintain_fault_duration = nil
}

// SetCarMaintainMileage sets the "car_maintain_mileage" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainMileage(f float32) {
	m.car_maintain_mileage = &f
	m.addcar_maintain_mileage = nil
}

// CarMaintainMileage returns the value of the "car_maintain_mileage" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainMileage() (r float32, exists bool) {
	v := m.car_maintain_mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainMileage returns the old "car_maintain_mileage" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainMileage(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainMileage: %w", err)
	}
	return oldValue.CarMaintainMileage, nil
}

// AddCarMaintainMileage adds f to the "car_maintain_mileage" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainMileage(f float32) {
	if m.addcar_maintain_mileage != nil {
		*m.addcar_maintain_mileage += f
	} else {
		m.addcar_maintain_mileage = &f
	}
}

// AddedCarMaintainMileage returns the value that was added to the "car_maintain_mileage" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainMileage() (r float32, exists bool) {
	v := m.addcar_maintain_mileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainMileage resets all changes to the "car_maintain_mileage" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainMileage() {
	m.car_maintain_mileage = nil
	m.addcar_maintain_mileage = nil
}

// SetCarMaintainFaultTimes sets the "car_maintain_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) SetCarMaintainFaultTimes(u uint32) {
	m.car_maintain_fault_times = &u
	m.addcar_maintain_fault_times = nil
}

// CarMaintainFaultTimes returns the value of the "car_maintain_fault_times" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarMaintainFaultTimes() (r uint32, exists bool) {
	v := m.car_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarMaintainFaultTimes returns the old "car_maintain_fault_times" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarMaintainFaultTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarMaintainFaultTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarMaintainFaultTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarMaintainFaultTimes: %w", err)
	}
	return oldValue.CarMaintainFaultTimes, nil
}

// AddCarMaintainFaultTimes adds u to the "car_maintain_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) AddCarMaintainFaultTimes(u int32) {
	if m.addcar_maintain_fault_times != nil {
		*m.addcar_maintain_fault_times += u
	} else {
		m.addcar_maintain_fault_times = &u
	}
}

// AddedCarMaintainFaultTimes returns the value that was added to the "car_maintain_fault_times" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarMaintainFaultTimes() (r int32, exists bool) {
	v := m.addcar_maintain_fault_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarMaintainFaultTimes resets all changes to the "car_maintain_fault_times" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarMaintainFaultTimes() {
	m.car_maintain_fault_times = nil
	m.addcar_maintain_fault_times = nil
}

// SetCarAlarmTimes sets the "car_alarm_times" field.
func (m *StatsHourlyScenicAreaMutation) SetCarAlarmTimes(u uint32) {
	m.car_alarm_times = &u
	m.addcar_alarm_times = nil
}

// CarAlarmTimes returns the value of the "car_alarm_times" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CarAlarmTimes() (r uint32, exists bool) {
	v := m.car_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// OldCarAlarmTimes returns the old "car_alarm_times" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCarAlarmTimes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarAlarmTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarAlarmTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarAlarmTimes: %w", err)
	}
	return oldValue.CarAlarmTimes, nil
}

// AddCarAlarmTimes adds u to the "car_alarm_times" field.
func (m *StatsHourlyScenicAreaMutation) AddCarAlarmTimes(u int32) {
	if m.addcar_alarm_times != nil {
		*m.addcar_alarm_times += u
	} else {
		m.addcar_alarm_times = &u
	}
}

// AddedCarAlarmTimes returns the value that was added to the "car_alarm_times" field in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedCarAlarmTimes() (r int32, exists bool) {
	v := m.addcar_alarm_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarAlarmTimes resets all changes to the "car_alarm_times" field.
func (m *StatsHourlyScenicAreaMutation) ResetCarAlarmTimes() {
	m.car_alarm_times = nil
	m.addcar_alarm_times = nil
}

// SetStatsTime sets the "stats_time" field.
func (m *StatsHourlyScenicAreaMutation) SetStatsTime(t time.Time) {
	m.stats_time = &t
}

// StatsTime returns the value of the "stats_time" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) StatsTime() (r time.Time, exists bool) {
	v := m.stats_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTime returns the old "stats_time" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldStatsTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTime: %w", err)
	}
	return oldValue.StatsTime, nil
}

// ResetStatsTime resets all changes to the "stats_time" field.
func (m *StatsHourlyScenicAreaMutation) ResetStatsTime() {
	m.stats_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *StatsHourlyScenicAreaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatsHourlyScenicAreaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatsHourlyScenicArea entity.
// If the StatsHourlyScenicArea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatsHourlyScenicAreaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatsHourlyScenicAreaMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the StatsHourlyScenicAreaMutation builder.
func (m *StatsHourlyScenicAreaMutation) Where(ps ...predicate.StatsHourlyScenicArea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatsHourlyScenicAreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatsHourlyScenicAreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatsHourlyScenicArea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatsHourlyScenicAreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatsHourlyScenicAreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatsHourlyScenicArea).
func (m *StatsHourlyScenicAreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatsHourlyScenicAreaMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.scenic_area_id != nil {
		fields = append(fields, statshourlyscenicarea.FieldScenicAreaID)
	}
	if m.y != nil {
		fields = append(fields, statshourlyscenicarea.FieldY)
	}
	if m.m != nil {
		fields = append(fields, statshourlyscenicarea.FieldM)
	}
	if m.d != nil {
		fields = append(fields, statshourlyscenicarea.FieldD)
	}
	if m.h != nil {
		fields = append(fields, statshourlyscenicarea.FieldH)
	}
	if m.week != nil {
		fields = append(fields, statshourlyscenicarea.FieldWeek)
	}
	if m.weekday != nil {
		fields = append(fields, statshourlyscenicarea.FieldWeekday)
	}
	if m.period != nil {
		fields = append(fields, statshourlyscenicarea.FieldPeriod)
	}
	if m.user_count_login != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountLogin)
	}
	if m.user_count_register != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountRegister)
	}
	if m.user_count_order != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountOrder)
	}
	if m.order_count_create != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountCreate)
	}
	if m.order_count_finish != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountFinish)
	}
	if m.order_count_cancel != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountCancel)
	}
	if m.order_amount != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderAmount)
	}
	if m.order_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderDuration)
	}
	if m.order_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderMileage)
	}
	if m.car_count_deploy != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarCountDeploy)
	}
	if m.car_count_operation != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarCountOperation)
	}
	if m.car_operation_manual_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationManualDuration)
	}
	if m.car_operation_auto_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationAutoDuration)
	}
	if m.car_operation_normal_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationNormalDuration)
	}
	if m.car_operation_fault_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationFaultDuration)
	}
	if m.car_operation_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationMileage)
	}
	if m.car_operation_fault_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationFaultTimes)
	}
	if m.car_maintain_manual_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainManualDuration)
	}
	if m.car_maintain_auto_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainAutoDuration)
	}
	if m.car_maintain_normal_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainNormalDuration)
	}
	if m.car_maintain_fault_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainFaultDuration)
	}
	if m.car_maintain_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainMileage)
	}
	if m.car_maintain_fault_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainFaultTimes)
	}
	if m.car_alarm_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarAlarmTimes)
	}
	if m.stats_time != nil {
		fields = append(fields, statshourlyscenicarea.FieldStatsTime)
	}
	if m.create_time != nil {
		fields = append(fields, statshourlyscenicarea.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatsHourlyScenicAreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		return m.ScenicAreaID()
	case statshourlyscenicarea.FieldY:
		return m.Y()
	case statshourlyscenicarea.FieldM:
		return m.M()
	case statshourlyscenicarea.FieldD:
		return m.D()
	case statshourlyscenicarea.FieldH:
		return m.H()
	case statshourlyscenicarea.FieldWeek:
		return m.Week()
	case statshourlyscenicarea.FieldWeekday:
		return m.Weekday()
	case statshourlyscenicarea.FieldPeriod:
		return m.Period()
	case statshourlyscenicarea.FieldUserCountLogin:
		return m.UserCountLogin()
	case statshourlyscenicarea.FieldUserCountRegister:
		return m.UserCountRegister()
	case statshourlyscenicarea.FieldUserCountOrder:
		return m.UserCountOrder()
	case statshourlyscenicarea.FieldOrderCountCreate:
		return m.OrderCountCreate()
	case statshourlyscenicarea.FieldOrderCountFinish:
		return m.OrderCountFinish()
	case statshourlyscenicarea.FieldOrderCountCancel:
		return m.OrderCountCancel()
	case statshourlyscenicarea.FieldOrderAmount:
		return m.OrderAmount()
	case statshourlyscenicarea.FieldOrderDuration:
		return m.OrderDuration()
	case statshourlyscenicarea.FieldOrderMileage:
		return m.OrderMileage()
	case statshourlyscenicarea.FieldCarCountDeploy:
		return m.CarCountDeploy()
	case statshourlyscenicarea.FieldCarCountOperation:
		return m.CarCountOperation()
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		return m.CarOperationManualDuration()
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		return m.CarOperationAutoDuration()
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		return m.CarOperationNormalDuration()
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		return m.CarOperationFaultDuration()
	case statshourlyscenicarea.FieldCarOperationMileage:
		return m.CarOperationMileage()
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		return m.CarOperationFaultTimes()
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		return m.CarMaintainManualDuration()
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		return m.CarMaintainAutoDuration()
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		return m.CarMaintainNormalDuration()
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		return m.CarMaintainFaultDuration()
	case statshourlyscenicarea.FieldCarMaintainMileage:
		return m.CarMaintainMileage()
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		return m.CarMaintainFaultTimes()
	case statshourlyscenicarea.FieldCarAlarmTimes:
		return m.CarAlarmTimes()
	case statshourlyscenicarea.FieldStatsTime:
		return m.StatsTime()
	case statshourlyscenicarea.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatsHourlyScenicAreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case statshourlyscenicarea.FieldY:
		return m.OldY(ctx)
	case statshourlyscenicarea.FieldM:
		return m.OldM(ctx)
	case statshourlyscenicarea.FieldD:
		return m.OldD(ctx)
	case statshourlyscenicarea.FieldH:
		return m.OldH(ctx)
	case statshourlyscenicarea.FieldWeek:
		return m.OldWeek(ctx)
	case statshourlyscenicarea.FieldWeekday:
		return m.OldWeekday(ctx)
	case statshourlyscenicarea.FieldPeriod:
		return m.OldPeriod(ctx)
	case statshourlyscenicarea.FieldUserCountLogin:
		return m.OldUserCountLogin(ctx)
	case statshourlyscenicarea.FieldUserCountRegister:
		return m.OldUserCountRegister(ctx)
	case statshourlyscenicarea.FieldUserCountOrder:
		return m.OldUserCountOrder(ctx)
	case statshourlyscenicarea.FieldOrderCountCreate:
		return m.OldOrderCountCreate(ctx)
	case statshourlyscenicarea.FieldOrderCountFinish:
		return m.OldOrderCountFinish(ctx)
	case statshourlyscenicarea.FieldOrderCountCancel:
		return m.OldOrderCountCancel(ctx)
	case statshourlyscenicarea.FieldOrderAmount:
		return m.OldOrderAmount(ctx)
	case statshourlyscenicarea.FieldOrderDuration:
		return m.OldOrderDuration(ctx)
	case statshourlyscenicarea.FieldOrderMileage:
		return m.OldOrderMileage(ctx)
	case statshourlyscenicarea.FieldCarCountDeploy:
		return m.OldCarCountDeploy(ctx)
	case statshourlyscenicarea.FieldCarCountOperation:
		return m.OldCarCountOperation(ctx)
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		return m.OldCarOperationManualDuration(ctx)
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		return m.OldCarOperationAutoDuration(ctx)
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		return m.OldCarOperationNormalDuration(ctx)
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		return m.OldCarOperationFaultDuration(ctx)
	case statshourlyscenicarea.FieldCarOperationMileage:
		return m.OldCarOperationMileage(ctx)
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		return m.OldCarOperationFaultTimes(ctx)
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		return m.OldCarMaintainManualDuration(ctx)
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		return m.OldCarMaintainAutoDuration(ctx)
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		return m.OldCarMaintainNormalDuration(ctx)
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		return m.OldCarMaintainFaultDuration(ctx)
	case statshourlyscenicarea.FieldCarMaintainMileage:
		return m.OldCarMaintainMileage(ctx)
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		return m.OldCarMaintainFaultTimes(ctx)
	case statshourlyscenicarea.FieldCarAlarmTimes:
		return m.OldCarAlarmTimes(ctx)
	case statshourlyscenicarea.FieldStatsTime:
		return m.OldStatsTime(ctx)
	case statshourlyscenicarea.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown StatsHourlyScenicArea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsHourlyScenicAreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case statshourlyscenicarea.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case statshourlyscenicarea.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetM(v)
		return nil
	case statshourlyscenicarea.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case statshourlyscenicarea.FieldH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH(v)
		return nil
	case statshourlyscenicarea.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeek(v)
		return nil
	case statshourlyscenicarea.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	case statshourlyscenicarea.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case statshourlyscenicarea.FieldUserCountLogin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountLogin(v)
		return nil
	case statshourlyscenicarea.FieldUserCountRegister:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountRegister(v)
		return nil
	case statshourlyscenicarea.FieldUserCountOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCountOrder(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCreate(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountFinish(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCountCancel(v)
		return nil
	case statshourlyscenicarea.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAmount(v)
		return nil
	case statshourlyscenicarea.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDuration(v)
		return nil
	case statshourlyscenicarea.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarCountDeploy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarCountDeploy(v)
		return nil
	case statshourlyscenicarea.FieldCarCountOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarCountOperation(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationManualDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationAutoDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationNormalDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationFaultDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarOperationFaultTimes(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainManualDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainAutoDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainNormalDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainFaultDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarMaintainFaultTimes(v)
		return nil
	case statshourlyscenicarea.FieldCarAlarmTimes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarAlarmTimes(v)
		return nil
	case statshourlyscenicarea.FieldStatsTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTime(v)
		return nil
	case statshourlyscenicarea.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyScenicArea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedFields() []string {
	var fields []string
	if m.addscenic_area_id != nil {
		fields = append(fields, statshourlyscenicarea.FieldScenicAreaID)
	}
	if m.addy != nil {
		fields = append(fields, statshourlyscenicarea.FieldY)
	}
	if m.addm != nil {
		fields = append(fields, statshourlyscenicarea.FieldM)
	}
	if m.addd != nil {
		fields = append(fields, statshourlyscenicarea.FieldD)
	}
	if m.addh != nil {
		fields = append(fields, statshourlyscenicarea.FieldH)
	}
	if m.addweek != nil {
		fields = append(fields, statshourlyscenicarea.FieldWeek)
	}
	if m.addweekday != nil {
		fields = append(fields, statshourlyscenicarea.FieldWeekday)
	}
	if m.addperiod != nil {
		fields = append(fields, statshourlyscenicarea.FieldPeriod)
	}
	if m.adduser_count_login != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountLogin)
	}
	if m.adduser_count_register != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountRegister)
	}
	if m.adduser_count_order != nil {
		fields = append(fields, statshourlyscenicarea.FieldUserCountOrder)
	}
	if m.addorder_count_create != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountCreate)
	}
	if m.addorder_count_finish != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountFinish)
	}
	if m.addorder_count_cancel != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderCountCancel)
	}
	if m.addorder_amount != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderAmount)
	}
	if m.addorder_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderDuration)
	}
	if m.addorder_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldOrderMileage)
	}
	if m.addcar_count_deploy != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarCountDeploy)
	}
	if m.addcar_count_operation != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarCountOperation)
	}
	if m.addcar_operation_manual_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationManualDuration)
	}
	if m.addcar_operation_auto_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationAutoDuration)
	}
	if m.addcar_operation_normal_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationNormalDuration)
	}
	if m.addcar_operation_fault_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationFaultDuration)
	}
	if m.addcar_operation_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationMileage)
	}
	if m.addcar_operation_fault_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarOperationFaultTimes)
	}
	if m.addcar_maintain_manual_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainManualDuration)
	}
	if m.addcar_maintain_auto_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainAutoDuration)
	}
	if m.addcar_maintain_normal_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainNormalDuration)
	}
	if m.addcar_maintain_fault_duration != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainFaultDuration)
	}
	if m.addcar_maintain_mileage != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainMileage)
	}
	if m.addcar_maintain_fault_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarMaintainFaultTimes)
	}
	if m.addcar_alarm_times != nil {
		fields = append(fields, statshourlyscenicarea.FieldCarAlarmTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatsHourlyScenicAreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		return m.AddedScenicAreaID()
	case statshourlyscenicarea.FieldY:
		return m.AddedY()
	case statshourlyscenicarea.FieldM:
		return m.AddedM()
	case statshourlyscenicarea.FieldD:
		return m.AddedD()
	case statshourlyscenicarea.FieldH:
		return m.AddedH()
	case statshourlyscenicarea.FieldWeek:
		return m.AddedWeek()
	case statshourlyscenicarea.FieldWeekday:
		return m.AddedWeekday()
	case statshourlyscenicarea.FieldPeriod:
		return m.AddedPeriod()
	case statshourlyscenicarea.FieldUserCountLogin:
		return m.AddedUserCountLogin()
	case statshourlyscenicarea.FieldUserCountRegister:
		return m.AddedUserCountRegister()
	case statshourlyscenicarea.FieldUserCountOrder:
		return m.AddedUserCountOrder()
	case statshourlyscenicarea.FieldOrderCountCreate:
		return m.AddedOrderCountCreate()
	case statshourlyscenicarea.FieldOrderCountFinish:
		return m.AddedOrderCountFinish()
	case statshourlyscenicarea.FieldOrderCountCancel:
		return m.AddedOrderCountCancel()
	case statshourlyscenicarea.FieldOrderAmount:
		return m.AddedOrderAmount()
	case statshourlyscenicarea.FieldOrderDuration:
		return m.AddedOrderDuration()
	case statshourlyscenicarea.FieldOrderMileage:
		return m.AddedOrderMileage()
	case statshourlyscenicarea.FieldCarCountDeploy:
		return m.AddedCarCountDeploy()
	case statshourlyscenicarea.FieldCarCountOperation:
		return m.AddedCarCountOperation()
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		return m.AddedCarOperationManualDuration()
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		return m.AddedCarOperationAutoDuration()
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		return m.AddedCarOperationNormalDuration()
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		return m.AddedCarOperationFaultDuration()
	case statshourlyscenicarea.FieldCarOperationMileage:
		return m.AddedCarOperationMileage()
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		return m.AddedCarOperationFaultTimes()
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		return m.AddedCarMaintainManualDuration()
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		return m.AddedCarMaintainAutoDuration()
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		return m.AddedCarMaintainNormalDuration()
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		return m.AddedCarMaintainFaultDuration()
	case statshourlyscenicarea.FieldCarMaintainMileage:
		return m.AddedCarMaintainMileage()
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		return m.AddedCarMaintainFaultTimes()
	case statshourlyscenicarea.FieldCarAlarmTimes:
		return m.AddedCarAlarmTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatsHourlyScenicAreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScenicAreaID(v)
		return nil
	case statshourlyscenicarea.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	case statshourlyscenicarea.FieldM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddM(v)
		return nil
	case statshourlyscenicarea.FieldD:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddD(v)
		return nil
	case statshourlyscenicarea.FieldH:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddH(v)
		return nil
	case statshourlyscenicarea.FieldWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeek(v)
		return nil
	case statshourlyscenicarea.FieldWeekday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekday(v)
		return nil
	case statshourlyscenicarea.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case statshourlyscenicarea.FieldUserCountLogin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountLogin(v)
		return nil
	case statshourlyscenicarea.FieldUserCountRegister:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountRegister(v)
		return nil
	case statshourlyscenicarea.FieldUserCountOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCountOrder(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountCreate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCreate(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountFinish:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountFinish(v)
		return nil
	case statshourlyscenicarea.FieldOrderCountCancel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCountCancel(v)
		return nil
	case statshourlyscenicarea.FieldOrderAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAmount(v)
		return nil
	case statshourlyscenicarea.FieldOrderDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDuration(v)
		return nil
	case statshourlyscenicarea.FieldOrderMileage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarCountDeploy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarCountDeploy(v)
		return nil
	case statshourlyscenicarea.FieldCarCountOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarCountOperation(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationManualDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationAutoDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationNormalDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationFaultDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarOperationFaultTimes(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainManualDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainAutoDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainNormalDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainFaultDuration(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainMileage:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainMileage(v)
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarMaintainFaultTimes(v)
		return nil
	case statshourlyscenicarea.FieldCarAlarmTimes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarAlarmTimes(v)
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyScenicArea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatsHourlyScenicAreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatsHourlyScenicAreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatsHourlyScenicAreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatsHourlyScenicArea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatsHourlyScenicAreaMutation) ResetField(name string) error {
	switch name {
	case statshourlyscenicarea.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case statshourlyscenicarea.FieldY:
		m.ResetY()
		return nil
	case statshourlyscenicarea.FieldM:
		m.ResetM()
		return nil
	case statshourlyscenicarea.FieldD:
		m.ResetD()
		return nil
	case statshourlyscenicarea.FieldH:
		m.ResetH()
		return nil
	case statshourlyscenicarea.FieldWeek:
		m.ResetWeek()
		return nil
	case statshourlyscenicarea.FieldWeekday:
		m.ResetWeekday()
		return nil
	case statshourlyscenicarea.FieldPeriod:
		m.ResetPeriod()
		return nil
	case statshourlyscenicarea.FieldUserCountLogin:
		m.ResetUserCountLogin()
		return nil
	case statshourlyscenicarea.FieldUserCountRegister:
		m.ResetUserCountRegister()
		return nil
	case statshourlyscenicarea.FieldUserCountOrder:
		m.ResetUserCountOrder()
		return nil
	case statshourlyscenicarea.FieldOrderCountCreate:
		m.ResetOrderCountCreate()
		return nil
	case statshourlyscenicarea.FieldOrderCountFinish:
		m.ResetOrderCountFinish()
		return nil
	case statshourlyscenicarea.FieldOrderCountCancel:
		m.ResetOrderCountCancel()
		return nil
	case statshourlyscenicarea.FieldOrderAmount:
		m.ResetOrderAmount()
		return nil
	case statshourlyscenicarea.FieldOrderDuration:
		m.ResetOrderDuration()
		return nil
	case statshourlyscenicarea.FieldOrderMileage:
		m.ResetOrderMileage()
		return nil
	case statshourlyscenicarea.FieldCarCountDeploy:
		m.ResetCarCountDeploy()
		return nil
	case statshourlyscenicarea.FieldCarCountOperation:
		m.ResetCarCountOperation()
		return nil
	case statshourlyscenicarea.FieldCarOperationManualDuration:
		m.ResetCarOperationManualDuration()
		return nil
	case statshourlyscenicarea.FieldCarOperationAutoDuration:
		m.ResetCarOperationAutoDuration()
		return nil
	case statshourlyscenicarea.FieldCarOperationNormalDuration:
		m.ResetCarOperationNormalDuration()
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultDuration:
		m.ResetCarOperationFaultDuration()
		return nil
	case statshourlyscenicarea.FieldCarOperationMileage:
		m.ResetCarOperationMileage()
		return nil
	case statshourlyscenicarea.FieldCarOperationFaultTimes:
		m.ResetCarOperationFaultTimes()
		return nil
	case statshourlyscenicarea.FieldCarMaintainManualDuration:
		m.ResetCarMaintainManualDuration()
		return nil
	case statshourlyscenicarea.FieldCarMaintainAutoDuration:
		m.ResetCarMaintainAutoDuration()
		return nil
	case statshourlyscenicarea.FieldCarMaintainNormalDuration:
		m.ResetCarMaintainNormalDuration()
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultDuration:
		m.ResetCarMaintainFaultDuration()
		return nil
	case statshourlyscenicarea.FieldCarMaintainMileage:
		m.ResetCarMaintainMileage()
		return nil
	case statshourlyscenicarea.FieldCarMaintainFaultTimes:
		m.ResetCarMaintainFaultTimes()
		return nil
	case statshourlyscenicarea.FieldCarAlarmTimes:
		m.ResetCarAlarmTimes()
		return nil
	case statshourlyscenicarea.FieldStatsTime:
		m.ResetStatsTime()
		return nil
	case statshourlyscenicarea.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown StatsHourlyScenicArea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatsHourlyScenicAreaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatsHourlyScenicAreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatsHourlyScenicAreaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatsHourlyScenicAreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatsHourlyScenicAreaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatsHourlyScenicAreaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StatsHourlyScenicArea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatsHourlyScenicAreaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StatsHourlyScenicArea edge %s", name)
}

// SystemConfigMutation represents an operation that mutates the SystemConfig nodes in the graph.
type SystemConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int
	group         *systemconfig.Group
	name          *string
	key           *string
	value         *string
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemConfig, error)
	predicates    []predicate.SystemConfig
}

var _ ent.Mutation = (*SystemConfigMutation)(nil)

// systemconfigOption allows management of the mutation configuration using functional options.
type systemconfigOption func(*SystemConfigMutation)

// newSystemConfigMutation creates new mutation for the SystemConfig entity.
func newSystemConfigMutation(c config, op Op, opts ...systemconfigOption) *SystemConfigMutation {
	m := &SystemConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemConfigID sets the ID field of the mutation.
func withSystemConfigID(id int) systemconfigOption {
	return func(m *SystemConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemConfig
		)
		m.oldValue = func(ctx context.Context) (*SystemConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemConfig sets the old SystemConfig of the mutation.
func withSystemConfig(node *SystemConfig) systemconfigOption {
	return func(m *SystemConfigMutation) {
		m.oldValue = func(context.Context) (*SystemConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemConfig entities.
func (m *SystemConfigMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroup sets the "group" field.
func (m *SystemConfigMutation) SetGroup(s systemconfig.Group) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *SystemConfigMutation) Group() (r systemconfig.Group, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldGroup(ctx context.Context) (v systemconfig.Group, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *SystemConfigMutation) ResetGroup() {
	m.group = nil
}

// SetName sets the "name" field.
func (m *SystemConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemConfigMutation) ResetName() {
	m.name = nil
}

// SetKey sets the "key" field.
func (m *SystemConfigMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SystemConfigMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SystemConfigMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SystemConfigMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SystemConfigMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SystemConfigMutation) ResetValue() {
	m.value = nil
}

// SetCreateTime sets the "create_time" field.
func (m *SystemConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SystemConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SystemConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SystemConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SystemConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SystemConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the SystemConfigMutation builder.
func (m *SystemConfigMutation) Where(ps ...predicate.SystemConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemConfig).
func (m *SystemConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemConfigMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.group != nil {
		fields = append(fields, systemconfig.FieldGroup)
	}
	if m.name != nil {
		fields = append(fields, systemconfig.FieldName)
	}
	if m.key != nil {
		fields = append(fields, systemconfig.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, systemconfig.FieldValue)
	}
	if m.create_time != nil {
		fields = append(fields, systemconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, systemconfig.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemconfig.FieldGroup:
		return m.Group()
	case systemconfig.FieldName:
		return m.Name()
	case systemconfig.FieldKey:
		return m.Key()
	case systemconfig.FieldValue:
		return m.Value()
	case systemconfig.FieldCreateTime:
		return m.CreateTime()
	case systemconfig.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemconfig.FieldGroup:
		return m.OldGroup(ctx)
	case systemconfig.FieldName:
		return m.OldName(ctx)
	case systemconfig.FieldKey:
		return m.OldKey(ctx)
	case systemconfig.FieldValue:
		return m.OldValue(ctx)
	case systemconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case systemconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown SystemConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemconfig.FieldGroup:
		v, ok := value.(systemconfig.Group)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case systemconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemconfig.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case systemconfig.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case systemconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case systemconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown SystemConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemConfigMutation) ResetField(name string) error {
	switch name {
	case systemconfig.FieldGroup:
		m.ResetGroup()
		return nil
	case systemconfig.FieldName:
		m.ResetName()
		return nil
	case systemconfig.FieldKey:
		m.ResetKey()
		return nil
	case systemconfig.FieldValue:
		m.ResetValue()
		return nil
	case systemconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case systemconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown SystemConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemConfig edge %s", name)
}

// SystemLogMutation represents an operation that mutates the SystemLog nodes in the graph.
type SystemLogMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	timestamp     *int
	addtimestamp  *int
	action        *string
	user          *string
	scenic_area   *string
	source_ip     *string
	login_type    *systemlog.LoginType
	content       *string
	status        *systemlog.Status
	remarks       *string
	create_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemLog, error)
	predicates    []predicate.SystemLog
}

var _ ent.Mutation = (*SystemLogMutation)(nil)

// systemlogOption allows management of the mutation configuration using functional options.
type systemlogOption func(*SystemLogMutation)

// newSystemLogMutation creates new mutation for the SystemLog entity.
func newSystemLogMutation(c config, op Op, opts ...systemlogOption) *SystemLogMutation {
	m := &SystemLogMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemLogID sets the ID field of the mutation.
func withSystemLogID(id uint64) systemlogOption {
	return func(m *SystemLogMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemLog
		)
		m.oldValue = func(ctx context.Context) (*SystemLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemLog sets the old SystemLog of the mutation.
func withSystemLog(node *SystemLog) systemlogOption {
	return func(m *SystemLogMutation) {
		m.oldValue = func(context.Context) (*SystemLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemLog entities.
func (m *SystemLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemLogMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SystemLogMutation) SetTimestamp(i int) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SystemLogMutation) Timestamp() (r int, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldTimestamp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *SystemLogMutation) AddTimestamp(i int) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *SystemLogMutation) AddedTimestamp() (r int, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SystemLogMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// SetAction sets the "action" field.
func (m *SystemLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SystemLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *SystemLogMutation) ResetAction() {
	m.action = nil
}

// SetUser sets the "user" field.
func (m *SystemLogMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *SystemLogMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *SystemLogMutation) ResetUser() {
	m.user = nil
}

// SetScenicArea sets the "scenic_area" field.
func (m *SystemLogMutation) SetScenicArea(s string) {
	m.scenic_area = &s
}

// ScenicArea returns the value of the "scenic_area" field in the mutation.
func (m *SystemLogMutation) ScenicArea() (r string, exists bool) {
	v := m.scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicArea returns the old "scenic_area" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldScenicArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicArea: %w", err)
	}
	return oldValue.ScenicArea, nil
}

// ResetScenicArea resets all changes to the "scenic_area" field.
func (m *SystemLogMutation) ResetScenicArea() {
	m.scenic_area = nil
}

// SetSourceIP sets the "source_ip" field.
func (m *SystemLogMutation) SetSourceIP(s string) {
	m.source_ip = &s
}

// SourceIP returns the value of the "source_ip" field in the mutation.
func (m *SystemLogMutation) SourceIP() (r string, exists bool) {
	v := m.source_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceIP returns the old "source_ip" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldSourceIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceIP: %w", err)
	}
	return oldValue.SourceIP, nil
}

// ResetSourceIP resets all changes to the "source_ip" field.
func (m *SystemLogMutation) ResetSourceIP() {
	m.source_ip = nil
}

// SetLoginType sets the "login_type" field.
func (m *SystemLogMutation) SetLoginType(st systemlog.LoginType) {
	m.login_type = &st
}

// LoginType returns the value of the "login_type" field in the mutation.
func (m *SystemLogMutation) LoginType() (r systemlog.LoginType, exists bool) {
	v := m.login_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginType returns the old "login_type" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldLoginType(ctx context.Context) (v systemlog.LoginType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginType: %w", err)
	}
	return oldValue.LoginType, nil
}

// ResetLoginType resets all changes to the "login_type" field.
func (m *SystemLogMutation) ResetLoginType() {
	m.login_type = nil
}

// SetContent sets the "content" field.
func (m *SystemLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SystemLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SystemLogMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *SystemLogMutation) SetStatus(s systemlog.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemLogMutation) Status() (r systemlog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldStatus(ctx context.Context) (v systemlog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemLogMutation) ResetStatus() {
	m.status = nil
}

// SetRemarks sets the "remarks" field.
func (m *SystemLogMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the value of the "remarks" field in the mutation.
func (m *SystemLogMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old "remarks" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemarks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of the "remarks" field.
func (m *SystemLogMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[systemlog.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the "remarks" field was cleared in this mutation.
func (m *SystemLogMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[systemlog.FieldRemarks]
	return ok
}

// ResetRemarks resets all changes to the "remarks" field.
func (m *SystemLogMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, systemlog.FieldRemarks)
}

// SetCreateTime sets the "create_time" field.
func (m *SystemLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SystemLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SystemLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// Where appends a list predicates to the SystemLogMutation builder.
func (m *SystemLogMutation) Where(ps ...predicate.SystemLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemLog).
func (m *SystemLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.timestamp != nil {
		fields = append(fields, systemlog.FieldTimestamp)
	}
	if m.action != nil {
		fields = append(fields, systemlog.FieldAction)
	}
	if m.user != nil {
		fields = append(fields, systemlog.FieldUser)
	}
	if m.scenic_area != nil {
		fields = append(fields, systemlog.FieldScenicArea)
	}
	if m.source_ip != nil {
		fields = append(fields, systemlog.FieldSourceIP)
	}
	if m.login_type != nil {
		fields = append(fields, systemlog.FieldLoginType)
	}
	if m.content != nil {
		fields = append(fields, systemlog.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, systemlog.FieldStatus)
	}
	if m.remarks != nil {
		fields = append(fields, systemlog.FieldRemarks)
	}
	if m.create_time != nil {
		fields = append(fields, systemlog.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemlog.FieldTimestamp:
		return m.Timestamp()
	case systemlog.FieldAction:
		return m.Action()
	case systemlog.FieldUser:
		return m.User()
	case systemlog.FieldScenicArea:
		return m.ScenicArea()
	case systemlog.FieldSourceIP:
		return m.SourceIP()
	case systemlog.FieldLoginType:
		return m.LoginType()
	case systemlog.FieldContent:
		return m.Content()
	case systemlog.FieldStatus:
		return m.Status()
	case systemlog.FieldRemarks:
		return m.Remarks()
	case systemlog.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case systemlog.FieldAction:
		return m.OldAction(ctx)
	case systemlog.FieldUser:
		return m.OldUser(ctx)
	case systemlog.FieldScenicArea:
		return m.OldScenicArea(ctx)
	case systemlog.FieldSourceIP:
		return m.OldSourceIP(ctx)
	case systemlog.FieldLoginType:
		return m.OldLoginType(ctx)
	case systemlog.FieldContent:
		return m.OldContent(ctx)
	case systemlog.FieldStatus:
		return m.OldStatus(ctx)
	case systemlog.FieldRemarks:
		return m.OldRemarks(ctx)
	case systemlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown SystemLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemlog.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case systemlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case systemlog.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case systemlog.FieldScenicArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicArea(v)
		return nil
	case systemlog.FieldSourceIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceIP(v)
		return nil
	case systemlog.FieldLoginType:
		v, ok := value.(systemlog.LoginType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginType(v)
		return nil
	case systemlog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case systemlog.FieldStatus:
		v, ok := value.(systemlog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemlog.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case systemlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown SystemLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemLogMutation) AddedFields() []string {
	var fields []string
	if m.addtimestamp != nil {
		fields = append(fields, systemlog.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemlog.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemlog.FieldTimestamp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown SystemLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemlog.FieldRemarks) {
		fields = append(fields, systemlog.FieldRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemLogMutation) ClearField(name string) error {
	switch name {
	case systemlog.FieldRemarks:
		m.ClearRemarks()
		return nil
	}
	return fmt.Errorf("unknown SystemLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemLogMutation) ResetField(name string) error {
	switch name {
	case systemlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case systemlog.FieldAction:
		m.ResetAction()
		return nil
	case systemlog.FieldUser:
		m.ResetUser()
		return nil
	case systemlog.FieldScenicArea:
		m.ResetScenicArea()
		return nil
	case systemlog.FieldSourceIP:
		m.ResetSourceIP()
		return nil
	case systemlog.FieldLoginType:
		m.ResetLoginType()
		return nil
	case systemlog.FieldContent:
		m.ResetContent()
		return nil
	case systemlog.FieldStatus:
		m.ResetStatus()
		return nil
	case systemlog.FieldRemarks:
		m.ResetRemarks()
		return nil
	case systemlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown SystemLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemLog edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *string
	rel_id        *int
	addrel_id     *int
	rel_data      *any
	state         *int
	addstate      *int
	try_times     *int
	addtry_times  *int
	error_msg     *string
	start_time    *time.Time
	next_time     *time.Time
	end_time      *time.Time
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetRelID sets the "rel_id" field.
func (m *TaskMutation) SetRelID(i int) {
	m.rel_id = &i
	m.addrel_id = nil
}

// RelID returns the value of the "rel_id" field in the mutation.
func (m *TaskMutation) RelID() (r int, exists bool) {
	v := m.rel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRelID returns the old "rel_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelID: %w", err)
	}
	return oldValue.RelID, nil
}

// AddRelID adds i to the "rel_id" field.
func (m *TaskMutation) AddRelID(i int) {
	if m.addrel_id != nil {
		*m.addrel_id += i
	} else {
		m.addrel_id = &i
	}
}

// AddedRelID returns the value that was added to the "rel_id" field in this mutation.
func (m *TaskMutation) AddedRelID() (r int, exists bool) {
	v := m.addrel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRelID resets all changes to the "rel_id" field.
func (m *TaskMutation) ResetRelID() {
	m.rel_id = nil
	m.addrel_id = nil
}

// SetRelData sets the "rel_data" field.
func (m *TaskMutation) SetRelData(a any) {
	m.rel_data = &a
}

// RelData returns the value of the "rel_data" field in the mutation.
func (m *TaskMutation) RelData() (r any, exists bool) {
	v := m.rel_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRelData returns the old "rel_data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRelData(ctx context.Context) (v any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelData: %w", err)
	}
	return oldValue.RelData, nil
}

// ClearRelData clears the value of the "rel_data" field.
func (m *TaskMutation) ClearRelData() {
	m.rel_data = nil
	m.clearedFields[task.FieldRelData] = struct{}{}
}

// RelDataCleared returns if the "rel_data" field was cleared in this mutation.
func (m *TaskMutation) RelDataCleared() bool {
	_, ok := m.clearedFields[task.FieldRelData]
	return ok
}

// ResetRelData resets all changes to the "rel_data" field.
func (m *TaskMutation) ResetRelData() {
	m.rel_data = nil
	delete(m.clearedFields, task.FieldRelData)
}

// SetState sets the "state" field.
func (m *TaskMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *TaskMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *TaskMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *TaskMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *TaskMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetTryTimes sets the "try_times" field.
func (m *TaskMutation) SetTryTimes(i int) {
	m.try_times = &i
	m.addtry_times = nil
}

// TryTimes returns the value of the "try_times" field in the mutation.
func (m *TaskMutation) TryTimes() (r int, exists bool) {
	v := m.try_times
	if v == nil {
		return
	}
	return *v, true
}

// OldTryTimes returns the old "try_times" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTryTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTryTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTryTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTryTimes: %w", err)
	}
	return oldValue.TryTimes, nil
}

// AddTryTimes adds i to the "try_times" field.
func (m *TaskMutation) AddTryTimes(i int) {
	if m.addtry_times != nil {
		*m.addtry_times += i
	} else {
		m.addtry_times = &i
	}
}

// AddedTryTimes returns the value that was added to the "try_times" field in this mutation.
func (m *TaskMutation) AddedTryTimes() (r int, exists bool) {
	v := m.addtry_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetTryTimes resets all changes to the "try_times" field.
func (m *TaskMutation) ResetTryTimes() {
	m.try_times = nil
	m.addtry_times = nil
}

// SetErrorMsg sets the "error_msg" field.
func (m *TaskMutation) SetErrorMsg(s string) {
	m.error_msg = &s
}

// ErrorMsg returns the value of the "error_msg" field in the mutation.
func (m *TaskMutation) ErrorMsg() (r string, exists bool) {
	v := m.error_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMsg returns the old "error_msg" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldErrorMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMsg: %w", err)
	}
	return oldValue.ErrorMsg, nil
}

// ResetErrorMsg resets all changes to the "error_msg" field.
func (m *TaskMutation) ResetErrorMsg() {
	m.error_msg = nil
}

// SetStartTime sets the "start_time" field.
func (m *TaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TaskMutation) ResetStartTime() {
	m.start_time = nil
}

// SetNextTime sets the "next_time" field.
func (m *TaskMutation) SetNextTime(t time.Time) {
	m.next_time = &t
}

// NextTime returns the value of the "next_time" field in the mutation.
func (m *TaskMutation) NextTime() (r time.Time, exists bool) {
	v := m.next_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextTime returns the old "next_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNextTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextTime: %w", err)
	}
	return oldValue.NextTime, nil
}

// ResetNextTime resets all changes to the "next_time" field.
func (m *TaskMutation) ResetNextTime() {
	m.next_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *TaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *TaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *TaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[task.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *TaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *TaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, task.FieldEndTime)
}

// SetCreateTime sets the "create_time" field.
func (m *TaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.rel_id != nil {
		fields = append(fields, task.FieldRelID)
	}
	if m.rel_data != nil {
		fields = append(fields, task.FieldRelData)
	}
	if m.state != nil {
		fields = append(fields, task.FieldState)
	}
	if m.try_times != nil {
		fields = append(fields, task.FieldTryTimes)
	}
	if m.error_msg != nil {
		fields = append(fields, task.FieldErrorMsg)
	}
	if m.start_time != nil {
		fields = append(fields, task.FieldStartTime)
	}
	if m.next_time != nil {
		fields = append(fields, task.FieldNextTime)
	}
	if m.end_time != nil {
		fields = append(fields, task.FieldEndTime)
	}
	if m.create_time != nil {
		fields = append(fields, task.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, task.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldType:
		return m.GetType()
	case task.FieldRelID:
		return m.RelID()
	case task.FieldRelData:
		return m.RelData()
	case task.FieldState:
		return m.State()
	case task.FieldTryTimes:
		return m.TryTimes()
	case task.FieldErrorMsg:
		return m.ErrorMsg()
	case task.FieldStartTime:
		return m.StartTime()
	case task.FieldNextTime:
		return m.NextTime()
	case task.FieldEndTime:
		return m.EndTime()
	case task.FieldCreateTime:
		return m.CreateTime()
	case task.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldRelID:
		return m.OldRelID(ctx)
	case task.FieldRelData:
		return m.OldRelData(ctx)
	case task.FieldState:
		return m.OldState(ctx)
	case task.FieldTryTimes:
		return m.OldTryTimes(ctx)
	case task.FieldErrorMsg:
		return m.OldErrorMsg(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	case task.FieldNextTime:
		return m.OldNextTime(ctx)
	case task.FieldEndTime:
		return m.OldEndTime(ctx)
	case task.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case task.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldRelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelID(v)
		return nil
	case task.FieldRelData:
		v, ok := value.(any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelData(v)
		return nil
	case task.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case task.FieldTryTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTryTimes(v)
		return nil
	case task.FieldErrorMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMsg(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case task.FieldNextTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextTime(v)
		return nil
	case task.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case task.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case task.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addrel_id != nil {
		fields = append(fields, task.FieldRelID)
	}
	if m.addstate != nil {
		fields = append(fields, task.FieldState)
	}
	if m.addtry_times != nil {
		fields = append(fields, task.FieldTryTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldRelID:
		return m.AddedRelID()
	case task.FieldState:
		return m.AddedState()
	case task.FieldTryTimes:
		return m.AddedTryTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldRelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelID(v)
		return nil
	case task.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case task.FieldTryTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTryTimes(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldRelData) {
		fields = append(fields, task.FieldRelData)
	}
	if m.FieldCleared(task.FieldEndTime) {
		fields = append(fields, task.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldRelData:
		m.ClearRelData()
		return nil
	case task.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldRelID:
		m.ResetRelID()
		return nil
	case task.FieldRelData:
		m.ResetRelData()
		return nil
	case task.FieldState:
		m.ResetState()
		return nil
	case task.FieldTryTimes:
		m.ResetTryTimes()
		return nil
	case task.FieldErrorMsg:
		m.ResetErrorMsg()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	case task.FieldNextTime:
		m.ResetNextTime()
		return nil
	case task.FieldEndTime:
		m.ResetEndTime()
		return nil
	case task.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case task.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	origin                        *int
	addorigin                     *int
	user_cls                      *int
	adduser_cls                   *int
	open_id                       *string
	username                      *string
	nickname                      *string
	phone                         *string
	avatar_url                    *string
	gender                        *uint8
	addgender                     *int8
	password                      *string
	country                       *string
	province                      *string
	city                          *string
	status                        *int
	addstatus                     *int
	is_deleted                    *uint8
	addis_deleted                 *int8
	login_time                    *time.Time
	language                      *string
	is_tester                     *bool
	create_time                   *time.Time
	update_time                   *time.Time
	clearedFields                 map[string]struct{}
	background_scenic_area        *int
	clearedbackground_scenic_area bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScenicAreaID sets the "scenic_area_id" field.
func (m *UserMutation) SetScenicAreaID(i int) {
	m.background_scenic_area = &i
}

// ScenicAreaID returns the value of the "scenic_area_id" field in the mutation.
func (m *UserMutation) ScenicAreaID() (r int, exists bool) {
	v := m.background_scenic_area
	if v == nil {
		return
	}
	return *v, true
}

// OldScenicAreaID returns the old "scenic_area_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScenicAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScenicAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScenicAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScenicAreaID: %w", err)
	}
	return oldValue.ScenicAreaID, nil
}

// ClearScenicAreaID clears the value of the "scenic_area_id" field.
func (m *UserMutation) ClearScenicAreaID() {
	m.background_scenic_area = nil
	m.clearedFields[user.FieldScenicAreaID] = struct{}{}
}

// ScenicAreaIDCleared returns if the "scenic_area_id" field was cleared in this mutation.
func (m *UserMutation) ScenicAreaIDCleared() bool {
	_, ok := m.clearedFields[user.FieldScenicAreaID]
	return ok
}

// ResetScenicAreaID resets all changes to the "scenic_area_id" field.
func (m *UserMutation) ResetScenicAreaID() {
	m.background_scenic_area = nil
	delete(m.clearedFields, user.FieldScenicAreaID)
}

// SetOrigin sets the "origin" field.
func (m *UserMutation) SetOrigin(i int) {
	m.origin = &i
	m.addorigin = nil
}

// Origin returns the value of the "origin" field in the mutation.
func (m *UserMutation) Origin() (r int, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrigin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// AddOrigin adds i to the "origin" field.
func (m *UserMutation) AddOrigin(i int) {
	if m.addorigin != nil {
		*m.addorigin += i
	} else {
		m.addorigin = &i
	}
}

// AddedOrigin returns the value that was added to the "origin" field in this mutation.
func (m *UserMutation) AddedOrigin() (r int, exists bool) {
	v := m.addorigin
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrigin resets all changes to the "origin" field.
func (m *UserMutation) ResetOrigin() {
	m.origin = nil
	m.addorigin = nil
}

// SetUserCls sets the "user_cls" field.
func (m *UserMutation) SetUserCls(i int) {
	m.user_cls = &i
	m.adduser_cls = nil
}

// UserCls returns the value of the "user_cls" field in the mutation.
func (m *UserMutation) UserCls() (r int, exists bool) {
	v := m.user_cls
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCls returns the old "user_cls" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserCls(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCls: %w", err)
	}
	return oldValue.UserCls, nil
}

// AddUserCls adds i to the "user_cls" field.
func (m *UserMutation) AddUserCls(i int) {
	if m.adduser_cls != nil {
		*m.adduser_cls += i
	} else {
		m.adduser_cls = &i
	}
}

// AddedUserCls returns the value that was added to the "user_cls" field in this mutation.
func (m *UserMutation) AddedUserCls() (r int, exists bool) {
	v := m.adduser_cls
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserCls resets all changes to the "user_cls" field.
func (m *UserMutation) ResetUserCls() {
	m.user_cls = nil
	m.adduser_cls = nil
}

// SetOpenID sets the "open_id" field.
func (m *UserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *UserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *UserMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(u uint8) {
	m.gender = &u
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r uint8, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds u to the "gender" field.
func (m *UserMutation) AddGender(u int8) {
	if m.addgender != nil {
		*m.addgender += u
	} else {
		m.addgender = &u
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int8, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetCountry sets the "country" field.
func (m *UserMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *UserMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the "province" field.
func (m *UserMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *UserMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *UserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserMutation) ResetCity() {
	m.city = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *UserMutation) SetIsDeleted(u uint8) {
	m.is_deleted = &u
	m.addis_deleted = nil
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *UserMutation) IsDeleted() (r uint8, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsDeleted(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// AddIsDeleted adds u to the "is_deleted" field.
func (m *UserMutation) AddIsDeleted(u int8) {
	if m.addis_deleted != nil {
		*m.addis_deleted += u
	} else {
		m.addis_deleted = &u
	}
}

// AddedIsDeleted returns the value that was added to the "is_deleted" field in this mutation.
func (m *UserMutation) AddedIsDeleted() (r int8, exists bool) {
	v := m.addis_deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *UserMutation) ResetIsDeleted() {
	m.is_deleted = nil
	m.addis_deleted = nil
}

// SetLoginTime sets the "login_time" field.
func (m *UserMutation) SetLoginTime(t time.Time) {
	m.login_time = &t
}

// LoginTime returns the value of the "login_time" field in the mutation.
func (m *UserMutation) LoginTime() (r time.Time, exists bool) {
	v := m.login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTime returns the old "login_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTime: %w", err)
	}
	return oldValue.LoginTime, nil
}

// ClearLoginTime clears the value of the "login_time" field.
func (m *UserMutation) ClearLoginTime() {
	m.login_time = nil
	m.clearedFields[user.FieldLoginTime] = struct{}{}
}

// LoginTimeCleared returns if the "login_time" field was cleared in this mutation.
func (m *UserMutation) LoginTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldLoginTime]
	return ok
}

// ResetLoginTime resets all changes to the "login_time" field.
func (m *UserMutation) ResetLoginTime() {
	m.login_time = nil
	delete(m.clearedFields, user.FieldLoginTime)
}

// SetLanguage sets the "language" field.
func (m *UserMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserMutation) ResetLanguage() {
	m.language = nil
}

// SetIsTester sets the "is_tester" field.
func (m *UserMutation) SetIsTester(b bool) {
	m.is_tester = &b
}

// IsTester returns the value of the "is_tester" field in the mutation.
func (m *UserMutation) IsTester() (r bool, exists bool) {
	v := m.is_tester
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTester returns the old "is_tester" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsTester(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTester is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTester requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTester: %w", err)
	}
	return oldValue.IsTester, nil
}

// ResetIsTester resets all changes to the "is_tester" field.
func (m *UserMutation) ResetIsTester() {
	m.is_tester = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBackgroundScenicAreaID sets the "background_scenic_area" edge to the ScenicArea entity by id.
func (m *UserMutation) SetBackgroundScenicAreaID(id int) {
	m.background_scenic_area = &id
}

// ClearBackgroundScenicArea clears the "background_scenic_area" edge to the ScenicArea entity.
func (m *UserMutation) ClearBackgroundScenicArea() {
	m.clearedbackground_scenic_area = true
	m.clearedFields[user.FieldScenicAreaID] = struct{}{}
}

// BackgroundScenicAreaCleared reports if the "background_scenic_area" edge to the ScenicArea entity was cleared.
func (m *UserMutation) BackgroundScenicAreaCleared() bool {
	return m.ScenicAreaIDCleared() || m.clearedbackground_scenic_area
}

// BackgroundScenicAreaID returns the "background_scenic_area" edge ID in the mutation.
func (m *UserMutation) BackgroundScenicAreaID() (id int, exists bool) {
	if m.background_scenic_area != nil {
		return *m.background_scenic_area, true
	}
	return
}

// BackgroundScenicAreaIDs returns the "background_scenic_area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BackgroundScenicAreaID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BackgroundScenicAreaIDs() (ids []int) {
	if id := m.background_scenic_area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBackgroundScenicArea resets all changes to the "background_scenic_area" edge.
func (m *UserMutation) ResetBackgroundScenicArea() {
	m.background_scenic_area = nil
	m.clearedbackground_scenic_area = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.background_scenic_area != nil {
		fields = append(fields, user.FieldScenicAreaID)
	}
	if m.origin != nil {
		fields = append(fields, user.FieldOrigin)
	}
	if m.user_cls != nil {
		fields = append(fields, user.FieldUserCls)
	}
	if m.open_id != nil {
		fields = append(fields, user.FieldOpenID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.country != nil {
		fields = append(fields, user.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, user.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, user.FieldCity)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, user.FieldIsDeleted)
	}
	if m.login_time != nil {
		fields = append(fields, user.FieldLoginTime)
	}
	if m.language != nil {
		fields = append(fields, user.FieldLanguage)
	}
	if m.is_tester != nil {
		fields = append(fields, user.FieldIsTester)
	}
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldScenicAreaID:
		return m.ScenicAreaID()
	case user.FieldOrigin:
		return m.Origin()
	case user.FieldUserCls:
		return m.UserCls()
	case user.FieldOpenID:
		return m.OpenID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldGender:
		return m.Gender()
	case user.FieldPassword:
		return m.Password()
	case user.FieldCountry:
		return m.Country()
	case user.FieldProvince:
		return m.Province()
	case user.FieldCity:
		return m.City()
	case user.FieldStatus:
		return m.Status()
	case user.FieldIsDeleted:
		return m.IsDeleted()
	case user.FieldLoginTime:
		return m.LoginTime()
	case user.FieldLanguage:
		return m.Language()
	case user.FieldIsTester:
		return m.IsTester()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldScenicAreaID:
		return m.OldScenicAreaID(ctx)
	case user.FieldOrigin:
		return m.OldOrigin(ctx)
	case user.FieldUserCls:
		return m.OldUserCls(ctx)
	case user.FieldOpenID:
		return m.OldOpenID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldCountry:
		return m.OldCountry(ctx)
	case user.FieldProvince:
		return m.OldProvince(ctx)
	case user.FieldCity:
		return m.OldCity(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case user.FieldLoginTime:
		return m.OldLoginTime(ctx)
	case user.FieldLanguage:
		return m.OldLanguage(ctx)
	case user.FieldIsTester:
		return m.OldIsTester(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldScenicAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScenicAreaID(v)
		return nil
	case user.FieldOrigin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	case user.FieldUserCls:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCls(v)
		return nil
	case user.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldGender:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case user.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case user.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldIsDeleted:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case user.FieldLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTime(v)
		return nil
	case user.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case user.FieldIsTester:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTester(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addorigin != nil {
		fields = append(fields, user.FieldOrigin)
	}
	if m.adduser_cls != nil {
		fields = append(fields, user.FieldUserCls)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addis_deleted != nil {
		fields = append(fields, user.FieldIsDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldOrigin:
		return m.AddedOrigin()
	case user.FieldUserCls:
		return m.AddedUserCls()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldIsDeleted:
		return m.AddedIsDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldOrigin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrigin(v)
		return nil
	case user.FieldUserCls:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCls(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldIsDeleted:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldScenicAreaID) {
		fields = append(fields, user.FieldScenicAreaID)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldLoginTime) {
		fields = append(fields, user.FieldLoginTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldScenicAreaID:
		m.ClearScenicAreaID()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldLoginTime:
		m.ClearLoginTime()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldScenicAreaID:
		m.ResetScenicAreaID()
		return nil
	case user.FieldOrigin:
		m.ResetOrigin()
		return nil
	case user.FieldUserCls:
		m.ResetUserCls()
		return nil
	case user.FieldOpenID:
		m.ResetOpenID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldCountry:
		m.ResetCountry()
		return nil
	case user.FieldProvince:
		m.ResetProvince()
		return nil
	case user.FieldCity:
		m.ResetCity()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case user.FieldLoginTime:
		m.ResetLoginTime()
		return nil
	case user.FieldLanguage:
		m.ResetLanguage()
		return nil
	case user.FieldIsTester:
		m.ResetIsTester()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.background_scenic_area != nil {
		edges = append(edges, user.EdgeBackgroundScenicArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBackgroundScenicArea:
		if id := m.background_scenic_area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbackground_scenic_area {
		edges = append(edges, user.EdgeBackgroundScenicArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBackgroundScenicArea:
		return m.clearedbackground_scenic_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBackgroundScenicArea:
		m.ClearBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBackgroundScenicArea:
		m.ResetBackgroundScenicArea()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
