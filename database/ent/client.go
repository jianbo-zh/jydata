// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/jianbo-zh/jydata/database/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/jianbo-zh/jydata/database/ent/access"
	"github.com/jianbo-zh/jydata/database/ent/account"
	"github.com/jianbo-zh/jydata/database/ent/activityorder"
	"github.com/jianbo-zh/jydata/database/ent/apppush"
	"github.com/jianbo-zh/jydata/database/ent/appversion"
	"github.com/jianbo-zh/jydata/database/ent/billingstrategy"
	"github.com/jianbo-zh/jydata/database/ent/car"
	"github.com/jianbo-zh/jydata/database/ent/caralarm"
	"github.com/jianbo-zh/jydata/database/ent/carconfig"
	"github.com/jianbo-zh/jydata/database/ent/carconfigdownload"
	"github.com/jianbo-zh/jydata/database/ent/carconfigpack"
	"github.com/jianbo-zh/jydata/database/ent/carconfigstatus"
	"github.com/jianbo-zh/jydata/database/ent/carcumulative"
	"github.com/jianbo-zh/jydata/database/ent/carextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/carlogupload"
	"github.com/jianbo-zh/jydata/database/ent/carsflight"
	"github.com/jianbo-zh/jydata/database/ent/carsflightextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/carsmodels"
	"github.com/jianbo-zh/jydata/database/ent/carsmodelsgroups"
	"github.com/jianbo-zh/jydata/database/ent/carsmodelsgroupsparams"
	"github.com/jianbo-zh/jydata/database/ent/carsoperatelog"
	"github.com/jianbo-zh/jydata/database/ent/coupon"
	"github.com/jianbo-zh/jydata/database/ent/feedback"
	"github.com/jianbo-zh/jydata/database/ent/file"
	"github.com/jianbo-zh/jydata/database/ent/mapversion"
	"github.com/jianbo-zh/jydata/database/ent/operationuser"
	"github.com/jianbo-zh/jydata/database/ent/order"
	"github.com/jianbo-zh/jydata/database/ent/orderappeal"
	"github.com/jianbo-zh/jydata/database/ent/orderbilling"
	"github.com/jianbo-zh/jydata/database/ent/orderextendflight"
	"github.com/jianbo-zh/jydata/database/ent/orderrefund"
	"github.com/jianbo-zh/jydata/database/ent/ordersharing"
	"github.com/jianbo-zh/jydata/database/ent/otabtree"
	"github.com/jianbo-zh/jydata/database/ent/otadeploy"
	"github.com/jianbo-zh/jydata/database/ent/otaversion"
	"github.com/jianbo-zh/jydata/database/ent/paymentaccount"
	"github.com/jianbo-zh/jydata/database/ent/paytxbill"
	"github.com/jianbo-zh/jydata/database/ent/poi"
	"github.com/jianbo-zh/jydata/database/ent/poiextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/profitreceiver"
	"github.com/jianbo-zh/jydata/database/ent/role"
	"github.com/jianbo-zh/jydata/database/ent/route"
	"github.com/jianbo-zh/jydata/database/ent/scenicarea"
	"github.com/jianbo-zh/jydata/database/ent/scenicareaextendyokee"
	"github.com/jianbo-zh/jydata/database/ent/scenicareamap"
	"github.com/jianbo-zh/jydata/database/ent/schetask"
	"github.com/jianbo-zh/jydata/database/ent/schetaskevent"
	"github.com/jianbo-zh/jydata/database/ent/sshaccount"
	"github.com/jianbo-zh/jydata/database/ent/statsdaily"
	"github.com/jianbo-zh/jydata/database/ent/statsdailycar"
	"github.com/jianbo-zh/jydata/database/ent/statsdailyscenicarea"
	"github.com/jianbo-zh/jydata/database/ent/statshourlycar"
	"github.com/jianbo-zh/jydata/database/ent/statshourlyscenicarea"
	"github.com/jianbo-zh/jydata/database/ent/systemconfig"
	"github.com/jianbo-zh/jydata/database/ent/systemlog"
	"github.com/jianbo-zh/jydata/database/ent/task"
	"github.com/jianbo-zh/jydata/database/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Access is the client for interacting with the Access builders.
	Access *AccessClient
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// ActivityOrder is the client for interacting with the ActivityOrder builders.
	ActivityOrder *ActivityOrderClient
	// AppPush is the client for interacting with the AppPush builders.
	AppPush *AppPushClient
	// AppVersion is the client for interacting with the AppVersion builders.
	AppVersion *AppVersionClient
	// BillingStrategy is the client for interacting with the BillingStrategy builders.
	BillingStrategy *BillingStrategyClient
	// Car is the client for interacting with the Car builders.
	Car *CarClient
	// CarAlarm is the client for interacting with the CarAlarm builders.
	CarAlarm *CarAlarmClient
	// CarConfig is the client for interacting with the CarConfig builders.
	CarConfig *CarConfigClient
	// CarConfigDownload is the client for interacting with the CarConfigDownload builders.
	CarConfigDownload *CarConfigDownloadClient
	// CarConfigPack is the client for interacting with the CarConfigPack builders.
	CarConfigPack *CarConfigPackClient
	// CarConfigStatus is the client for interacting with the CarConfigStatus builders.
	CarConfigStatus *CarConfigStatusClient
	// CarCumulative is the client for interacting with the CarCumulative builders.
	CarCumulative *CarCumulativeClient
	// CarExtendYokee is the client for interacting with the CarExtendYokee builders.
	CarExtendYokee *CarExtendYokeeClient
	// CarLogUpload is the client for interacting with the CarLogUpload builders.
	CarLogUpload *CarLogUploadClient
	// CarsFlight is the client for interacting with the CarsFlight builders.
	CarsFlight *CarsFlightClient
	// CarsFlightExtendYokee is the client for interacting with the CarsFlightExtendYokee builders.
	CarsFlightExtendYokee *CarsFlightExtendYokeeClient
	// CarsModels is the client for interacting with the CarsModels builders.
	CarsModels *CarsModelsClient
	// CarsModelsGroups is the client for interacting with the CarsModelsGroups builders.
	CarsModelsGroups *CarsModelsGroupsClient
	// CarsModelsGroupsParams is the client for interacting with the CarsModelsGroupsParams builders.
	CarsModelsGroupsParams *CarsModelsGroupsParamsClient
	// CarsOperateLog is the client for interacting with the CarsOperateLog builders.
	CarsOperateLog *CarsOperateLogClient
	// Coupon is the client for interacting with the Coupon builders.
	Coupon *CouponClient
	// Feedback is the client for interacting with the Feedback builders.
	Feedback *FeedbackClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// MapVersion is the client for interacting with the MapVersion builders.
	MapVersion *MapVersionClient
	// OperationUser is the client for interacting with the OperationUser builders.
	OperationUser *OperationUserClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderAppeal is the client for interacting with the OrderAppeal builders.
	OrderAppeal *OrderAppealClient
	// OrderBilling is the client for interacting with the OrderBilling builders.
	OrderBilling *OrderBillingClient
	// OrderExtendFlight is the client for interacting with the OrderExtendFlight builders.
	OrderExtendFlight *OrderExtendFlightClient
	// OrderRefund is the client for interacting with the OrderRefund builders.
	OrderRefund *OrderRefundClient
	// OrderSharing is the client for interacting with the OrderSharing builders.
	OrderSharing *OrderSharingClient
	// OtaBtree is the client for interacting with the OtaBtree builders.
	OtaBtree *OtaBtreeClient
	// OtaDeploy is the client for interacting with the OtaDeploy builders.
	OtaDeploy *OtaDeployClient
	// OtaVersion is the client for interacting with the OtaVersion builders.
	OtaVersion *OtaVersionClient
	// PayTxBill is the client for interacting with the PayTxBill builders.
	PayTxBill *PayTxBillClient
	// PaymentAccount is the client for interacting with the PaymentAccount builders.
	PaymentAccount *PaymentAccountClient
	// Poi is the client for interacting with the Poi builders.
	Poi *PoiClient
	// PoiExtendYokee is the client for interacting with the PoiExtendYokee builders.
	PoiExtendYokee *PoiExtendYokeeClient
	// ProfitReceiver is the client for interacting with the ProfitReceiver builders.
	ProfitReceiver *ProfitReceiverClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Route is the client for interacting with the Route builders.
	Route *RouteClient
	// ScenicArea is the client for interacting with the ScenicArea builders.
	ScenicArea *ScenicAreaClient
	// ScenicAreaExtendYokee is the client for interacting with the ScenicAreaExtendYokee builders.
	ScenicAreaExtendYokee *ScenicAreaExtendYokeeClient
	// ScenicAreaMap is the client for interacting with the ScenicAreaMap builders.
	ScenicAreaMap *ScenicAreaMapClient
	// ScheTask is the client for interacting with the ScheTask builders.
	ScheTask *ScheTaskClient
	// ScheTaskEvent is the client for interacting with the ScheTaskEvent builders.
	ScheTaskEvent *ScheTaskEventClient
	// SshAccount is the client for interacting with the SshAccount builders.
	SshAccount *SshAccountClient
	// StatsDaily is the client for interacting with the StatsDaily builders.
	StatsDaily *StatsDailyClient
	// StatsDailyCar is the client for interacting with the StatsDailyCar builders.
	StatsDailyCar *StatsDailyCarClient
	// StatsDailyScenicArea is the client for interacting with the StatsDailyScenicArea builders.
	StatsDailyScenicArea *StatsDailyScenicAreaClient
	// StatsHourlyCar is the client for interacting with the StatsHourlyCar builders.
	StatsHourlyCar *StatsHourlyCarClient
	// StatsHourlyScenicArea is the client for interacting with the StatsHourlyScenicArea builders.
	StatsHourlyScenicArea *StatsHourlyScenicAreaClient
	// SystemConfig is the client for interacting with the SystemConfig builders.
	SystemConfig *SystemConfigClient
	// SystemLog is the client for interacting with the SystemLog builders.
	SystemLog *SystemLogClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Access = NewAccessClient(c.config)
	c.Account = NewAccountClient(c.config)
	c.ActivityOrder = NewActivityOrderClient(c.config)
	c.AppPush = NewAppPushClient(c.config)
	c.AppVersion = NewAppVersionClient(c.config)
	c.BillingStrategy = NewBillingStrategyClient(c.config)
	c.Car = NewCarClient(c.config)
	c.CarAlarm = NewCarAlarmClient(c.config)
	c.CarConfig = NewCarConfigClient(c.config)
	c.CarConfigDownload = NewCarConfigDownloadClient(c.config)
	c.CarConfigPack = NewCarConfigPackClient(c.config)
	c.CarConfigStatus = NewCarConfigStatusClient(c.config)
	c.CarCumulative = NewCarCumulativeClient(c.config)
	c.CarExtendYokee = NewCarExtendYokeeClient(c.config)
	c.CarLogUpload = NewCarLogUploadClient(c.config)
	c.CarsFlight = NewCarsFlightClient(c.config)
	c.CarsFlightExtendYokee = NewCarsFlightExtendYokeeClient(c.config)
	c.CarsModels = NewCarsModelsClient(c.config)
	c.CarsModelsGroups = NewCarsModelsGroupsClient(c.config)
	c.CarsModelsGroupsParams = NewCarsModelsGroupsParamsClient(c.config)
	c.CarsOperateLog = NewCarsOperateLogClient(c.config)
	c.Coupon = NewCouponClient(c.config)
	c.Feedback = NewFeedbackClient(c.config)
	c.File = NewFileClient(c.config)
	c.MapVersion = NewMapVersionClient(c.config)
	c.OperationUser = NewOperationUserClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderAppeal = NewOrderAppealClient(c.config)
	c.OrderBilling = NewOrderBillingClient(c.config)
	c.OrderExtendFlight = NewOrderExtendFlightClient(c.config)
	c.OrderRefund = NewOrderRefundClient(c.config)
	c.OrderSharing = NewOrderSharingClient(c.config)
	c.OtaBtree = NewOtaBtreeClient(c.config)
	c.OtaDeploy = NewOtaDeployClient(c.config)
	c.OtaVersion = NewOtaVersionClient(c.config)
	c.PayTxBill = NewPayTxBillClient(c.config)
	c.PaymentAccount = NewPaymentAccountClient(c.config)
	c.Poi = NewPoiClient(c.config)
	c.PoiExtendYokee = NewPoiExtendYokeeClient(c.config)
	c.ProfitReceiver = NewProfitReceiverClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Route = NewRouteClient(c.config)
	c.ScenicArea = NewScenicAreaClient(c.config)
	c.ScenicAreaExtendYokee = NewScenicAreaExtendYokeeClient(c.config)
	c.ScenicAreaMap = NewScenicAreaMapClient(c.config)
	c.ScheTask = NewScheTaskClient(c.config)
	c.ScheTaskEvent = NewScheTaskEventClient(c.config)
	c.SshAccount = NewSshAccountClient(c.config)
	c.StatsDaily = NewStatsDailyClient(c.config)
	c.StatsDailyCar = NewStatsDailyCarClient(c.config)
	c.StatsDailyScenicArea = NewStatsDailyScenicAreaClient(c.config)
	c.StatsHourlyCar = NewStatsHourlyCarClient(c.config)
	c.StatsHourlyScenicArea = NewStatsHourlyScenicAreaClient(c.config)
	c.SystemConfig = NewSystemConfigClient(c.config)
	c.SystemLog = NewSystemLogClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Access:                 NewAccessClient(cfg),
		Account:                NewAccountClient(cfg),
		ActivityOrder:          NewActivityOrderClient(cfg),
		AppPush:                NewAppPushClient(cfg),
		AppVersion:             NewAppVersionClient(cfg),
		BillingStrategy:        NewBillingStrategyClient(cfg),
		Car:                    NewCarClient(cfg),
		CarAlarm:               NewCarAlarmClient(cfg),
		CarConfig:              NewCarConfigClient(cfg),
		CarConfigDownload:      NewCarConfigDownloadClient(cfg),
		CarConfigPack:          NewCarConfigPackClient(cfg),
		CarConfigStatus:        NewCarConfigStatusClient(cfg),
		CarCumulative:          NewCarCumulativeClient(cfg),
		CarExtendYokee:         NewCarExtendYokeeClient(cfg),
		CarLogUpload:           NewCarLogUploadClient(cfg),
		CarsFlight:             NewCarsFlightClient(cfg),
		CarsFlightExtendYokee:  NewCarsFlightExtendYokeeClient(cfg),
		CarsModels:             NewCarsModelsClient(cfg),
		CarsModelsGroups:       NewCarsModelsGroupsClient(cfg),
		CarsModelsGroupsParams: NewCarsModelsGroupsParamsClient(cfg),
		CarsOperateLog:         NewCarsOperateLogClient(cfg),
		Coupon:                 NewCouponClient(cfg),
		Feedback:               NewFeedbackClient(cfg),
		File:                   NewFileClient(cfg),
		MapVersion:             NewMapVersionClient(cfg),
		OperationUser:          NewOperationUserClient(cfg),
		Order:                  NewOrderClient(cfg),
		OrderAppeal:            NewOrderAppealClient(cfg),
		OrderBilling:           NewOrderBillingClient(cfg),
		OrderExtendFlight:      NewOrderExtendFlightClient(cfg),
		OrderRefund:            NewOrderRefundClient(cfg),
		OrderSharing:           NewOrderSharingClient(cfg),
		OtaBtree:               NewOtaBtreeClient(cfg),
		OtaDeploy:              NewOtaDeployClient(cfg),
		OtaVersion:             NewOtaVersionClient(cfg),
		PayTxBill:              NewPayTxBillClient(cfg),
		PaymentAccount:         NewPaymentAccountClient(cfg),
		Poi:                    NewPoiClient(cfg),
		PoiExtendYokee:         NewPoiExtendYokeeClient(cfg),
		ProfitReceiver:         NewProfitReceiverClient(cfg),
		Role:                   NewRoleClient(cfg),
		Route:                  NewRouteClient(cfg),
		ScenicArea:             NewScenicAreaClient(cfg),
		ScenicAreaExtendYokee:  NewScenicAreaExtendYokeeClient(cfg),
		ScenicAreaMap:          NewScenicAreaMapClient(cfg),
		ScheTask:               NewScheTaskClient(cfg),
		ScheTaskEvent:          NewScheTaskEventClient(cfg),
		SshAccount:             NewSshAccountClient(cfg),
		StatsDaily:             NewStatsDailyClient(cfg),
		StatsDailyCar:          NewStatsDailyCarClient(cfg),
		StatsDailyScenicArea:   NewStatsDailyScenicAreaClient(cfg),
		StatsHourlyCar:         NewStatsHourlyCarClient(cfg),
		StatsHourlyScenicArea:  NewStatsHourlyScenicAreaClient(cfg),
		SystemConfig:           NewSystemConfigClient(cfg),
		SystemLog:              NewSystemLogClient(cfg),
		Task:                   NewTaskClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		Access:                 NewAccessClient(cfg),
		Account:                NewAccountClient(cfg),
		ActivityOrder:          NewActivityOrderClient(cfg),
		AppPush:                NewAppPushClient(cfg),
		AppVersion:             NewAppVersionClient(cfg),
		BillingStrategy:        NewBillingStrategyClient(cfg),
		Car:                    NewCarClient(cfg),
		CarAlarm:               NewCarAlarmClient(cfg),
		CarConfig:              NewCarConfigClient(cfg),
		CarConfigDownload:      NewCarConfigDownloadClient(cfg),
		CarConfigPack:          NewCarConfigPackClient(cfg),
		CarConfigStatus:        NewCarConfigStatusClient(cfg),
		CarCumulative:          NewCarCumulativeClient(cfg),
		CarExtendYokee:         NewCarExtendYokeeClient(cfg),
		CarLogUpload:           NewCarLogUploadClient(cfg),
		CarsFlight:             NewCarsFlightClient(cfg),
		CarsFlightExtendYokee:  NewCarsFlightExtendYokeeClient(cfg),
		CarsModels:             NewCarsModelsClient(cfg),
		CarsModelsGroups:       NewCarsModelsGroupsClient(cfg),
		CarsModelsGroupsParams: NewCarsModelsGroupsParamsClient(cfg),
		CarsOperateLog:         NewCarsOperateLogClient(cfg),
		Coupon:                 NewCouponClient(cfg),
		Feedback:               NewFeedbackClient(cfg),
		File:                   NewFileClient(cfg),
		MapVersion:             NewMapVersionClient(cfg),
		OperationUser:          NewOperationUserClient(cfg),
		Order:                  NewOrderClient(cfg),
		OrderAppeal:            NewOrderAppealClient(cfg),
		OrderBilling:           NewOrderBillingClient(cfg),
		OrderExtendFlight:      NewOrderExtendFlightClient(cfg),
		OrderRefund:            NewOrderRefundClient(cfg),
		OrderSharing:           NewOrderSharingClient(cfg),
		OtaBtree:               NewOtaBtreeClient(cfg),
		OtaDeploy:              NewOtaDeployClient(cfg),
		OtaVersion:             NewOtaVersionClient(cfg),
		PayTxBill:              NewPayTxBillClient(cfg),
		PaymentAccount:         NewPaymentAccountClient(cfg),
		Poi:                    NewPoiClient(cfg),
		PoiExtendYokee:         NewPoiExtendYokeeClient(cfg),
		ProfitReceiver:         NewProfitReceiverClient(cfg),
		Role:                   NewRoleClient(cfg),
		Route:                  NewRouteClient(cfg),
		ScenicArea:             NewScenicAreaClient(cfg),
		ScenicAreaExtendYokee:  NewScenicAreaExtendYokeeClient(cfg),
		ScenicAreaMap:          NewScenicAreaMapClient(cfg),
		ScheTask:               NewScheTaskClient(cfg),
		ScheTaskEvent:          NewScheTaskEventClient(cfg),
		SshAccount:             NewSshAccountClient(cfg),
		StatsDaily:             NewStatsDailyClient(cfg),
		StatsDailyCar:          NewStatsDailyCarClient(cfg),
		StatsDailyScenicArea:   NewStatsDailyScenicAreaClient(cfg),
		StatsHourlyCar:         NewStatsHourlyCarClient(cfg),
		StatsHourlyScenicArea:  NewStatsHourlyScenicAreaClient(cfg),
		SystemConfig:           NewSystemConfigClient(cfg),
		SystemLog:              NewSystemLogClient(cfg),
		Task:                   NewTaskClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Access.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Access, c.Account, c.ActivityOrder, c.AppPush, c.AppVersion,
		c.BillingStrategy, c.Car, c.CarAlarm, c.CarConfig, c.CarConfigDownload,
		c.CarConfigPack, c.CarConfigStatus, c.CarCumulative, c.CarExtendYokee,
		c.CarLogUpload, c.CarsFlight, c.CarsFlightExtendYokee, c.CarsModels,
		c.CarsModelsGroups, c.CarsModelsGroupsParams, c.CarsOperateLog, c.Coupon,
		c.Feedback, c.File, c.MapVersion, c.OperationUser, c.Order, c.OrderAppeal,
		c.OrderBilling, c.OrderExtendFlight, c.OrderRefund, c.OrderSharing, c.OtaBtree,
		c.OtaDeploy, c.OtaVersion, c.PayTxBill, c.PaymentAccount, c.Poi,
		c.PoiExtendYokee, c.ProfitReceiver, c.Role, c.Route, c.ScenicArea,
		c.ScenicAreaExtendYokee, c.ScenicAreaMap, c.ScheTask, c.ScheTaskEvent,
		c.SshAccount, c.StatsDaily, c.StatsDailyCar, c.StatsDailyScenicArea,
		c.StatsHourlyCar, c.StatsHourlyScenicArea, c.SystemConfig, c.SystemLog, c.Task,
		c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Access, c.Account, c.ActivityOrder, c.AppPush, c.AppVersion,
		c.BillingStrategy, c.Car, c.CarAlarm, c.CarConfig, c.CarConfigDownload,
		c.CarConfigPack, c.CarConfigStatus, c.CarCumulative, c.CarExtendYokee,
		c.CarLogUpload, c.CarsFlight, c.CarsFlightExtendYokee, c.CarsModels,
		c.CarsModelsGroups, c.CarsModelsGroupsParams, c.CarsOperateLog, c.Coupon,
		c.Feedback, c.File, c.MapVersion, c.OperationUser, c.Order, c.OrderAppeal,
		c.OrderBilling, c.OrderExtendFlight, c.OrderRefund, c.OrderSharing, c.OtaBtree,
		c.OtaDeploy, c.OtaVersion, c.PayTxBill, c.PaymentAccount, c.Poi,
		c.PoiExtendYokee, c.ProfitReceiver, c.Role, c.Route, c.ScenicArea,
		c.ScenicAreaExtendYokee, c.ScenicAreaMap, c.ScheTask, c.ScheTaskEvent,
		c.SshAccount, c.StatsDaily, c.StatsDailyCar, c.StatsDailyScenicArea,
		c.StatsHourlyCar, c.StatsHourlyScenicArea, c.SystemConfig, c.SystemLog, c.Task,
		c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccessMutation:
		return c.Access.mutate(ctx, m)
	case *AccountMutation:
		return c.Account.mutate(ctx, m)
	case *ActivityOrderMutation:
		return c.ActivityOrder.mutate(ctx, m)
	case *AppPushMutation:
		return c.AppPush.mutate(ctx, m)
	case *AppVersionMutation:
		return c.AppVersion.mutate(ctx, m)
	case *BillingStrategyMutation:
		return c.BillingStrategy.mutate(ctx, m)
	case *CarMutation:
		return c.Car.mutate(ctx, m)
	case *CarAlarmMutation:
		return c.CarAlarm.mutate(ctx, m)
	case *CarConfigMutation:
		return c.CarConfig.mutate(ctx, m)
	case *CarConfigDownloadMutation:
		return c.CarConfigDownload.mutate(ctx, m)
	case *CarConfigPackMutation:
		return c.CarConfigPack.mutate(ctx, m)
	case *CarConfigStatusMutation:
		return c.CarConfigStatus.mutate(ctx, m)
	case *CarCumulativeMutation:
		return c.CarCumulative.mutate(ctx, m)
	case *CarExtendYokeeMutation:
		return c.CarExtendYokee.mutate(ctx, m)
	case *CarLogUploadMutation:
		return c.CarLogUpload.mutate(ctx, m)
	case *CarsFlightMutation:
		return c.CarsFlight.mutate(ctx, m)
	case *CarsFlightExtendYokeeMutation:
		return c.CarsFlightExtendYokee.mutate(ctx, m)
	case *CarsModelsMutation:
		return c.CarsModels.mutate(ctx, m)
	case *CarsModelsGroupsMutation:
		return c.CarsModelsGroups.mutate(ctx, m)
	case *CarsModelsGroupsParamsMutation:
		return c.CarsModelsGroupsParams.mutate(ctx, m)
	case *CarsOperateLogMutation:
		return c.CarsOperateLog.mutate(ctx, m)
	case *CouponMutation:
		return c.Coupon.mutate(ctx, m)
	case *FeedbackMutation:
		return c.Feedback.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *MapVersionMutation:
		return c.MapVersion.mutate(ctx, m)
	case *OperationUserMutation:
		return c.OperationUser.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderAppealMutation:
		return c.OrderAppeal.mutate(ctx, m)
	case *OrderBillingMutation:
		return c.OrderBilling.mutate(ctx, m)
	case *OrderExtendFlightMutation:
		return c.OrderExtendFlight.mutate(ctx, m)
	case *OrderRefundMutation:
		return c.OrderRefund.mutate(ctx, m)
	case *OrderSharingMutation:
		return c.OrderSharing.mutate(ctx, m)
	case *OtaBtreeMutation:
		return c.OtaBtree.mutate(ctx, m)
	case *OtaDeployMutation:
		return c.OtaDeploy.mutate(ctx, m)
	case *OtaVersionMutation:
		return c.OtaVersion.mutate(ctx, m)
	case *PayTxBillMutation:
		return c.PayTxBill.mutate(ctx, m)
	case *PaymentAccountMutation:
		return c.PaymentAccount.mutate(ctx, m)
	case *PoiMutation:
		return c.Poi.mutate(ctx, m)
	case *PoiExtendYokeeMutation:
		return c.PoiExtendYokee.mutate(ctx, m)
	case *ProfitReceiverMutation:
		return c.ProfitReceiver.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *RouteMutation:
		return c.Route.mutate(ctx, m)
	case *ScenicAreaMutation:
		return c.ScenicArea.mutate(ctx, m)
	case *ScenicAreaExtendYokeeMutation:
		return c.ScenicAreaExtendYokee.mutate(ctx, m)
	case *ScenicAreaMapMutation:
		return c.ScenicAreaMap.mutate(ctx, m)
	case *ScheTaskMutation:
		return c.ScheTask.mutate(ctx, m)
	case *ScheTaskEventMutation:
		return c.ScheTaskEvent.mutate(ctx, m)
	case *SshAccountMutation:
		return c.SshAccount.mutate(ctx, m)
	case *StatsDailyMutation:
		return c.StatsDaily.mutate(ctx, m)
	case *StatsDailyCarMutation:
		return c.StatsDailyCar.mutate(ctx, m)
	case *StatsDailyScenicAreaMutation:
		return c.StatsDailyScenicArea.mutate(ctx, m)
	case *StatsHourlyCarMutation:
		return c.StatsHourlyCar.mutate(ctx, m)
	case *StatsHourlyScenicAreaMutation:
		return c.StatsHourlyScenicArea.mutate(ctx, m)
	case *SystemConfigMutation:
		return c.SystemConfig.mutate(ctx, m)
	case *SystemLogMutation:
		return c.SystemLog.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccessClient is a client for the Access schema.
type AccessClient struct {
	config
}

// NewAccessClient returns a client for the Access from the given config.
func NewAccessClient(c config) *AccessClient {
	return &AccessClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `access.Hooks(f(g(h())))`.
func (c *AccessClient) Use(hooks ...Hook) {
	c.hooks.Access = append(c.hooks.Access, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `access.Intercept(f(g(h())))`.
func (c *AccessClient) Intercept(interceptors ...Interceptor) {
	c.inters.Access = append(c.inters.Access, interceptors...)
}

// Create returns a builder for creating a Access entity.
func (c *AccessClient) Create() *AccessCreate {
	mutation := newAccessMutation(c.config, OpCreate)
	return &AccessCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Access entities.
func (c *AccessClient) CreateBulk(builders ...*AccessCreate) *AccessCreateBulk {
	return &AccessCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccessClient) MapCreateBulk(slice any, setFunc func(*AccessCreate, int)) *AccessCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccessCreateBulk{err: fmt.Errorf("calling to AccessClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccessCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccessCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Access.
func (c *AccessClient) Update() *AccessUpdate {
	mutation := newAccessMutation(c.config, OpUpdate)
	return &AccessUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccessClient) UpdateOne(a *Access) *AccessUpdateOne {
	mutation := newAccessMutation(c.config, OpUpdateOne, withAccess(a))
	return &AccessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccessClient) UpdateOneID(id int) *AccessUpdateOne {
	mutation := newAccessMutation(c.config, OpUpdateOne, withAccessID(id))
	return &AccessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Access.
func (c *AccessClient) Delete() *AccessDelete {
	mutation := newAccessMutation(c.config, OpDelete)
	return &AccessDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccessClient) DeleteOne(a *Access) *AccessDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccessClient) DeleteOneID(id int) *AccessDeleteOne {
	builder := c.Delete().Where(access.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccessDeleteOne{builder}
}

// Query returns a query builder for Access.
func (c *AccessClient) Query() *AccessQuery {
	return &AccessQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccess},
		inters: c.Interceptors(),
	}
}

// Get returns a Access entity by its id.
func (c *AccessClient) Get(ctx context.Context, id int) (*Access, error) {
	return c.Query().Where(access.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccessClient) GetX(ctx context.Context, id int) *Access {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AccessClient) Hooks() []Hook {
	return c.hooks.Access
}

// Interceptors returns the client interceptors.
func (c *AccessClient) Interceptors() []Interceptor {
	return c.inters.Access
}

func (c *AccessClient) mutate(ctx context.Context, m *AccessMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccessCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccessUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccessUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccessDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Access mutation op: %q", m.Op())
	}
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `account.Intercept(f(g(h())))`.
func (c *AccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.Account = append(c.inters.Account, interceptors...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountClient) MapCreateBulk(slice any, setFunc func(*AccountCreate, int)) *AccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountCreateBulk{err: fmt.Errorf("calling to AccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(a))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id int) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id int) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id int) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id int) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a Account.
func (c *AccountClient) QueryBackgroundScenicArea(a *Account) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.BackgroundScenicAreaTable, account.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// Interceptors returns the client interceptors.
func (c *AccountClient) Interceptors() []Interceptor {
	return c.inters.Account
}

func (c *AccountClient) mutate(ctx context.Context, m *AccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Account mutation op: %q", m.Op())
	}
}

// ActivityOrderClient is a client for the ActivityOrder schema.
type ActivityOrderClient struct {
	config
}

// NewActivityOrderClient returns a client for the ActivityOrder from the given config.
func NewActivityOrderClient(c config) *ActivityOrderClient {
	return &ActivityOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activityorder.Hooks(f(g(h())))`.
func (c *ActivityOrderClient) Use(hooks ...Hook) {
	c.hooks.ActivityOrder = append(c.hooks.ActivityOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activityorder.Intercept(f(g(h())))`.
func (c *ActivityOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityOrder = append(c.inters.ActivityOrder, interceptors...)
}

// Create returns a builder for creating a ActivityOrder entity.
func (c *ActivityOrderClient) Create() *ActivityOrderCreate {
	mutation := newActivityOrderMutation(c.config, OpCreate)
	return &ActivityOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityOrder entities.
func (c *ActivityOrderClient) CreateBulk(builders ...*ActivityOrderCreate) *ActivityOrderCreateBulk {
	return &ActivityOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityOrderClient) MapCreateBulk(slice any, setFunc func(*ActivityOrderCreate, int)) *ActivityOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityOrderCreateBulk{err: fmt.Errorf("calling to ActivityOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityOrder.
func (c *ActivityOrderClient) Update() *ActivityOrderUpdate {
	mutation := newActivityOrderMutation(c.config, OpUpdate)
	return &ActivityOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityOrderClient) UpdateOne(ao *ActivityOrder) *ActivityOrderUpdateOne {
	mutation := newActivityOrderMutation(c.config, OpUpdateOne, withActivityOrder(ao))
	return &ActivityOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityOrderClient) UpdateOneID(id int) *ActivityOrderUpdateOne {
	mutation := newActivityOrderMutation(c.config, OpUpdateOne, withActivityOrderID(id))
	return &ActivityOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityOrder.
func (c *ActivityOrderClient) Delete() *ActivityOrderDelete {
	mutation := newActivityOrderMutation(c.config, OpDelete)
	return &ActivityOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityOrderClient) DeleteOne(ao *ActivityOrder) *ActivityOrderDeleteOne {
	return c.DeleteOneID(ao.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityOrderClient) DeleteOneID(id int) *ActivityOrderDeleteOne {
	builder := c.Delete().Where(activityorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityOrderDeleteOne{builder}
}

// Query returns a query builder for ActivityOrder.
func (c *ActivityOrderClient) Query() *ActivityOrderQuery {
	return &ActivityOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityOrder entity by its id.
func (c *ActivityOrderClient) Get(ctx context.Context, id int) (*ActivityOrder, error) {
	return c.Query().Where(activityorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityOrderClient) GetX(ctx context.Context, id int) *ActivityOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ActivityOrderClient) Hooks() []Hook {
	return c.hooks.ActivityOrder
}

// Interceptors returns the client interceptors.
func (c *ActivityOrderClient) Interceptors() []Interceptor {
	return c.inters.ActivityOrder
}

func (c *ActivityOrderClient) mutate(ctx context.Context, m *ActivityOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityOrder mutation op: %q", m.Op())
	}
}

// AppPushClient is a client for the AppPush schema.
type AppPushClient struct {
	config
}

// NewAppPushClient returns a client for the AppPush from the given config.
func NewAppPushClient(c config) *AppPushClient {
	return &AppPushClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apppush.Hooks(f(g(h())))`.
func (c *AppPushClient) Use(hooks ...Hook) {
	c.hooks.AppPush = append(c.hooks.AppPush, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apppush.Intercept(f(g(h())))`.
func (c *AppPushClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppPush = append(c.inters.AppPush, interceptors...)
}

// Create returns a builder for creating a AppPush entity.
func (c *AppPushClient) Create() *AppPushCreate {
	mutation := newAppPushMutation(c.config, OpCreate)
	return &AppPushCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppPush entities.
func (c *AppPushClient) CreateBulk(builders ...*AppPushCreate) *AppPushCreateBulk {
	return &AppPushCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppPushClient) MapCreateBulk(slice any, setFunc func(*AppPushCreate, int)) *AppPushCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppPushCreateBulk{err: fmt.Errorf("calling to AppPushClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppPushCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppPushCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppPush.
func (c *AppPushClient) Update() *AppPushUpdate {
	mutation := newAppPushMutation(c.config, OpUpdate)
	return &AppPushUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppPushClient) UpdateOne(ap *AppPush) *AppPushUpdateOne {
	mutation := newAppPushMutation(c.config, OpUpdateOne, withAppPush(ap))
	return &AppPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppPushClient) UpdateOneID(id int) *AppPushUpdateOne {
	mutation := newAppPushMutation(c.config, OpUpdateOne, withAppPushID(id))
	return &AppPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppPush.
func (c *AppPushClient) Delete() *AppPushDelete {
	mutation := newAppPushMutation(c.config, OpDelete)
	return &AppPushDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppPushClient) DeleteOne(ap *AppPush) *AppPushDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppPushClient) DeleteOneID(id int) *AppPushDeleteOne {
	builder := c.Delete().Where(apppush.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppPushDeleteOne{builder}
}

// Query returns a query builder for AppPush.
func (c *AppPushClient) Query() *AppPushQuery {
	return &AppPushQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppPush},
		inters: c.Interceptors(),
	}
}

// Get returns a AppPush entity by its id.
func (c *AppPushClient) Get(ctx context.Context, id int) (*AppPush, error) {
	return c.Query().Where(apppush.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppPushClient) GetX(ctx context.Context, id int) *AppPush {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppPushClient) Hooks() []Hook {
	return c.hooks.AppPush
}

// Interceptors returns the client interceptors.
func (c *AppPushClient) Interceptors() []Interceptor {
	return c.inters.AppPush
}

func (c *AppPushClient) mutate(ctx context.Context, m *AppPushMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppPushCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppPushUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppPushUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppPushDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppPush mutation op: %q", m.Op())
	}
}

// AppVersionClient is a client for the AppVersion schema.
type AppVersionClient struct {
	config
}

// NewAppVersionClient returns a client for the AppVersion from the given config.
func NewAppVersionClient(c config) *AppVersionClient {
	return &AppVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appversion.Hooks(f(g(h())))`.
func (c *AppVersionClient) Use(hooks ...Hook) {
	c.hooks.AppVersion = append(c.hooks.AppVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appversion.Intercept(f(g(h())))`.
func (c *AppVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppVersion = append(c.inters.AppVersion, interceptors...)
}

// Create returns a builder for creating a AppVersion entity.
func (c *AppVersionClient) Create() *AppVersionCreate {
	mutation := newAppVersionMutation(c.config, OpCreate)
	return &AppVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppVersion entities.
func (c *AppVersionClient) CreateBulk(builders ...*AppVersionCreate) *AppVersionCreateBulk {
	return &AppVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppVersionClient) MapCreateBulk(slice any, setFunc func(*AppVersionCreate, int)) *AppVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppVersionCreateBulk{err: fmt.Errorf("calling to AppVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppVersion.
func (c *AppVersionClient) Update() *AppVersionUpdate {
	mutation := newAppVersionMutation(c.config, OpUpdate)
	return &AppVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppVersionClient) UpdateOne(av *AppVersion) *AppVersionUpdateOne {
	mutation := newAppVersionMutation(c.config, OpUpdateOne, withAppVersion(av))
	return &AppVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppVersionClient) UpdateOneID(id int) *AppVersionUpdateOne {
	mutation := newAppVersionMutation(c.config, OpUpdateOne, withAppVersionID(id))
	return &AppVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppVersion.
func (c *AppVersionClient) Delete() *AppVersionDelete {
	mutation := newAppVersionMutation(c.config, OpDelete)
	return &AppVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppVersionClient) DeleteOne(av *AppVersion) *AppVersionDeleteOne {
	return c.DeleteOneID(av.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppVersionClient) DeleteOneID(id int) *AppVersionDeleteOne {
	builder := c.Delete().Where(appversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppVersionDeleteOne{builder}
}

// Query returns a query builder for AppVersion.
func (c *AppVersionClient) Query() *AppVersionQuery {
	return &AppVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a AppVersion entity by its id.
func (c *AppVersionClient) Get(ctx context.Context, id int) (*AppVersion, error) {
	return c.Query().Where(appversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppVersionClient) GetX(ctx context.Context, id int) *AppVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppVersionClient) Hooks() []Hook {
	return c.hooks.AppVersion
}

// Interceptors returns the client interceptors.
func (c *AppVersionClient) Interceptors() []Interceptor {
	return c.inters.AppVersion
}

func (c *AppVersionClient) mutate(ctx context.Context, m *AppVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppVersion mutation op: %q", m.Op())
	}
}

// BillingStrategyClient is a client for the BillingStrategy schema.
type BillingStrategyClient struct {
	config
}

// NewBillingStrategyClient returns a client for the BillingStrategy from the given config.
func NewBillingStrategyClient(c config) *BillingStrategyClient {
	return &BillingStrategyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `billingstrategy.Hooks(f(g(h())))`.
func (c *BillingStrategyClient) Use(hooks ...Hook) {
	c.hooks.BillingStrategy = append(c.hooks.BillingStrategy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `billingstrategy.Intercept(f(g(h())))`.
func (c *BillingStrategyClient) Intercept(interceptors ...Interceptor) {
	c.inters.BillingStrategy = append(c.inters.BillingStrategy, interceptors...)
}

// Create returns a builder for creating a BillingStrategy entity.
func (c *BillingStrategyClient) Create() *BillingStrategyCreate {
	mutation := newBillingStrategyMutation(c.config, OpCreate)
	return &BillingStrategyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BillingStrategy entities.
func (c *BillingStrategyClient) CreateBulk(builders ...*BillingStrategyCreate) *BillingStrategyCreateBulk {
	return &BillingStrategyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BillingStrategyClient) MapCreateBulk(slice any, setFunc func(*BillingStrategyCreate, int)) *BillingStrategyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BillingStrategyCreateBulk{err: fmt.Errorf("calling to BillingStrategyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BillingStrategyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BillingStrategyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BillingStrategy.
func (c *BillingStrategyClient) Update() *BillingStrategyUpdate {
	mutation := newBillingStrategyMutation(c.config, OpUpdate)
	return &BillingStrategyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BillingStrategyClient) UpdateOne(bs *BillingStrategy) *BillingStrategyUpdateOne {
	mutation := newBillingStrategyMutation(c.config, OpUpdateOne, withBillingStrategy(bs))
	return &BillingStrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BillingStrategyClient) UpdateOneID(id int) *BillingStrategyUpdateOne {
	mutation := newBillingStrategyMutation(c.config, OpUpdateOne, withBillingStrategyID(id))
	return &BillingStrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BillingStrategy.
func (c *BillingStrategyClient) Delete() *BillingStrategyDelete {
	mutation := newBillingStrategyMutation(c.config, OpDelete)
	return &BillingStrategyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BillingStrategyClient) DeleteOne(bs *BillingStrategy) *BillingStrategyDeleteOne {
	return c.DeleteOneID(bs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BillingStrategyClient) DeleteOneID(id int) *BillingStrategyDeleteOne {
	builder := c.Delete().Where(billingstrategy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BillingStrategyDeleteOne{builder}
}

// Query returns a query builder for BillingStrategy.
func (c *BillingStrategyClient) Query() *BillingStrategyQuery {
	return &BillingStrategyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBillingStrategy},
		inters: c.Interceptors(),
	}
}

// Get returns a BillingStrategy entity by its id.
func (c *BillingStrategyClient) Get(ctx context.Context, id int) (*BillingStrategy, error) {
	return c.Query().Where(billingstrategy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BillingStrategyClient) GetX(ctx context.Context, id int) *BillingStrategy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a BillingStrategy.
func (c *BillingStrategyClient) QueryBackgroundScenicArea(bs *BillingStrategy) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(billingstrategy.Table, billingstrategy.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, billingstrategy.BackgroundScenicAreaTable, billingstrategy.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(bs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BillingStrategyClient) Hooks() []Hook {
	return c.hooks.BillingStrategy
}

// Interceptors returns the client interceptors.
func (c *BillingStrategyClient) Interceptors() []Interceptor {
	return c.inters.BillingStrategy
}

func (c *BillingStrategyClient) mutate(ctx context.Context, m *BillingStrategyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BillingStrategyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BillingStrategyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BillingStrategyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BillingStrategyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BillingStrategy mutation op: %q", m.Op())
	}
}

// CarClient is a client for the Car schema.
type CarClient struct {
	config
}

// NewCarClient returns a client for the Car from the given config.
func NewCarClient(c config) *CarClient {
	return &CarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `car.Hooks(f(g(h())))`.
func (c *CarClient) Use(hooks ...Hook) {
	c.hooks.Car = append(c.hooks.Car, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `car.Intercept(f(g(h())))`.
func (c *CarClient) Intercept(interceptors ...Interceptor) {
	c.inters.Car = append(c.inters.Car, interceptors...)
}

// Create returns a builder for creating a Car entity.
func (c *CarClient) Create() *CarCreate {
	mutation := newCarMutation(c.config, OpCreate)
	return &CarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Car entities.
func (c *CarClient) CreateBulk(builders ...*CarCreate) *CarCreateBulk {
	return &CarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarClient) MapCreateBulk(slice any, setFunc func(*CarCreate, int)) *CarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarCreateBulk{err: fmt.Errorf("calling to CarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Car.
func (c *CarClient) Update() *CarUpdate {
	mutation := newCarMutation(c.config, OpUpdate)
	return &CarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarClient) UpdateOne(ca *Car) *CarUpdateOne {
	mutation := newCarMutation(c.config, OpUpdateOne, withCar(ca))
	return &CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarClient) UpdateOneID(id int) *CarUpdateOne {
	mutation := newCarMutation(c.config, OpUpdateOne, withCarID(id))
	return &CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Car.
func (c *CarClient) Delete() *CarDelete {
	mutation := newCarMutation(c.config, OpDelete)
	return &CarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarClient) DeleteOne(ca *Car) *CarDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarClient) DeleteOneID(id int) *CarDeleteOne {
	builder := c.Delete().Where(car.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarDeleteOne{builder}
}

// Query returns a query builder for Car.
func (c *CarClient) Query() *CarQuery {
	return &CarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCar},
		inters: c.Interceptors(),
	}
}

// Get returns a Car entity by its id.
func (c *CarClient) Get(ctx context.Context, id int) (*Car, error) {
	return c.Query().Where(car.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarClient) GetX(ctx context.Context, id int) *Car {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a Car.
func (c *CarClient) QueryBackgroundScenicArea(ca *Car) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, car.BackgroundScenicAreaTable, car.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarsModels queries the cars_models edge of a Car.
func (c *CarClient) QueryCarsModels(ca *Car) *CarsModelsQuery {
	query := (&CarsModelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(carsmodels.Table, carsmodels.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, car.CarsModelsTable, car.CarsModelsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarOperateLogs queries the car_operate_logs edge of a Car.
func (c *CarClient) QueryCarOperateLogs(ca *Car) *CarsOperateLogQuery {
	query := (&CarsOperateLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(carsoperatelog.Table, carsoperatelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.CarOperateLogsTable, car.CarOperateLogsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a Car.
func (c *CarClient) QueryOrders(ca *Car) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.OrdersTable, car.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatsHourlyCar queries the stats_hourly_car edge of a Car.
func (c *CarClient) QueryStatsHourlyCar(ca *Car) *StatsHourlyCarQuery {
	query := (&StatsHourlyCarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(statshourlycar.Table, statshourlycar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.StatsHourlyCarTable, car.StatsHourlyCarColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheTask queries the sche_task edge of a Car.
func (c *CarClient) QueryScheTask(ca *Car) *ScheTaskQuery {
	query := (&ScheTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(schetask.Table, schetask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ScheTaskTable, car.ScheTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfigFiles queries the config_files edge of a Car.
func (c *CarClient) QueryConfigFiles(ca *Car) *CarConfigQuery {
	query := (&CarConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(carconfig.Table, carconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ConfigFilesTable, car.ConfigFilesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarConfigs queries the car_configs edge of a Car.
func (c *CarClient) QueryCarConfigs(ca *Car) *CarConfigDownloadQuery {
	query := (&CarConfigDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(carconfigdownload.Table, carconfigdownload.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.CarConfigsTable, car.CarConfigsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarClient) Hooks() []Hook {
	hooks := c.hooks.Car
	return append(hooks[:len(hooks):len(hooks)], car.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CarClient) Interceptors() []Interceptor {
	inters := c.inters.Car
	return append(inters[:len(inters):len(inters)], car.Interceptors[:]...)
}

func (c *CarClient) mutate(ctx context.Context, m *CarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Car mutation op: %q", m.Op())
	}
}

// CarAlarmClient is a client for the CarAlarm schema.
type CarAlarmClient struct {
	config
}

// NewCarAlarmClient returns a client for the CarAlarm from the given config.
func NewCarAlarmClient(c config) *CarAlarmClient {
	return &CarAlarmClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `caralarm.Hooks(f(g(h())))`.
func (c *CarAlarmClient) Use(hooks ...Hook) {
	c.hooks.CarAlarm = append(c.hooks.CarAlarm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `caralarm.Intercept(f(g(h())))`.
func (c *CarAlarmClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarAlarm = append(c.inters.CarAlarm, interceptors...)
}

// Create returns a builder for creating a CarAlarm entity.
func (c *CarAlarmClient) Create() *CarAlarmCreate {
	mutation := newCarAlarmMutation(c.config, OpCreate)
	return &CarAlarmCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarAlarm entities.
func (c *CarAlarmClient) CreateBulk(builders ...*CarAlarmCreate) *CarAlarmCreateBulk {
	return &CarAlarmCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarAlarmClient) MapCreateBulk(slice any, setFunc func(*CarAlarmCreate, int)) *CarAlarmCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarAlarmCreateBulk{err: fmt.Errorf("calling to CarAlarmClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarAlarmCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarAlarmCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarAlarm.
func (c *CarAlarmClient) Update() *CarAlarmUpdate {
	mutation := newCarAlarmMutation(c.config, OpUpdate)
	return &CarAlarmUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarAlarmClient) UpdateOne(ca *CarAlarm) *CarAlarmUpdateOne {
	mutation := newCarAlarmMutation(c.config, OpUpdateOne, withCarAlarm(ca))
	return &CarAlarmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarAlarmClient) UpdateOneID(id int) *CarAlarmUpdateOne {
	mutation := newCarAlarmMutation(c.config, OpUpdateOne, withCarAlarmID(id))
	return &CarAlarmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarAlarm.
func (c *CarAlarmClient) Delete() *CarAlarmDelete {
	mutation := newCarAlarmMutation(c.config, OpDelete)
	return &CarAlarmDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarAlarmClient) DeleteOne(ca *CarAlarm) *CarAlarmDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarAlarmClient) DeleteOneID(id int) *CarAlarmDeleteOne {
	builder := c.Delete().Where(caralarm.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarAlarmDeleteOne{builder}
}

// Query returns a query builder for CarAlarm.
func (c *CarAlarmClient) Query() *CarAlarmQuery {
	return &CarAlarmQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarAlarm},
		inters: c.Interceptors(),
	}
}

// Get returns a CarAlarm entity by its id.
func (c *CarAlarmClient) Get(ctx context.Context, id int) (*CarAlarm, error) {
	return c.Query().Where(caralarm.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarAlarmClient) GetX(ctx context.Context, id int) *CarAlarm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarAlarmClient) Hooks() []Hook {
	return c.hooks.CarAlarm
}

// Interceptors returns the client interceptors.
func (c *CarAlarmClient) Interceptors() []Interceptor {
	return c.inters.CarAlarm
}

func (c *CarAlarmClient) mutate(ctx context.Context, m *CarAlarmMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarAlarmCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarAlarmUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarAlarmUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarAlarmDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarAlarm mutation op: %q", m.Op())
	}
}

// CarConfigClient is a client for the CarConfig schema.
type CarConfigClient struct {
	config
}

// NewCarConfigClient returns a client for the CarConfig from the given config.
func NewCarConfigClient(c config) *CarConfigClient {
	return &CarConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carconfig.Hooks(f(g(h())))`.
func (c *CarConfigClient) Use(hooks ...Hook) {
	c.hooks.CarConfig = append(c.hooks.CarConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carconfig.Intercept(f(g(h())))`.
func (c *CarConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarConfig = append(c.inters.CarConfig, interceptors...)
}

// Create returns a builder for creating a CarConfig entity.
func (c *CarConfigClient) Create() *CarConfigCreate {
	mutation := newCarConfigMutation(c.config, OpCreate)
	return &CarConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarConfig entities.
func (c *CarConfigClient) CreateBulk(builders ...*CarConfigCreate) *CarConfigCreateBulk {
	return &CarConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarConfigClient) MapCreateBulk(slice any, setFunc func(*CarConfigCreate, int)) *CarConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarConfigCreateBulk{err: fmt.Errorf("calling to CarConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarConfig.
func (c *CarConfigClient) Update() *CarConfigUpdate {
	mutation := newCarConfigMutation(c.config, OpUpdate)
	return &CarConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarConfigClient) UpdateOne(cc *CarConfig) *CarConfigUpdateOne {
	mutation := newCarConfigMutation(c.config, OpUpdateOne, withCarConfig(cc))
	return &CarConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarConfigClient) UpdateOneID(id int) *CarConfigUpdateOne {
	mutation := newCarConfigMutation(c.config, OpUpdateOne, withCarConfigID(id))
	return &CarConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarConfig.
func (c *CarConfigClient) Delete() *CarConfigDelete {
	mutation := newCarConfigMutation(c.config, OpDelete)
	return &CarConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarConfigClient) DeleteOne(cc *CarConfig) *CarConfigDeleteOne {
	return c.DeleteOneID(cc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarConfigClient) DeleteOneID(id int) *CarConfigDeleteOne {
	builder := c.Delete().Where(carconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarConfigDeleteOne{builder}
}

// Query returns a query builder for CarConfig.
func (c *CarConfigClient) Query() *CarConfigQuery {
	return &CarConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a CarConfig entity by its id.
func (c *CarConfigClient) Get(ctx context.Context, id int) (*CarConfig, error) {
	return c.Query().Where(carconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarConfigClient) GetX(ctx context.Context, id int) *CarConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a CarConfig.
func (c *CarConfigClient) QueryBackgroundScenicArea(cc *CarConfig) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carconfig.Table, carconfig.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carconfig.BackgroundScenicAreaTable, carconfig.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(cc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarsModels queries the cars_models edge of a CarConfig.
func (c *CarConfigClient) QueryCarsModels(cc *CarConfig) *CarsModelsQuery {
	query := (&CarsModelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carconfig.Table, carconfig.FieldID, id),
			sqlgraph.To(carsmodels.Table, carsmodels.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carconfig.CarsModelsTable, carconfig.CarsModelsColumn),
		)
		fromV = sqlgraph.Neighbors(cc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCar queries the car edge of a CarConfig.
func (c *CarConfigClient) QueryCar(cc *CarConfig) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carconfig.Table, carconfig.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carconfig.CarTable, carconfig.CarColumn),
		)
		fromV = sqlgraph.Neighbors(cc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarConfigClient) Hooks() []Hook {
	return c.hooks.CarConfig
}

// Interceptors returns the client interceptors.
func (c *CarConfigClient) Interceptors() []Interceptor {
	return c.inters.CarConfig
}

func (c *CarConfigClient) mutate(ctx context.Context, m *CarConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarConfig mutation op: %q", m.Op())
	}
}

// CarConfigDownloadClient is a client for the CarConfigDownload schema.
type CarConfigDownloadClient struct {
	config
}

// NewCarConfigDownloadClient returns a client for the CarConfigDownload from the given config.
func NewCarConfigDownloadClient(c config) *CarConfigDownloadClient {
	return &CarConfigDownloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carconfigdownload.Hooks(f(g(h())))`.
func (c *CarConfigDownloadClient) Use(hooks ...Hook) {
	c.hooks.CarConfigDownload = append(c.hooks.CarConfigDownload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carconfigdownload.Intercept(f(g(h())))`.
func (c *CarConfigDownloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarConfigDownload = append(c.inters.CarConfigDownload, interceptors...)
}

// Create returns a builder for creating a CarConfigDownload entity.
func (c *CarConfigDownloadClient) Create() *CarConfigDownloadCreate {
	mutation := newCarConfigDownloadMutation(c.config, OpCreate)
	return &CarConfigDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarConfigDownload entities.
func (c *CarConfigDownloadClient) CreateBulk(builders ...*CarConfigDownloadCreate) *CarConfigDownloadCreateBulk {
	return &CarConfigDownloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarConfigDownloadClient) MapCreateBulk(slice any, setFunc func(*CarConfigDownloadCreate, int)) *CarConfigDownloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarConfigDownloadCreateBulk{err: fmt.Errorf("calling to CarConfigDownloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarConfigDownloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarConfigDownloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarConfigDownload.
func (c *CarConfigDownloadClient) Update() *CarConfigDownloadUpdate {
	mutation := newCarConfigDownloadMutation(c.config, OpUpdate)
	return &CarConfigDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarConfigDownloadClient) UpdateOne(ccd *CarConfigDownload) *CarConfigDownloadUpdateOne {
	mutation := newCarConfigDownloadMutation(c.config, OpUpdateOne, withCarConfigDownload(ccd))
	return &CarConfigDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarConfigDownloadClient) UpdateOneID(id int) *CarConfigDownloadUpdateOne {
	mutation := newCarConfigDownloadMutation(c.config, OpUpdateOne, withCarConfigDownloadID(id))
	return &CarConfigDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarConfigDownload.
func (c *CarConfigDownloadClient) Delete() *CarConfigDownloadDelete {
	mutation := newCarConfigDownloadMutation(c.config, OpDelete)
	return &CarConfigDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarConfigDownloadClient) DeleteOne(ccd *CarConfigDownload) *CarConfigDownloadDeleteOne {
	return c.DeleteOneID(ccd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarConfigDownloadClient) DeleteOneID(id int) *CarConfigDownloadDeleteOne {
	builder := c.Delete().Where(carconfigdownload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarConfigDownloadDeleteOne{builder}
}

// Query returns a query builder for CarConfigDownload.
func (c *CarConfigDownloadClient) Query() *CarConfigDownloadQuery {
	return &CarConfigDownloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarConfigDownload},
		inters: c.Interceptors(),
	}
}

// Get returns a CarConfigDownload entity by its id.
func (c *CarConfigDownloadClient) Get(ctx context.Context, id int) (*CarConfigDownload, error) {
	return c.Query().Where(carconfigdownload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarConfigDownloadClient) GetX(ctx context.Context, id int) *CarConfigDownload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarConfigDownloadClient) Hooks() []Hook {
	return c.hooks.CarConfigDownload
}

// Interceptors returns the client interceptors.
func (c *CarConfigDownloadClient) Interceptors() []Interceptor {
	return c.inters.CarConfigDownload
}

func (c *CarConfigDownloadClient) mutate(ctx context.Context, m *CarConfigDownloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarConfigDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarConfigDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarConfigDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarConfigDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarConfigDownload mutation op: %q", m.Op())
	}
}

// CarConfigPackClient is a client for the CarConfigPack schema.
type CarConfigPackClient struct {
	config
}

// NewCarConfigPackClient returns a client for the CarConfigPack from the given config.
func NewCarConfigPackClient(c config) *CarConfigPackClient {
	return &CarConfigPackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carconfigpack.Hooks(f(g(h())))`.
func (c *CarConfigPackClient) Use(hooks ...Hook) {
	c.hooks.CarConfigPack = append(c.hooks.CarConfigPack, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carconfigpack.Intercept(f(g(h())))`.
func (c *CarConfigPackClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarConfigPack = append(c.inters.CarConfigPack, interceptors...)
}

// Create returns a builder for creating a CarConfigPack entity.
func (c *CarConfigPackClient) Create() *CarConfigPackCreate {
	mutation := newCarConfigPackMutation(c.config, OpCreate)
	return &CarConfigPackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarConfigPack entities.
func (c *CarConfigPackClient) CreateBulk(builders ...*CarConfigPackCreate) *CarConfigPackCreateBulk {
	return &CarConfigPackCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarConfigPackClient) MapCreateBulk(slice any, setFunc func(*CarConfigPackCreate, int)) *CarConfigPackCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarConfigPackCreateBulk{err: fmt.Errorf("calling to CarConfigPackClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarConfigPackCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarConfigPackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarConfigPack.
func (c *CarConfigPackClient) Update() *CarConfigPackUpdate {
	mutation := newCarConfigPackMutation(c.config, OpUpdate)
	return &CarConfigPackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarConfigPackClient) UpdateOne(ccp *CarConfigPack) *CarConfigPackUpdateOne {
	mutation := newCarConfigPackMutation(c.config, OpUpdateOne, withCarConfigPack(ccp))
	return &CarConfigPackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarConfigPackClient) UpdateOneID(id int) *CarConfigPackUpdateOne {
	mutation := newCarConfigPackMutation(c.config, OpUpdateOne, withCarConfigPackID(id))
	return &CarConfigPackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarConfigPack.
func (c *CarConfigPackClient) Delete() *CarConfigPackDelete {
	mutation := newCarConfigPackMutation(c.config, OpDelete)
	return &CarConfigPackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarConfigPackClient) DeleteOne(ccp *CarConfigPack) *CarConfigPackDeleteOne {
	return c.DeleteOneID(ccp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarConfigPackClient) DeleteOneID(id int) *CarConfigPackDeleteOne {
	builder := c.Delete().Where(carconfigpack.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarConfigPackDeleteOne{builder}
}

// Query returns a query builder for CarConfigPack.
func (c *CarConfigPackClient) Query() *CarConfigPackQuery {
	return &CarConfigPackQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarConfigPack},
		inters: c.Interceptors(),
	}
}

// Get returns a CarConfigPack entity by its id.
func (c *CarConfigPackClient) Get(ctx context.Context, id int) (*CarConfigPack, error) {
	return c.Query().Where(carconfigpack.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarConfigPackClient) GetX(ctx context.Context, id int) *CarConfigPack {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarConfigPackClient) Hooks() []Hook {
	return c.hooks.CarConfigPack
}

// Interceptors returns the client interceptors.
func (c *CarConfigPackClient) Interceptors() []Interceptor {
	return c.inters.CarConfigPack
}

func (c *CarConfigPackClient) mutate(ctx context.Context, m *CarConfigPackMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarConfigPackCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarConfigPackUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarConfigPackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarConfigPackDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarConfigPack mutation op: %q", m.Op())
	}
}

// CarConfigStatusClient is a client for the CarConfigStatus schema.
type CarConfigStatusClient struct {
	config
}

// NewCarConfigStatusClient returns a client for the CarConfigStatus from the given config.
func NewCarConfigStatusClient(c config) *CarConfigStatusClient {
	return &CarConfigStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carconfigstatus.Hooks(f(g(h())))`.
func (c *CarConfigStatusClient) Use(hooks ...Hook) {
	c.hooks.CarConfigStatus = append(c.hooks.CarConfigStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carconfigstatus.Intercept(f(g(h())))`.
func (c *CarConfigStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarConfigStatus = append(c.inters.CarConfigStatus, interceptors...)
}

// Create returns a builder for creating a CarConfigStatus entity.
func (c *CarConfigStatusClient) Create() *CarConfigStatusCreate {
	mutation := newCarConfigStatusMutation(c.config, OpCreate)
	return &CarConfigStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarConfigStatus entities.
func (c *CarConfigStatusClient) CreateBulk(builders ...*CarConfigStatusCreate) *CarConfigStatusCreateBulk {
	return &CarConfigStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarConfigStatusClient) MapCreateBulk(slice any, setFunc func(*CarConfigStatusCreate, int)) *CarConfigStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarConfigStatusCreateBulk{err: fmt.Errorf("calling to CarConfigStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarConfigStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarConfigStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarConfigStatus.
func (c *CarConfigStatusClient) Update() *CarConfigStatusUpdate {
	mutation := newCarConfigStatusMutation(c.config, OpUpdate)
	return &CarConfigStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarConfigStatusClient) UpdateOne(ccs *CarConfigStatus) *CarConfigStatusUpdateOne {
	mutation := newCarConfigStatusMutation(c.config, OpUpdateOne, withCarConfigStatus(ccs))
	return &CarConfigStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarConfigStatusClient) UpdateOneID(id int) *CarConfigStatusUpdateOne {
	mutation := newCarConfigStatusMutation(c.config, OpUpdateOne, withCarConfigStatusID(id))
	return &CarConfigStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarConfigStatus.
func (c *CarConfigStatusClient) Delete() *CarConfigStatusDelete {
	mutation := newCarConfigStatusMutation(c.config, OpDelete)
	return &CarConfigStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarConfigStatusClient) DeleteOne(ccs *CarConfigStatus) *CarConfigStatusDeleteOne {
	return c.DeleteOneID(ccs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarConfigStatusClient) DeleteOneID(id int) *CarConfigStatusDeleteOne {
	builder := c.Delete().Where(carconfigstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarConfigStatusDeleteOne{builder}
}

// Query returns a query builder for CarConfigStatus.
func (c *CarConfigStatusClient) Query() *CarConfigStatusQuery {
	return &CarConfigStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarConfigStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a CarConfigStatus entity by its id.
func (c *CarConfigStatusClient) Get(ctx context.Context, id int) (*CarConfigStatus, error) {
	return c.Query().Where(carconfigstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarConfigStatusClient) GetX(ctx context.Context, id int) *CarConfigStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarConfigStatusClient) Hooks() []Hook {
	return c.hooks.CarConfigStatus
}

// Interceptors returns the client interceptors.
func (c *CarConfigStatusClient) Interceptors() []Interceptor {
	return c.inters.CarConfigStatus
}

func (c *CarConfigStatusClient) mutate(ctx context.Context, m *CarConfigStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarConfigStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarConfigStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarConfigStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarConfigStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarConfigStatus mutation op: %q", m.Op())
	}
}

// CarCumulativeClient is a client for the CarCumulative schema.
type CarCumulativeClient struct {
	config
}

// NewCarCumulativeClient returns a client for the CarCumulative from the given config.
func NewCarCumulativeClient(c config) *CarCumulativeClient {
	return &CarCumulativeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carcumulative.Hooks(f(g(h())))`.
func (c *CarCumulativeClient) Use(hooks ...Hook) {
	c.hooks.CarCumulative = append(c.hooks.CarCumulative, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carcumulative.Intercept(f(g(h())))`.
func (c *CarCumulativeClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarCumulative = append(c.inters.CarCumulative, interceptors...)
}

// Create returns a builder for creating a CarCumulative entity.
func (c *CarCumulativeClient) Create() *CarCumulativeCreate {
	mutation := newCarCumulativeMutation(c.config, OpCreate)
	return &CarCumulativeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarCumulative entities.
func (c *CarCumulativeClient) CreateBulk(builders ...*CarCumulativeCreate) *CarCumulativeCreateBulk {
	return &CarCumulativeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarCumulativeClient) MapCreateBulk(slice any, setFunc func(*CarCumulativeCreate, int)) *CarCumulativeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarCumulativeCreateBulk{err: fmt.Errorf("calling to CarCumulativeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarCumulativeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarCumulativeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarCumulative.
func (c *CarCumulativeClient) Update() *CarCumulativeUpdate {
	mutation := newCarCumulativeMutation(c.config, OpUpdate)
	return &CarCumulativeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarCumulativeClient) UpdateOne(cc *CarCumulative) *CarCumulativeUpdateOne {
	mutation := newCarCumulativeMutation(c.config, OpUpdateOne, withCarCumulative(cc))
	return &CarCumulativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarCumulativeClient) UpdateOneID(id int) *CarCumulativeUpdateOne {
	mutation := newCarCumulativeMutation(c.config, OpUpdateOne, withCarCumulativeID(id))
	return &CarCumulativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarCumulative.
func (c *CarCumulativeClient) Delete() *CarCumulativeDelete {
	mutation := newCarCumulativeMutation(c.config, OpDelete)
	return &CarCumulativeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarCumulativeClient) DeleteOne(cc *CarCumulative) *CarCumulativeDeleteOne {
	return c.DeleteOneID(cc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarCumulativeClient) DeleteOneID(id int) *CarCumulativeDeleteOne {
	builder := c.Delete().Where(carcumulative.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarCumulativeDeleteOne{builder}
}

// Query returns a query builder for CarCumulative.
func (c *CarCumulativeClient) Query() *CarCumulativeQuery {
	return &CarCumulativeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarCumulative},
		inters: c.Interceptors(),
	}
}

// Get returns a CarCumulative entity by its id.
func (c *CarCumulativeClient) Get(ctx context.Context, id int) (*CarCumulative, error) {
	return c.Query().Where(carcumulative.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarCumulativeClient) GetX(ctx context.Context, id int) *CarCumulative {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarCumulativeClient) Hooks() []Hook {
	return c.hooks.CarCumulative
}

// Interceptors returns the client interceptors.
func (c *CarCumulativeClient) Interceptors() []Interceptor {
	return c.inters.CarCumulative
}

func (c *CarCumulativeClient) mutate(ctx context.Context, m *CarCumulativeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarCumulativeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarCumulativeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarCumulativeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarCumulativeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarCumulative mutation op: %q", m.Op())
	}
}

// CarExtendYokeeClient is a client for the CarExtendYokee schema.
type CarExtendYokeeClient struct {
	config
}

// NewCarExtendYokeeClient returns a client for the CarExtendYokee from the given config.
func NewCarExtendYokeeClient(c config) *CarExtendYokeeClient {
	return &CarExtendYokeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carextendyokee.Hooks(f(g(h())))`.
func (c *CarExtendYokeeClient) Use(hooks ...Hook) {
	c.hooks.CarExtendYokee = append(c.hooks.CarExtendYokee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carextendyokee.Intercept(f(g(h())))`.
func (c *CarExtendYokeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarExtendYokee = append(c.inters.CarExtendYokee, interceptors...)
}

// Create returns a builder for creating a CarExtendYokee entity.
func (c *CarExtendYokeeClient) Create() *CarExtendYokeeCreate {
	mutation := newCarExtendYokeeMutation(c.config, OpCreate)
	return &CarExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarExtendYokee entities.
func (c *CarExtendYokeeClient) CreateBulk(builders ...*CarExtendYokeeCreate) *CarExtendYokeeCreateBulk {
	return &CarExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarExtendYokeeClient) MapCreateBulk(slice any, setFunc func(*CarExtendYokeeCreate, int)) *CarExtendYokeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarExtendYokeeCreateBulk{err: fmt.Errorf("calling to CarExtendYokeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarExtendYokeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarExtendYokee.
func (c *CarExtendYokeeClient) Update() *CarExtendYokeeUpdate {
	mutation := newCarExtendYokeeMutation(c.config, OpUpdate)
	return &CarExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarExtendYokeeClient) UpdateOne(cey *CarExtendYokee) *CarExtendYokeeUpdateOne {
	mutation := newCarExtendYokeeMutation(c.config, OpUpdateOne, withCarExtendYokee(cey))
	return &CarExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarExtendYokeeClient) UpdateOneID(id int) *CarExtendYokeeUpdateOne {
	mutation := newCarExtendYokeeMutation(c.config, OpUpdateOne, withCarExtendYokeeID(id))
	return &CarExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarExtendYokee.
func (c *CarExtendYokeeClient) Delete() *CarExtendYokeeDelete {
	mutation := newCarExtendYokeeMutation(c.config, OpDelete)
	return &CarExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarExtendYokeeClient) DeleteOne(cey *CarExtendYokee) *CarExtendYokeeDeleteOne {
	return c.DeleteOneID(cey.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarExtendYokeeClient) DeleteOneID(id int) *CarExtendYokeeDeleteOne {
	builder := c.Delete().Where(carextendyokee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarExtendYokeeDeleteOne{builder}
}

// Query returns a query builder for CarExtendYokee.
func (c *CarExtendYokeeClient) Query() *CarExtendYokeeQuery {
	return &CarExtendYokeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarExtendYokee},
		inters: c.Interceptors(),
	}
}

// Get returns a CarExtendYokee entity by its id.
func (c *CarExtendYokeeClient) Get(ctx context.Context, id int) (*CarExtendYokee, error) {
	return c.Query().Where(carextendyokee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarExtendYokeeClient) GetX(ctx context.Context, id int) *CarExtendYokee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarExtendYokeeClient) Hooks() []Hook {
	hooks := c.hooks.CarExtendYokee
	return append(hooks[:len(hooks):len(hooks)], carextendyokee.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CarExtendYokeeClient) Interceptors() []Interceptor {
	inters := c.inters.CarExtendYokee
	return append(inters[:len(inters):len(inters)], carextendyokee.Interceptors[:]...)
}

func (c *CarExtendYokeeClient) mutate(ctx context.Context, m *CarExtendYokeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarExtendYokee mutation op: %q", m.Op())
	}
}

// CarLogUploadClient is a client for the CarLogUpload schema.
type CarLogUploadClient struct {
	config
}

// NewCarLogUploadClient returns a client for the CarLogUpload from the given config.
func NewCarLogUploadClient(c config) *CarLogUploadClient {
	return &CarLogUploadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carlogupload.Hooks(f(g(h())))`.
func (c *CarLogUploadClient) Use(hooks ...Hook) {
	c.hooks.CarLogUpload = append(c.hooks.CarLogUpload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carlogupload.Intercept(f(g(h())))`.
func (c *CarLogUploadClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarLogUpload = append(c.inters.CarLogUpload, interceptors...)
}

// Create returns a builder for creating a CarLogUpload entity.
func (c *CarLogUploadClient) Create() *CarLogUploadCreate {
	mutation := newCarLogUploadMutation(c.config, OpCreate)
	return &CarLogUploadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarLogUpload entities.
func (c *CarLogUploadClient) CreateBulk(builders ...*CarLogUploadCreate) *CarLogUploadCreateBulk {
	return &CarLogUploadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarLogUploadClient) MapCreateBulk(slice any, setFunc func(*CarLogUploadCreate, int)) *CarLogUploadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarLogUploadCreateBulk{err: fmt.Errorf("calling to CarLogUploadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarLogUploadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarLogUploadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarLogUpload.
func (c *CarLogUploadClient) Update() *CarLogUploadUpdate {
	mutation := newCarLogUploadMutation(c.config, OpUpdate)
	return &CarLogUploadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarLogUploadClient) UpdateOne(clu *CarLogUpload) *CarLogUploadUpdateOne {
	mutation := newCarLogUploadMutation(c.config, OpUpdateOne, withCarLogUpload(clu))
	return &CarLogUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarLogUploadClient) UpdateOneID(id int) *CarLogUploadUpdateOne {
	mutation := newCarLogUploadMutation(c.config, OpUpdateOne, withCarLogUploadID(id))
	return &CarLogUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarLogUpload.
func (c *CarLogUploadClient) Delete() *CarLogUploadDelete {
	mutation := newCarLogUploadMutation(c.config, OpDelete)
	return &CarLogUploadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarLogUploadClient) DeleteOne(clu *CarLogUpload) *CarLogUploadDeleteOne {
	return c.DeleteOneID(clu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarLogUploadClient) DeleteOneID(id int) *CarLogUploadDeleteOne {
	builder := c.Delete().Where(carlogupload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarLogUploadDeleteOne{builder}
}

// Query returns a query builder for CarLogUpload.
func (c *CarLogUploadClient) Query() *CarLogUploadQuery {
	return &CarLogUploadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarLogUpload},
		inters: c.Interceptors(),
	}
}

// Get returns a CarLogUpload entity by its id.
func (c *CarLogUploadClient) Get(ctx context.Context, id int) (*CarLogUpload, error) {
	return c.Query().Where(carlogupload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarLogUploadClient) GetX(ctx context.Context, id int) *CarLogUpload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarLogUploadClient) Hooks() []Hook {
	return c.hooks.CarLogUpload
}

// Interceptors returns the client interceptors.
func (c *CarLogUploadClient) Interceptors() []Interceptor {
	return c.inters.CarLogUpload
}

func (c *CarLogUploadClient) mutate(ctx context.Context, m *CarLogUploadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarLogUploadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarLogUploadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarLogUploadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarLogUploadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarLogUpload mutation op: %q", m.Op())
	}
}

// CarsFlightClient is a client for the CarsFlight schema.
type CarsFlightClient struct {
	config
}

// NewCarsFlightClient returns a client for the CarsFlight from the given config.
func NewCarsFlightClient(c config) *CarsFlightClient {
	return &CarsFlightClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsflight.Hooks(f(g(h())))`.
func (c *CarsFlightClient) Use(hooks ...Hook) {
	c.hooks.CarsFlight = append(c.hooks.CarsFlight, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsflight.Intercept(f(g(h())))`.
func (c *CarsFlightClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsFlight = append(c.inters.CarsFlight, interceptors...)
}

// Create returns a builder for creating a CarsFlight entity.
func (c *CarsFlightClient) Create() *CarsFlightCreate {
	mutation := newCarsFlightMutation(c.config, OpCreate)
	return &CarsFlightCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsFlight entities.
func (c *CarsFlightClient) CreateBulk(builders ...*CarsFlightCreate) *CarsFlightCreateBulk {
	return &CarsFlightCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsFlightClient) MapCreateBulk(slice any, setFunc func(*CarsFlightCreate, int)) *CarsFlightCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsFlightCreateBulk{err: fmt.Errorf("calling to CarsFlightClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsFlightCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsFlightCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsFlight.
func (c *CarsFlightClient) Update() *CarsFlightUpdate {
	mutation := newCarsFlightMutation(c.config, OpUpdate)
	return &CarsFlightUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsFlightClient) UpdateOne(cf *CarsFlight) *CarsFlightUpdateOne {
	mutation := newCarsFlightMutation(c.config, OpUpdateOne, withCarsFlight(cf))
	return &CarsFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsFlightClient) UpdateOneID(id int) *CarsFlightUpdateOne {
	mutation := newCarsFlightMutation(c.config, OpUpdateOne, withCarsFlightID(id))
	return &CarsFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsFlight.
func (c *CarsFlightClient) Delete() *CarsFlightDelete {
	mutation := newCarsFlightMutation(c.config, OpDelete)
	return &CarsFlightDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsFlightClient) DeleteOne(cf *CarsFlight) *CarsFlightDeleteOne {
	return c.DeleteOneID(cf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsFlightClient) DeleteOneID(id int) *CarsFlightDeleteOne {
	builder := c.Delete().Where(carsflight.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsFlightDeleteOne{builder}
}

// Query returns a query builder for CarsFlight.
func (c *CarsFlightClient) Query() *CarsFlightQuery {
	return &CarsFlightQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsFlight},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsFlight entity by its id.
func (c *CarsFlightClient) Get(ctx context.Context, id int) (*CarsFlight, error) {
	return c.Query().Where(carsflight.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsFlightClient) GetX(ctx context.Context, id int) *CarsFlight {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarsFlightClient) Hooks() []Hook {
	return c.hooks.CarsFlight
}

// Interceptors returns the client interceptors.
func (c *CarsFlightClient) Interceptors() []Interceptor {
	return c.inters.CarsFlight
}

func (c *CarsFlightClient) mutate(ctx context.Context, m *CarsFlightMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsFlightCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsFlightUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsFlightDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsFlight mutation op: %q", m.Op())
	}
}

// CarsFlightExtendYokeeClient is a client for the CarsFlightExtendYokee schema.
type CarsFlightExtendYokeeClient struct {
	config
}

// NewCarsFlightExtendYokeeClient returns a client for the CarsFlightExtendYokee from the given config.
func NewCarsFlightExtendYokeeClient(c config) *CarsFlightExtendYokeeClient {
	return &CarsFlightExtendYokeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsflightextendyokee.Hooks(f(g(h())))`.
func (c *CarsFlightExtendYokeeClient) Use(hooks ...Hook) {
	c.hooks.CarsFlightExtendYokee = append(c.hooks.CarsFlightExtendYokee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsflightextendyokee.Intercept(f(g(h())))`.
func (c *CarsFlightExtendYokeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsFlightExtendYokee = append(c.inters.CarsFlightExtendYokee, interceptors...)
}

// Create returns a builder for creating a CarsFlightExtendYokee entity.
func (c *CarsFlightExtendYokeeClient) Create() *CarsFlightExtendYokeeCreate {
	mutation := newCarsFlightExtendYokeeMutation(c.config, OpCreate)
	return &CarsFlightExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsFlightExtendYokee entities.
func (c *CarsFlightExtendYokeeClient) CreateBulk(builders ...*CarsFlightExtendYokeeCreate) *CarsFlightExtendYokeeCreateBulk {
	return &CarsFlightExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsFlightExtendYokeeClient) MapCreateBulk(slice any, setFunc func(*CarsFlightExtendYokeeCreate, int)) *CarsFlightExtendYokeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsFlightExtendYokeeCreateBulk{err: fmt.Errorf("calling to CarsFlightExtendYokeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsFlightExtendYokeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsFlightExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsFlightExtendYokee.
func (c *CarsFlightExtendYokeeClient) Update() *CarsFlightExtendYokeeUpdate {
	mutation := newCarsFlightExtendYokeeMutation(c.config, OpUpdate)
	return &CarsFlightExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsFlightExtendYokeeClient) UpdateOne(cfey *CarsFlightExtendYokee) *CarsFlightExtendYokeeUpdateOne {
	mutation := newCarsFlightExtendYokeeMutation(c.config, OpUpdateOne, withCarsFlightExtendYokee(cfey))
	return &CarsFlightExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsFlightExtendYokeeClient) UpdateOneID(id int) *CarsFlightExtendYokeeUpdateOne {
	mutation := newCarsFlightExtendYokeeMutation(c.config, OpUpdateOne, withCarsFlightExtendYokeeID(id))
	return &CarsFlightExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsFlightExtendYokee.
func (c *CarsFlightExtendYokeeClient) Delete() *CarsFlightExtendYokeeDelete {
	mutation := newCarsFlightExtendYokeeMutation(c.config, OpDelete)
	return &CarsFlightExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsFlightExtendYokeeClient) DeleteOne(cfey *CarsFlightExtendYokee) *CarsFlightExtendYokeeDeleteOne {
	return c.DeleteOneID(cfey.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsFlightExtendYokeeClient) DeleteOneID(id int) *CarsFlightExtendYokeeDeleteOne {
	builder := c.Delete().Where(carsflightextendyokee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsFlightExtendYokeeDeleteOne{builder}
}

// Query returns a query builder for CarsFlightExtendYokee.
func (c *CarsFlightExtendYokeeClient) Query() *CarsFlightExtendYokeeQuery {
	return &CarsFlightExtendYokeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsFlightExtendYokee},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsFlightExtendYokee entity by its id.
func (c *CarsFlightExtendYokeeClient) Get(ctx context.Context, id int) (*CarsFlightExtendYokee, error) {
	return c.Query().Where(carsflightextendyokee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsFlightExtendYokeeClient) GetX(ctx context.Context, id int) *CarsFlightExtendYokee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CarsFlightExtendYokeeClient) Hooks() []Hook {
	return c.hooks.CarsFlightExtendYokee
}

// Interceptors returns the client interceptors.
func (c *CarsFlightExtendYokeeClient) Interceptors() []Interceptor {
	return c.inters.CarsFlightExtendYokee
}

func (c *CarsFlightExtendYokeeClient) mutate(ctx context.Context, m *CarsFlightExtendYokeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsFlightExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsFlightExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsFlightExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsFlightExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsFlightExtendYokee mutation op: %q", m.Op())
	}
}

// CarsModelsClient is a client for the CarsModels schema.
type CarsModelsClient struct {
	config
}

// NewCarsModelsClient returns a client for the CarsModels from the given config.
func NewCarsModelsClient(c config) *CarsModelsClient {
	return &CarsModelsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsmodels.Hooks(f(g(h())))`.
func (c *CarsModelsClient) Use(hooks ...Hook) {
	c.hooks.CarsModels = append(c.hooks.CarsModels, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsmodels.Intercept(f(g(h())))`.
func (c *CarsModelsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsModels = append(c.inters.CarsModels, interceptors...)
}

// Create returns a builder for creating a CarsModels entity.
func (c *CarsModelsClient) Create() *CarsModelsCreate {
	mutation := newCarsModelsMutation(c.config, OpCreate)
	return &CarsModelsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsModels entities.
func (c *CarsModelsClient) CreateBulk(builders ...*CarsModelsCreate) *CarsModelsCreateBulk {
	return &CarsModelsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsModelsClient) MapCreateBulk(slice any, setFunc func(*CarsModelsCreate, int)) *CarsModelsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsModelsCreateBulk{err: fmt.Errorf("calling to CarsModelsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsModelsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsModelsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsModels.
func (c *CarsModelsClient) Update() *CarsModelsUpdate {
	mutation := newCarsModelsMutation(c.config, OpUpdate)
	return &CarsModelsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsModelsClient) UpdateOne(cm *CarsModels) *CarsModelsUpdateOne {
	mutation := newCarsModelsMutation(c.config, OpUpdateOne, withCarsModels(cm))
	return &CarsModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsModelsClient) UpdateOneID(id int) *CarsModelsUpdateOne {
	mutation := newCarsModelsMutation(c.config, OpUpdateOne, withCarsModelsID(id))
	return &CarsModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsModels.
func (c *CarsModelsClient) Delete() *CarsModelsDelete {
	mutation := newCarsModelsMutation(c.config, OpDelete)
	return &CarsModelsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsModelsClient) DeleteOne(cm *CarsModels) *CarsModelsDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsModelsClient) DeleteOneID(id int) *CarsModelsDeleteOne {
	builder := c.Delete().Where(carsmodels.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsModelsDeleteOne{builder}
}

// Query returns a query builder for CarsModels.
func (c *CarsModelsClient) Query() *CarsModelsQuery {
	return &CarsModelsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsModels},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsModels entity by its id.
func (c *CarsModelsClient) Get(ctx context.Context, id int) (*CarsModels, error) {
	return c.Query().Where(carsmodels.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsModelsClient) GetX(ctx context.Context, id int) *CarsModels {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCars queries the cars edge of a CarsModels.
func (c *CarsModelsClient) QueryCars(cm *CarsModels) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodels.Table, carsmodels.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, carsmodels.CarsTable, carsmodels.CarsColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a CarsModels.
func (c *CarsModelsClient) QueryGroups(cm *CarsModels) *CarsModelsGroupsQuery {
	query := (&CarsModelsGroupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodels.Table, carsmodels.FieldID, id),
			sqlgraph.To(carsmodelsgroups.Table, carsmodelsgroups.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, carsmodels.GroupsTable, carsmodels.GroupsColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParams queries the params edge of a CarsModels.
func (c *CarsModelsClient) QueryParams(cm *CarsModels) *CarsModelsGroupsParamsQuery {
	query := (&CarsModelsGroupsParamsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodels.Table, carsmodels.FieldID, id),
			sqlgraph.To(carsmodelsgroupsparams.Table, carsmodelsgroupsparams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, carsmodels.ParamsTable, carsmodels.ParamsColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfigFiles queries the config_files edge of a CarsModels.
func (c *CarsModelsClient) QueryConfigFiles(cm *CarsModels) *CarConfigQuery {
	query := (&CarConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodels.Table, carsmodels.FieldID, id),
			sqlgraph.To(carconfig.Table, carconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, carsmodels.ConfigFilesTable, carsmodels.ConfigFilesColumn),
		)
		fromV = sqlgraph.Neighbors(cm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarsModelsClient) Hooks() []Hook {
	return c.hooks.CarsModels
}

// Interceptors returns the client interceptors.
func (c *CarsModelsClient) Interceptors() []Interceptor {
	return c.inters.CarsModels
}

func (c *CarsModelsClient) mutate(ctx context.Context, m *CarsModelsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsModelsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsModelsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsModelsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsModelsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsModels mutation op: %q", m.Op())
	}
}

// CarsModelsGroupsClient is a client for the CarsModelsGroups schema.
type CarsModelsGroupsClient struct {
	config
}

// NewCarsModelsGroupsClient returns a client for the CarsModelsGroups from the given config.
func NewCarsModelsGroupsClient(c config) *CarsModelsGroupsClient {
	return &CarsModelsGroupsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsmodelsgroups.Hooks(f(g(h())))`.
func (c *CarsModelsGroupsClient) Use(hooks ...Hook) {
	c.hooks.CarsModelsGroups = append(c.hooks.CarsModelsGroups, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsmodelsgroups.Intercept(f(g(h())))`.
func (c *CarsModelsGroupsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsModelsGroups = append(c.inters.CarsModelsGroups, interceptors...)
}

// Create returns a builder for creating a CarsModelsGroups entity.
func (c *CarsModelsGroupsClient) Create() *CarsModelsGroupsCreate {
	mutation := newCarsModelsGroupsMutation(c.config, OpCreate)
	return &CarsModelsGroupsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsModelsGroups entities.
func (c *CarsModelsGroupsClient) CreateBulk(builders ...*CarsModelsGroupsCreate) *CarsModelsGroupsCreateBulk {
	return &CarsModelsGroupsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsModelsGroupsClient) MapCreateBulk(slice any, setFunc func(*CarsModelsGroupsCreate, int)) *CarsModelsGroupsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsModelsGroupsCreateBulk{err: fmt.Errorf("calling to CarsModelsGroupsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsModelsGroupsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsModelsGroupsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsModelsGroups.
func (c *CarsModelsGroupsClient) Update() *CarsModelsGroupsUpdate {
	mutation := newCarsModelsGroupsMutation(c.config, OpUpdate)
	return &CarsModelsGroupsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsModelsGroupsClient) UpdateOne(cmg *CarsModelsGroups) *CarsModelsGroupsUpdateOne {
	mutation := newCarsModelsGroupsMutation(c.config, OpUpdateOne, withCarsModelsGroups(cmg))
	return &CarsModelsGroupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsModelsGroupsClient) UpdateOneID(id int) *CarsModelsGroupsUpdateOne {
	mutation := newCarsModelsGroupsMutation(c.config, OpUpdateOne, withCarsModelsGroupsID(id))
	return &CarsModelsGroupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsModelsGroups.
func (c *CarsModelsGroupsClient) Delete() *CarsModelsGroupsDelete {
	mutation := newCarsModelsGroupsMutation(c.config, OpDelete)
	return &CarsModelsGroupsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsModelsGroupsClient) DeleteOne(cmg *CarsModelsGroups) *CarsModelsGroupsDeleteOne {
	return c.DeleteOneID(cmg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsModelsGroupsClient) DeleteOneID(id int) *CarsModelsGroupsDeleteOne {
	builder := c.Delete().Where(carsmodelsgroups.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsModelsGroupsDeleteOne{builder}
}

// Query returns a query builder for CarsModelsGroups.
func (c *CarsModelsGroupsClient) Query() *CarsModelsGroupsQuery {
	return &CarsModelsGroupsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsModelsGroups},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsModelsGroups entity by its id.
func (c *CarsModelsGroupsClient) Get(ctx context.Context, id int) (*CarsModelsGroups, error) {
	return c.Query().Where(carsmodelsgroups.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsModelsGroupsClient) GetX(ctx context.Context, id int) *CarsModelsGroups {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModel queries the model edge of a CarsModelsGroups.
func (c *CarsModelsGroupsClient) QueryModel(cmg *CarsModelsGroups) *CarsModelsQuery {
	query := (&CarsModelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cmg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodelsgroups.Table, carsmodelsgroups.FieldID, id),
			sqlgraph.To(carsmodels.Table, carsmodels.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carsmodelsgroups.ModelTable, carsmodelsgroups.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(cmg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParams queries the params edge of a CarsModelsGroups.
func (c *CarsModelsGroupsClient) QueryParams(cmg *CarsModelsGroups) *CarsModelsGroupsParamsQuery {
	query := (&CarsModelsGroupsParamsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cmg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodelsgroups.Table, carsmodelsgroups.FieldID, id),
			sqlgraph.To(carsmodelsgroupsparams.Table, carsmodelsgroupsparams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, carsmodelsgroups.ParamsTable, carsmodelsgroups.ParamsColumn),
		)
		fromV = sqlgraph.Neighbors(cmg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarsModelsGroupsClient) Hooks() []Hook {
	return c.hooks.CarsModelsGroups
}

// Interceptors returns the client interceptors.
func (c *CarsModelsGroupsClient) Interceptors() []Interceptor {
	return c.inters.CarsModelsGroups
}

func (c *CarsModelsGroupsClient) mutate(ctx context.Context, m *CarsModelsGroupsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsModelsGroupsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsModelsGroupsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsModelsGroupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsModelsGroupsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsModelsGroups mutation op: %q", m.Op())
	}
}

// CarsModelsGroupsParamsClient is a client for the CarsModelsGroupsParams schema.
type CarsModelsGroupsParamsClient struct {
	config
}

// NewCarsModelsGroupsParamsClient returns a client for the CarsModelsGroupsParams from the given config.
func NewCarsModelsGroupsParamsClient(c config) *CarsModelsGroupsParamsClient {
	return &CarsModelsGroupsParamsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsmodelsgroupsparams.Hooks(f(g(h())))`.
func (c *CarsModelsGroupsParamsClient) Use(hooks ...Hook) {
	c.hooks.CarsModelsGroupsParams = append(c.hooks.CarsModelsGroupsParams, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsmodelsgroupsparams.Intercept(f(g(h())))`.
func (c *CarsModelsGroupsParamsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsModelsGroupsParams = append(c.inters.CarsModelsGroupsParams, interceptors...)
}

// Create returns a builder for creating a CarsModelsGroupsParams entity.
func (c *CarsModelsGroupsParamsClient) Create() *CarsModelsGroupsParamsCreate {
	mutation := newCarsModelsGroupsParamsMutation(c.config, OpCreate)
	return &CarsModelsGroupsParamsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsModelsGroupsParams entities.
func (c *CarsModelsGroupsParamsClient) CreateBulk(builders ...*CarsModelsGroupsParamsCreate) *CarsModelsGroupsParamsCreateBulk {
	return &CarsModelsGroupsParamsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsModelsGroupsParamsClient) MapCreateBulk(slice any, setFunc func(*CarsModelsGroupsParamsCreate, int)) *CarsModelsGroupsParamsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsModelsGroupsParamsCreateBulk{err: fmt.Errorf("calling to CarsModelsGroupsParamsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsModelsGroupsParamsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsModelsGroupsParamsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsModelsGroupsParams.
func (c *CarsModelsGroupsParamsClient) Update() *CarsModelsGroupsParamsUpdate {
	mutation := newCarsModelsGroupsParamsMutation(c.config, OpUpdate)
	return &CarsModelsGroupsParamsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsModelsGroupsParamsClient) UpdateOne(cmgp *CarsModelsGroupsParams) *CarsModelsGroupsParamsUpdateOne {
	mutation := newCarsModelsGroupsParamsMutation(c.config, OpUpdateOne, withCarsModelsGroupsParams(cmgp))
	return &CarsModelsGroupsParamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsModelsGroupsParamsClient) UpdateOneID(id int) *CarsModelsGroupsParamsUpdateOne {
	mutation := newCarsModelsGroupsParamsMutation(c.config, OpUpdateOne, withCarsModelsGroupsParamsID(id))
	return &CarsModelsGroupsParamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsModelsGroupsParams.
func (c *CarsModelsGroupsParamsClient) Delete() *CarsModelsGroupsParamsDelete {
	mutation := newCarsModelsGroupsParamsMutation(c.config, OpDelete)
	return &CarsModelsGroupsParamsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsModelsGroupsParamsClient) DeleteOne(cmgp *CarsModelsGroupsParams) *CarsModelsGroupsParamsDeleteOne {
	return c.DeleteOneID(cmgp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsModelsGroupsParamsClient) DeleteOneID(id int) *CarsModelsGroupsParamsDeleteOne {
	builder := c.Delete().Where(carsmodelsgroupsparams.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsModelsGroupsParamsDeleteOne{builder}
}

// Query returns a query builder for CarsModelsGroupsParams.
func (c *CarsModelsGroupsParamsClient) Query() *CarsModelsGroupsParamsQuery {
	return &CarsModelsGroupsParamsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsModelsGroupsParams},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsModelsGroupsParams entity by its id.
func (c *CarsModelsGroupsParamsClient) Get(ctx context.Context, id int) (*CarsModelsGroupsParams, error) {
	return c.Query().Where(carsmodelsgroupsparams.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsModelsGroupsParamsClient) GetX(ctx context.Context, id int) *CarsModelsGroupsParams {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryModel queries the model edge of a CarsModelsGroupsParams.
func (c *CarsModelsGroupsParamsClient) QueryModel(cmgp *CarsModelsGroupsParams) *CarsModelsQuery {
	query := (&CarsModelsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cmgp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodelsgroupsparams.Table, carsmodelsgroupsparams.FieldID, id),
			sqlgraph.To(carsmodels.Table, carsmodels.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carsmodelsgroupsparams.ModelTable, carsmodelsgroupsparams.ModelColumn),
		)
		fromV = sqlgraph.Neighbors(cmgp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a CarsModelsGroupsParams.
func (c *CarsModelsGroupsParamsClient) QueryGroup(cmgp *CarsModelsGroupsParams) *CarsModelsGroupsQuery {
	query := (&CarsModelsGroupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cmgp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsmodelsgroupsparams.Table, carsmodelsgroupsparams.FieldID, id),
			sqlgraph.To(carsmodelsgroups.Table, carsmodelsgroups.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carsmodelsgroupsparams.GroupTable, carsmodelsgroupsparams.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(cmgp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarsModelsGroupsParamsClient) Hooks() []Hook {
	return c.hooks.CarsModelsGroupsParams
}

// Interceptors returns the client interceptors.
func (c *CarsModelsGroupsParamsClient) Interceptors() []Interceptor {
	return c.inters.CarsModelsGroupsParams
}

func (c *CarsModelsGroupsParamsClient) mutate(ctx context.Context, m *CarsModelsGroupsParamsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsModelsGroupsParamsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsModelsGroupsParamsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsModelsGroupsParamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsModelsGroupsParamsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsModelsGroupsParams mutation op: %q", m.Op())
	}
}

// CarsOperateLogClient is a client for the CarsOperateLog schema.
type CarsOperateLogClient struct {
	config
}

// NewCarsOperateLogClient returns a client for the CarsOperateLog from the given config.
func NewCarsOperateLogClient(c config) *CarsOperateLogClient {
	return &CarsOperateLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `carsoperatelog.Hooks(f(g(h())))`.
func (c *CarsOperateLogClient) Use(hooks ...Hook) {
	c.hooks.CarsOperateLog = append(c.hooks.CarsOperateLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `carsoperatelog.Intercept(f(g(h())))`.
func (c *CarsOperateLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.CarsOperateLog = append(c.inters.CarsOperateLog, interceptors...)
}

// Create returns a builder for creating a CarsOperateLog entity.
func (c *CarsOperateLogClient) Create() *CarsOperateLogCreate {
	mutation := newCarsOperateLogMutation(c.config, OpCreate)
	return &CarsOperateLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CarsOperateLog entities.
func (c *CarsOperateLogClient) CreateBulk(builders ...*CarsOperateLogCreate) *CarsOperateLogCreateBulk {
	return &CarsOperateLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarsOperateLogClient) MapCreateBulk(slice any, setFunc func(*CarsOperateLogCreate, int)) *CarsOperateLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarsOperateLogCreateBulk{err: fmt.Errorf("calling to CarsOperateLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarsOperateLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarsOperateLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CarsOperateLog.
func (c *CarsOperateLogClient) Update() *CarsOperateLogUpdate {
	mutation := newCarsOperateLogMutation(c.config, OpUpdate)
	return &CarsOperateLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarsOperateLogClient) UpdateOne(col *CarsOperateLog) *CarsOperateLogUpdateOne {
	mutation := newCarsOperateLogMutation(c.config, OpUpdateOne, withCarsOperateLog(col))
	return &CarsOperateLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarsOperateLogClient) UpdateOneID(id int) *CarsOperateLogUpdateOne {
	mutation := newCarsOperateLogMutation(c.config, OpUpdateOne, withCarsOperateLogID(id))
	return &CarsOperateLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CarsOperateLog.
func (c *CarsOperateLogClient) Delete() *CarsOperateLogDelete {
	mutation := newCarsOperateLogMutation(c.config, OpDelete)
	return &CarsOperateLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarsOperateLogClient) DeleteOne(col *CarsOperateLog) *CarsOperateLogDeleteOne {
	return c.DeleteOneID(col.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarsOperateLogClient) DeleteOneID(id int) *CarsOperateLogDeleteOne {
	builder := c.Delete().Where(carsoperatelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarsOperateLogDeleteOne{builder}
}

// Query returns a query builder for CarsOperateLog.
func (c *CarsOperateLogClient) Query() *CarsOperateLogQuery {
	return &CarsOperateLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCarsOperateLog},
		inters: c.Interceptors(),
	}
}

// Get returns a CarsOperateLog entity by its id.
func (c *CarsOperateLogClient) Get(ctx context.Context, id int) (*CarsOperateLog, error) {
	return c.Query().Where(carsoperatelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarsOperateLogClient) GetX(ctx context.Context, id int) *CarsOperateLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a CarsOperateLog.
func (c *CarsOperateLogClient) QueryBackgroundScenicArea(col *CarsOperateLog) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := col.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsoperatelog.Table, carsoperatelog.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carsoperatelog.BackgroundScenicAreaTable, carsoperatelog.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(col.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCar queries the car edge of a CarsOperateLog.
func (c *CarsOperateLogClient) QueryCar(col *CarsOperateLog) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := col.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(carsoperatelog.Table, carsoperatelog.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, carsoperatelog.CarTable, carsoperatelog.CarColumn),
		)
		fromV = sqlgraph.Neighbors(col.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarsOperateLogClient) Hooks() []Hook {
	return c.hooks.CarsOperateLog
}

// Interceptors returns the client interceptors.
func (c *CarsOperateLogClient) Interceptors() []Interceptor {
	return c.inters.CarsOperateLog
}

func (c *CarsOperateLogClient) mutate(ctx context.Context, m *CarsOperateLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarsOperateLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarsOperateLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarsOperateLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarsOperateLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CarsOperateLog mutation op: %q", m.Op())
	}
}

// CouponClient is a client for the Coupon schema.
type CouponClient struct {
	config
}

// NewCouponClient returns a client for the Coupon from the given config.
func NewCouponClient(c config) *CouponClient {
	return &CouponClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coupon.Hooks(f(g(h())))`.
func (c *CouponClient) Use(hooks ...Hook) {
	c.hooks.Coupon = append(c.hooks.Coupon, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coupon.Intercept(f(g(h())))`.
func (c *CouponClient) Intercept(interceptors ...Interceptor) {
	c.inters.Coupon = append(c.inters.Coupon, interceptors...)
}

// Create returns a builder for creating a Coupon entity.
func (c *CouponClient) Create() *CouponCreate {
	mutation := newCouponMutation(c.config, OpCreate)
	return &CouponCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Coupon entities.
func (c *CouponClient) CreateBulk(builders ...*CouponCreate) *CouponCreateBulk {
	return &CouponCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CouponClient) MapCreateBulk(slice any, setFunc func(*CouponCreate, int)) *CouponCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CouponCreateBulk{err: fmt.Errorf("calling to CouponClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CouponCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CouponCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Coupon.
func (c *CouponClient) Update() *CouponUpdate {
	mutation := newCouponMutation(c.config, OpUpdate)
	return &CouponUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CouponClient) UpdateOne(co *Coupon) *CouponUpdateOne {
	mutation := newCouponMutation(c.config, OpUpdateOne, withCoupon(co))
	return &CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CouponClient) UpdateOneID(id int) *CouponUpdateOne {
	mutation := newCouponMutation(c.config, OpUpdateOne, withCouponID(id))
	return &CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Coupon.
func (c *CouponClient) Delete() *CouponDelete {
	mutation := newCouponMutation(c.config, OpDelete)
	return &CouponDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CouponClient) DeleteOne(co *Coupon) *CouponDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CouponClient) DeleteOneID(id int) *CouponDeleteOne {
	builder := c.Delete().Where(coupon.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CouponDeleteOne{builder}
}

// Query returns a query builder for Coupon.
func (c *CouponClient) Query() *CouponQuery {
	return &CouponQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCoupon},
		inters: c.Interceptors(),
	}
}

// Get returns a Coupon entity by its id.
func (c *CouponClient) Get(ctx context.Context, id int) (*Coupon, error) {
	return c.Query().Where(coupon.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CouponClient) GetX(ctx context.Context, id int) *Coupon {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CouponClient) Hooks() []Hook {
	hooks := c.hooks.Coupon
	return append(hooks[:len(hooks):len(hooks)], coupon.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CouponClient) Interceptors() []Interceptor {
	inters := c.inters.Coupon
	return append(inters[:len(inters):len(inters)], coupon.Interceptors[:]...)
}

func (c *CouponClient) mutate(ctx context.Context, m *CouponMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CouponCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CouponUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CouponUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CouponDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Coupon mutation op: %q", m.Op())
	}
}

// FeedbackClient is a client for the Feedback schema.
type FeedbackClient struct {
	config
}

// NewFeedbackClient returns a client for the Feedback from the given config.
func NewFeedbackClient(c config) *FeedbackClient {
	return &FeedbackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `feedback.Hooks(f(g(h())))`.
func (c *FeedbackClient) Use(hooks ...Hook) {
	c.hooks.Feedback = append(c.hooks.Feedback, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `feedback.Intercept(f(g(h())))`.
func (c *FeedbackClient) Intercept(interceptors ...Interceptor) {
	c.inters.Feedback = append(c.inters.Feedback, interceptors...)
}

// Create returns a builder for creating a Feedback entity.
func (c *FeedbackClient) Create() *FeedbackCreate {
	mutation := newFeedbackMutation(c.config, OpCreate)
	return &FeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Feedback entities.
func (c *FeedbackClient) CreateBulk(builders ...*FeedbackCreate) *FeedbackCreateBulk {
	return &FeedbackCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeedbackClient) MapCreateBulk(slice any, setFunc func(*FeedbackCreate, int)) *FeedbackCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeedbackCreateBulk{err: fmt.Errorf("calling to FeedbackClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeedbackCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeedbackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Feedback.
func (c *FeedbackClient) Update() *FeedbackUpdate {
	mutation := newFeedbackMutation(c.config, OpUpdate)
	return &FeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeedbackClient) UpdateOne(f *Feedback) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedback(f))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeedbackClient) UpdateOneID(id int) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedbackID(id))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Feedback.
func (c *FeedbackClient) Delete() *FeedbackDelete {
	mutation := newFeedbackMutation(c.config, OpDelete)
	return &FeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeedbackClient) DeleteOne(f *Feedback) *FeedbackDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeedbackClient) DeleteOneID(id int) *FeedbackDeleteOne {
	builder := c.Delete().Where(feedback.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeedbackDeleteOne{builder}
}

// Query returns a query builder for Feedback.
func (c *FeedbackClient) Query() *FeedbackQuery {
	return &FeedbackQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeedback},
		inters: c.Interceptors(),
	}
}

// Get returns a Feedback entity by its id.
func (c *FeedbackClient) Get(ctx context.Context, id int) (*Feedback, error) {
	return c.Query().Where(feedback.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeedbackClient) GetX(ctx context.Context, id int) *Feedback {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeedbackClient) Hooks() []Hook {
	return c.hooks.Feedback
}

// Interceptors returns the client interceptors.
func (c *FeedbackClient) Interceptors() []Interceptor {
	return c.inters.Feedback
}

func (c *FeedbackClient) mutate(ctx context.Context, m *FeedbackMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Feedback mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileClient) MapCreateBulk(slice any, setFunc func(*FileCreate, int)) *FileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileCreateBulk{err: fmt.Errorf("calling to FileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id int) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id int) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id int) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id int) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	return c.hooks.File
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown File mutation op: %q", m.Op())
	}
}

// MapVersionClient is a client for the MapVersion schema.
type MapVersionClient struct {
	config
}

// NewMapVersionClient returns a client for the MapVersion from the given config.
func NewMapVersionClient(c config) *MapVersionClient {
	return &MapVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mapversion.Hooks(f(g(h())))`.
func (c *MapVersionClient) Use(hooks ...Hook) {
	c.hooks.MapVersion = append(c.hooks.MapVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mapversion.Intercept(f(g(h())))`.
func (c *MapVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MapVersion = append(c.inters.MapVersion, interceptors...)
}

// Create returns a builder for creating a MapVersion entity.
func (c *MapVersionClient) Create() *MapVersionCreate {
	mutation := newMapVersionMutation(c.config, OpCreate)
	return &MapVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MapVersion entities.
func (c *MapVersionClient) CreateBulk(builders ...*MapVersionCreate) *MapVersionCreateBulk {
	return &MapVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MapVersionClient) MapCreateBulk(slice any, setFunc func(*MapVersionCreate, int)) *MapVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MapVersionCreateBulk{err: fmt.Errorf("calling to MapVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MapVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MapVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MapVersion.
func (c *MapVersionClient) Update() *MapVersionUpdate {
	mutation := newMapVersionMutation(c.config, OpUpdate)
	return &MapVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MapVersionClient) UpdateOne(mv *MapVersion) *MapVersionUpdateOne {
	mutation := newMapVersionMutation(c.config, OpUpdateOne, withMapVersion(mv))
	return &MapVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MapVersionClient) UpdateOneID(id int) *MapVersionUpdateOne {
	mutation := newMapVersionMutation(c.config, OpUpdateOne, withMapVersionID(id))
	return &MapVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MapVersion.
func (c *MapVersionClient) Delete() *MapVersionDelete {
	mutation := newMapVersionMutation(c.config, OpDelete)
	return &MapVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MapVersionClient) DeleteOne(mv *MapVersion) *MapVersionDeleteOne {
	return c.DeleteOneID(mv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MapVersionClient) DeleteOneID(id int) *MapVersionDeleteOne {
	builder := c.Delete().Where(mapversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MapVersionDeleteOne{builder}
}

// Query returns a query builder for MapVersion.
func (c *MapVersionClient) Query() *MapVersionQuery {
	return &MapVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMapVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a MapVersion entity by its id.
func (c *MapVersionClient) Get(ctx context.Context, id int) (*MapVersion, error) {
	return c.Query().Where(mapversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MapVersionClient) GetX(ctx context.Context, id int) *MapVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a MapVersion.
func (c *MapVersionClient) QueryBackgroundScenicArea(mv *MapVersion) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mv.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mapversion.Table, mapversion.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mapversion.BackgroundScenicAreaTable, mapversion.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(mv.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MapVersionClient) Hooks() []Hook {
	return c.hooks.MapVersion
}

// Interceptors returns the client interceptors.
func (c *MapVersionClient) Interceptors() []Interceptor {
	return c.inters.MapVersion
}

func (c *MapVersionClient) mutate(ctx context.Context, m *MapVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MapVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MapVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MapVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MapVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MapVersion mutation op: %q", m.Op())
	}
}

// OperationUserClient is a client for the OperationUser schema.
type OperationUserClient struct {
	config
}

// NewOperationUserClient returns a client for the OperationUser from the given config.
func NewOperationUserClient(c config) *OperationUserClient {
	return &OperationUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `operationuser.Hooks(f(g(h())))`.
func (c *OperationUserClient) Use(hooks ...Hook) {
	c.hooks.OperationUser = append(c.hooks.OperationUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `operationuser.Intercept(f(g(h())))`.
func (c *OperationUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.OperationUser = append(c.inters.OperationUser, interceptors...)
}

// Create returns a builder for creating a OperationUser entity.
func (c *OperationUserClient) Create() *OperationUserCreate {
	mutation := newOperationUserMutation(c.config, OpCreate)
	return &OperationUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OperationUser entities.
func (c *OperationUserClient) CreateBulk(builders ...*OperationUserCreate) *OperationUserCreateBulk {
	return &OperationUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OperationUserClient) MapCreateBulk(slice any, setFunc func(*OperationUserCreate, int)) *OperationUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OperationUserCreateBulk{err: fmt.Errorf("calling to OperationUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OperationUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OperationUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OperationUser.
func (c *OperationUserClient) Update() *OperationUserUpdate {
	mutation := newOperationUserMutation(c.config, OpUpdate)
	return &OperationUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OperationUserClient) UpdateOne(ou *OperationUser) *OperationUserUpdateOne {
	mutation := newOperationUserMutation(c.config, OpUpdateOne, withOperationUser(ou))
	return &OperationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OperationUserClient) UpdateOneID(id int) *OperationUserUpdateOne {
	mutation := newOperationUserMutation(c.config, OpUpdateOne, withOperationUserID(id))
	return &OperationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OperationUser.
func (c *OperationUserClient) Delete() *OperationUserDelete {
	mutation := newOperationUserMutation(c.config, OpDelete)
	return &OperationUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OperationUserClient) DeleteOne(ou *OperationUser) *OperationUserDeleteOne {
	return c.DeleteOneID(ou.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OperationUserClient) DeleteOneID(id int) *OperationUserDeleteOne {
	builder := c.Delete().Where(operationuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OperationUserDeleteOne{builder}
}

// Query returns a query builder for OperationUser.
func (c *OperationUserClient) Query() *OperationUserQuery {
	return &OperationUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOperationUser},
		inters: c.Interceptors(),
	}
}

// Get returns a OperationUser entity by its id.
func (c *OperationUserClient) Get(ctx context.Context, id int) (*OperationUser, error) {
	return c.Query().Where(operationuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OperationUserClient) GetX(ctx context.Context, id int) *OperationUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OperationUserClient) Hooks() []Hook {
	return c.hooks.OperationUser
}

// Interceptors returns the client interceptors.
func (c *OperationUserClient) Interceptors() []Interceptor {
	return c.inters.OperationUser
}

func (c *OperationUserClient) mutate(ctx context.Context, m *OperationUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OperationUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OperationUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OperationUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OperationUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OperationUser mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id int) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id int) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id int) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id int) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Order.
func (c *OrderClient) QueryCar(o *Order) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.CarTable, order.CarColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a Order.
func (c *OrderClient) QueryBackgroundScenicArea(o *Order) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, order.BackgroundScenicAreaTable, order.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBilling queries the billing edge of a Order.
func (c *OrderClient) QueryBilling(o *Order) *OrderBillingQuery {
	query := (&OrderBillingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderbilling.Table, orderbilling.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, order.BillingTable, order.BillingColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRefund queries the refund edge of a Order.
func (c *OrderClient) QueryRefund(o *Order) *OrderRefundQuery {
	query := (&OrderRefundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderrefund.Table, orderrefund.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, order.RefundTable, order.RefundColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySharing queries the sharing edge of a Order.
func (c *OrderClient) QuerySharing(o *Order) *OrderSharingQuery {
	query := (&OrderSharingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(ordersharing.Table, ordersharing.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, order.SharingTable, order.SharingColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderAppealClient is a client for the OrderAppeal schema.
type OrderAppealClient struct {
	config
}

// NewOrderAppealClient returns a client for the OrderAppeal from the given config.
func NewOrderAppealClient(c config) *OrderAppealClient {
	return &OrderAppealClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderappeal.Hooks(f(g(h())))`.
func (c *OrderAppealClient) Use(hooks ...Hook) {
	c.hooks.OrderAppeal = append(c.hooks.OrderAppeal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderappeal.Intercept(f(g(h())))`.
func (c *OrderAppealClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderAppeal = append(c.inters.OrderAppeal, interceptors...)
}

// Create returns a builder for creating a OrderAppeal entity.
func (c *OrderAppealClient) Create() *OrderAppealCreate {
	mutation := newOrderAppealMutation(c.config, OpCreate)
	return &OrderAppealCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderAppeal entities.
func (c *OrderAppealClient) CreateBulk(builders ...*OrderAppealCreate) *OrderAppealCreateBulk {
	return &OrderAppealCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderAppealClient) MapCreateBulk(slice any, setFunc func(*OrderAppealCreate, int)) *OrderAppealCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderAppealCreateBulk{err: fmt.Errorf("calling to OrderAppealClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderAppealCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderAppealCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderAppeal.
func (c *OrderAppealClient) Update() *OrderAppealUpdate {
	mutation := newOrderAppealMutation(c.config, OpUpdate)
	return &OrderAppealUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderAppealClient) UpdateOne(oa *OrderAppeal) *OrderAppealUpdateOne {
	mutation := newOrderAppealMutation(c.config, OpUpdateOne, withOrderAppeal(oa))
	return &OrderAppealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderAppealClient) UpdateOneID(id int) *OrderAppealUpdateOne {
	mutation := newOrderAppealMutation(c.config, OpUpdateOne, withOrderAppealID(id))
	return &OrderAppealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderAppeal.
func (c *OrderAppealClient) Delete() *OrderAppealDelete {
	mutation := newOrderAppealMutation(c.config, OpDelete)
	return &OrderAppealDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderAppealClient) DeleteOne(oa *OrderAppeal) *OrderAppealDeleteOne {
	return c.DeleteOneID(oa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderAppealClient) DeleteOneID(id int) *OrderAppealDeleteOne {
	builder := c.Delete().Where(orderappeal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderAppealDeleteOne{builder}
}

// Query returns a query builder for OrderAppeal.
func (c *OrderAppealClient) Query() *OrderAppealQuery {
	return &OrderAppealQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderAppeal},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderAppeal entity by its id.
func (c *OrderAppealClient) Get(ctx context.Context, id int) (*OrderAppeal, error) {
	return c.Query().Where(orderappeal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderAppealClient) GetX(ctx context.Context, id int) *OrderAppeal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderAppealClient) Hooks() []Hook {
	return c.hooks.OrderAppeal
}

// Interceptors returns the client interceptors.
func (c *OrderAppealClient) Interceptors() []Interceptor {
	return c.inters.OrderAppeal
}

func (c *OrderAppealClient) mutate(ctx context.Context, m *OrderAppealMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderAppealCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderAppealUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderAppealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderAppealDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderAppeal mutation op: %q", m.Op())
	}
}

// OrderBillingClient is a client for the OrderBilling schema.
type OrderBillingClient struct {
	config
}

// NewOrderBillingClient returns a client for the OrderBilling from the given config.
func NewOrderBillingClient(c config) *OrderBillingClient {
	return &OrderBillingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderbilling.Hooks(f(g(h())))`.
func (c *OrderBillingClient) Use(hooks ...Hook) {
	c.hooks.OrderBilling = append(c.hooks.OrderBilling, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderbilling.Intercept(f(g(h())))`.
func (c *OrderBillingClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderBilling = append(c.inters.OrderBilling, interceptors...)
}

// Create returns a builder for creating a OrderBilling entity.
func (c *OrderBillingClient) Create() *OrderBillingCreate {
	mutation := newOrderBillingMutation(c.config, OpCreate)
	return &OrderBillingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderBilling entities.
func (c *OrderBillingClient) CreateBulk(builders ...*OrderBillingCreate) *OrderBillingCreateBulk {
	return &OrderBillingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderBillingClient) MapCreateBulk(slice any, setFunc func(*OrderBillingCreate, int)) *OrderBillingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderBillingCreateBulk{err: fmt.Errorf("calling to OrderBillingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderBillingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderBillingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderBilling.
func (c *OrderBillingClient) Update() *OrderBillingUpdate {
	mutation := newOrderBillingMutation(c.config, OpUpdate)
	return &OrderBillingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderBillingClient) UpdateOne(ob *OrderBilling) *OrderBillingUpdateOne {
	mutation := newOrderBillingMutation(c.config, OpUpdateOne, withOrderBilling(ob))
	return &OrderBillingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderBillingClient) UpdateOneID(id int) *OrderBillingUpdateOne {
	mutation := newOrderBillingMutation(c.config, OpUpdateOne, withOrderBillingID(id))
	return &OrderBillingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderBilling.
func (c *OrderBillingClient) Delete() *OrderBillingDelete {
	mutation := newOrderBillingMutation(c.config, OpDelete)
	return &OrderBillingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderBillingClient) DeleteOne(ob *OrderBilling) *OrderBillingDeleteOne {
	return c.DeleteOneID(ob.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderBillingClient) DeleteOneID(id int) *OrderBillingDeleteOne {
	builder := c.Delete().Where(orderbilling.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderBillingDeleteOne{builder}
}

// Query returns a query builder for OrderBilling.
func (c *OrderBillingClient) Query() *OrderBillingQuery {
	return &OrderBillingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderBilling},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderBilling entity by its id.
func (c *OrderBillingClient) Get(ctx context.Context, id int) (*OrderBilling, error) {
	return c.Query().Where(orderbilling.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderBillingClient) GetX(ctx context.Context, id int) *OrderBilling {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderBilling.
func (c *OrderBillingClient) QueryOrder(ob *OrderBilling) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ob.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderbilling.Table, orderbilling.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, orderbilling.OrderTable, orderbilling.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(ob.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderBillingClient) Hooks() []Hook {
	return c.hooks.OrderBilling
}

// Interceptors returns the client interceptors.
func (c *OrderBillingClient) Interceptors() []Interceptor {
	return c.inters.OrderBilling
}

func (c *OrderBillingClient) mutate(ctx context.Context, m *OrderBillingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderBillingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderBillingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderBillingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderBillingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderBilling mutation op: %q", m.Op())
	}
}

// OrderExtendFlightClient is a client for the OrderExtendFlight schema.
type OrderExtendFlightClient struct {
	config
}

// NewOrderExtendFlightClient returns a client for the OrderExtendFlight from the given config.
func NewOrderExtendFlightClient(c config) *OrderExtendFlightClient {
	return &OrderExtendFlightClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderextendflight.Hooks(f(g(h())))`.
func (c *OrderExtendFlightClient) Use(hooks ...Hook) {
	c.hooks.OrderExtendFlight = append(c.hooks.OrderExtendFlight, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderextendflight.Intercept(f(g(h())))`.
func (c *OrderExtendFlightClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderExtendFlight = append(c.inters.OrderExtendFlight, interceptors...)
}

// Create returns a builder for creating a OrderExtendFlight entity.
func (c *OrderExtendFlightClient) Create() *OrderExtendFlightCreate {
	mutation := newOrderExtendFlightMutation(c.config, OpCreate)
	return &OrderExtendFlightCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderExtendFlight entities.
func (c *OrderExtendFlightClient) CreateBulk(builders ...*OrderExtendFlightCreate) *OrderExtendFlightCreateBulk {
	return &OrderExtendFlightCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderExtendFlightClient) MapCreateBulk(slice any, setFunc func(*OrderExtendFlightCreate, int)) *OrderExtendFlightCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderExtendFlightCreateBulk{err: fmt.Errorf("calling to OrderExtendFlightClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderExtendFlightCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderExtendFlightCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderExtendFlight.
func (c *OrderExtendFlightClient) Update() *OrderExtendFlightUpdate {
	mutation := newOrderExtendFlightMutation(c.config, OpUpdate)
	return &OrderExtendFlightUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderExtendFlightClient) UpdateOne(oef *OrderExtendFlight) *OrderExtendFlightUpdateOne {
	mutation := newOrderExtendFlightMutation(c.config, OpUpdateOne, withOrderExtendFlight(oef))
	return &OrderExtendFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderExtendFlightClient) UpdateOneID(id int) *OrderExtendFlightUpdateOne {
	mutation := newOrderExtendFlightMutation(c.config, OpUpdateOne, withOrderExtendFlightID(id))
	return &OrderExtendFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderExtendFlight.
func (c *OrderExtendFlightClient) Delete() *OrderExtendFlightDelete {
	mutation := newOrderExtendFlightMutation(c.config, OpDelete)
	return &OrderExtendFlightDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderExtendFlightClient) DeleteOne(oef *OrderExtendFlight) *OrderExtendFlightDeleteOne {
	return c.DeleteOneID(oef.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderExtendFlightClient) DeleteOneID(id int) *OrderExtendFlightDeleteOne {
	builder := c.Delete().Where(orderextendflight.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderExtendFlightDeleteOne{builder}
}

// Query returns a query builder for OrderExtendFlight.
func (c *OrderExtendFlightClient) Query() *OrderExtendFlightQuery {
	return &OrderExtendFlightQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderExtendFlight},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderExtendFlight entity by its id.
func (c *OrderExtendFlightClient) Get(ctx context.Context, id int) (*OrderExtendFlight, error) {
	return c.Query().Where(orderextendflight.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderExtendFlightClient) GetX(ctx context.Context, id int) *OrderExtendFlight {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderExtendFlightClient) Hooks() []Hook {
	return c.hooks.OrderExtendFlight
}

// Interceptors returns the client interceptors.
func (c *OrderExtendFlightClient) Interceptors() []Interceptor {
	return c.inters.OrderExtendFlight
}

func (c *OrderExtendFlightClient) mutate(ctx context.Context, m *OrderExtendFlightMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderExtendFlightCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderExtendFlightUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderExtendFlightUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderExtendFlightDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderExtendFlight mutation op: %q", m.Op())
	}
}

// OrderRefundClient is a client for the OrderRefund schema.
type OrderRefundClient struct {
	config
}

// NewOrderRefundClient returns a client for the OrderRefund from the given config.
func NewOrderRefundClient(c config) *OrderRefundClient {
	return &OrderRefundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderrefund.Hooks(f(g(h())))`.
func (c *OrderRefundClient) Use(hooks ...Hook) {
	c.hooks.OrderRefund = append(c.hooks.OrderRefund, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderrefund.Intercept(f(g(h())))`.
func (c *OrderRefundClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderRefund = append(c.inters.OrderRefund, interceptors...)
}

// Create returns a builder for creating a OrderRefund entity.
func (c *OrderRefundClient) Create() *OrderRefundCreate {
	mutation := newOrderRefundMutation(c.config, OpCreate)
	return &OrderRefundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderRefund entities.
func (c *OrderRefundClient) CreateBulk(builders ...*OrderRefundCreate) *OrderRefundCreateBulk {
	return &OrderRefundCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderRefundClient) MapCreateBulk(slice any, setFunc func(*OrderRefundCreate, int)) *OrderRefundCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderRefundCreateBulk{err: fmt.Errorf("calling to OrderRefundClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderRefundCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderRefundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderRefund.
func (c *OrderRefundClient) Update() *OrderRefundUpdate {
	mutation := newOrderRefundMutation(c.config, OpUpdate)
	return &OrderRefundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderRefundClient) UpdateOne(or *OrderRefund) *OrderRefundUpdateOne {
	mutation := newOrderRefundMutation(c.config, OpUpdateOne, withOrderRefund(or))
	return &OrderRefundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderRefundClient) UpdateOneID(id int) *OrderRefundUpdateOne {
	mutation := newOrderRefundMutation(c.config, OpUpdateOne, withOrderRefundID(id))
	return &OrderRefundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderRefund.
func (c *OrderRefundClient) Delete() *OrderRefundDelete {
	mutation := newOrderRefundMutation(c.config, OpDelete)
	return &OrderRefundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderRefundClient) DeleteOne(or *OrderRefund) *OrderRefundDeleteOne {
	return c.DeleteOneID(or.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderRefundClient) DeleteOneID(id int) *OrderRefundDeleteOne {
	builder := c.Delete().Where(orderrefund.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderRefundDeleteOne{builder}
}

// Query returns a query builder for OrderRefund.
func (c *OrderRefundClient) Query() *OrderRefundQuery {
	return &OrderRefundQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderRefund},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderRefund entity by its id.
func (c *OrderRefundClient) Get(ctx context.Context, id int) (*OrderRefund, error) {
	return c.Query().Where(orderrefund.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderRefundClient) GetX(ctx context.Context, id int) *OrderRefund {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderRefund.
func (c *OrderRefundClient) QueryOrder(or *OrderRefund) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderrefund.Table, orderrefund.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orderrefund.OrderTable, orderrefund.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderRefundClient) Hooks() []Hook {
	return c.hooks.OrderRefund
}

// Interceptors returns the client interceptors.
func (c *OrderRefundClient) Interceptors() []Interceptor {
	return c.inters.OrderRefund
}

func (c *OrderRefundClient) mutate(ctx context.Context, m *OrderRefundMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderRefundCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderRefundUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderRefundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderRefundDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderRefund mutation op: %q", m.Op())
	}
}

// OrderSharingClient is a client for the OrderSharing schema.
type OrderSharingClient struct {
	config
}

// NewOrderSharingClient returns a client for the OrderSharing from the given config.
func NewOrderSharingClient(c config) *OrderSharingClient {
	return &OrderSharingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordersharing.Hooks(f(g(h())))`.
func (c *OrderSharingClient) Use(hooks ...Hook) {
	c.hooks.OrderSharing = append(c.hooks.OrderSharing, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordersharing.Intercept(f(g(h())))`.
func (c *OrderSharingClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderSharing = append(c.inters.OrderSharing, interceptors...)
}

// Create returns a builder for creating a OrderSharing entity.
func (c *OrderSharingClient) Create() *OrderSharingCreate {
	mutation := newOrderSharingMutation(c.config, OpCreate)
	return &OrderSharingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderSharing entities.
func (c *OrderSharingClient) CreateBulk(builders ...*OrderSharingCreate) *OrderSharingCreateBulk {
	return &OrderSharingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderSharingClient) MapCreateBulk(slice any, setFunc func(*OrderSharingCreate, int)) *OrderSharingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderSharingCreateBulk{err: fmt.Errorf("calling to OrderSharingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderSharingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderSharingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderSharing.
func (c *OrderSharingClient) Update() *OrderSharingUpdate {
	mutation := newOrderSharingMutation(c.config, OpUpdate)
	return &OrderSharingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderSharingClient) UpdateOne(os *OrderSharing) *OrderSharingUpdateOne {
	mutation := newOrderSharingMutation(c.config, OpUpdateOne, withOrderSharing(os))
	return &OrderSharingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderSharingClient) UpdateOneID(id int) *OrderSharingUpdateOne {
	mutation := newOrderSharingMutation(c.config, OpUpdateOne, withOrderSharingID(id))
	return &OrderSharingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderSharing.
func (c *OrderSharingClient) Delete() *OrderSharingDelete {
	mutation := newOrderSharingMutation(c.config, OpDelete)
	return &OrderSharingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderSharingClient) DeleteOne(os *OrderSharing) *OrderSharingDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderSharingClient) DeleteOneID(id int) *OrderSharingDeleteOne {
	builder := c.Delete().Where(ordersharing.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderSharingDeleteOne{builder}
}

// Query returns a query builder for OrderSharing.
func (c *OrderSharingClient) Query() *OrderSharingQuery {
	return &OrderSharingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderSharing},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderSharing entity by its id.
func (c *OrderSharingClient) Get(ctx context.Context, id int) (*OrderSharing, error) {
	return c.Query().Where(ordersharing.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderSharingClient) GetX(ctx context.Context, id int) *OrderSharing {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderSharing.
func (c *OrderSharingClient) QueryOrder(os *OrderSharing) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ordersharing.Table, ordersharing.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, ordersharing.OrderTable, ordersharing.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderSharingClient) Hooks() []Hook {
	return c.hooks.OrderSharing
}

// Interceptors returns the client interceptors.
func (c *OrderSharingClient) Interceptors() []Interceptor {
	return c.inters.OrderSharing
}

func (c *OrderSharingClient) mutate(ctx context.Context, m *OrderSharingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderSharingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderSharingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderSharingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderSharingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderSharing mutation op: %q", m.Op())
	}
}

// OtaBtreeClient is a client for the OtaBtree schema.
type OtaBtreeClient struct {
	config
}

// NewOtaBtreeClient returns a client for the OtaBtree from the given config.
func NewOtaBtreeClient(c config) *OtaBtreeClient {
	return &OtaBtreeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `otabtree.Hooks(f(g(h())))`.
func (c *OtaBtreeClient) Use(hooks ...Hook) {
	c.hooks.OtaBtree = append(c.hooks.OtaBtree, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `otabtree.Intercept(f(g(h())))`.
func (c *OtaBtreeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OtaBtree = append(c.inters.OtaBtree, interceptors...)
}

// Create returns a builder for creating a OtaBtree entity.
func (c *OtaBtreeClient) Create() *OtaBtreeCreate {
	mutation := newOtaBtreeMutation(c.config, OpCreate)
	return &OtaBtreeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OtaBtree entities.
func (c *OtaBtreeClient) CreateBulk(builders ...*OtaBtreeCreate) *OtaBtreeCreateBulk {
	return &OtaBtreeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OtaBtreeClient) MapCreateBulk(slice any, setFunc func(*OtaBtreeCreate, int)) *OtaBtreeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OtaBtreeCreateBulk{err: fmt.Errorf("calling to OtaBtreeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OtaBtreeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OtaBtreeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OtaBtree.
func (c *OtaBtreeClient) Update() *OtaBtreeUpdate {
	mutation := newOtaBtreeMutation(c.config, OpUpdate)
	return &OtaBtreeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OtaBtreeClient) UpdateOne(ob *OtaBtree) *OtaBtreeUpdateOne {
	mutation := newOtaBtreeMutation(c.config, OpUpdateOne, withOtaBtree(ob))
	return &OtaBtreeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OtaBtreeClient) UpdateOneID(id int) *OtaBtreeUpdateOne {
	mutation := newOtaBtreeMutation(c.config, OpUpdateOne, withOtaBtreeID(id))
	return &OtaBtreeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OtaBtree.
func (c *OtaBtreeClient) Delete() *OtaBtreeDelete {
	mutation := newOtaBtreeMutation(c.config, OpDelete)
	return &OtaBtreeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OtaBtreeClient) DeleteOne(ob *OtaBtree) *OtaBtreeDeleteOne {
	return c.DeleteOneID(ob.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OtaBtreeClient) DeleteOneID(id int) *OtaBtreeDeleteOne {
	builder := c.Delete().Where(otabtree.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OtaBtreeDeleteOne{builder}
}

// Query returns a query builder for OtaBtree.
func (c *OtaBtreeClient) Query() *OtaBtreeQuery {
	return &OtaBtreeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOtaBtree},
		inters: c.Interceptors(),
	}
}

// Get returns a OtaBtree entity by its id.
func (c *OtaBtreeClient) Get(ctx context.Context, id int) (*OtaBtree, error) {
	return c.Query().Where(otabtree.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OtaBtreeClient) GetX(ctx context.Context, id int) *OtaBtree {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OtaBtreeClient) Hooks() []Hook {
	hooks := c.hooks.OtaBtree
	return append(hooks[:len(hooks):len(hooks)], otabtree.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OtaBtreeClient) Interceptors() []Interceptor {
	inters := c.inters.OtaBtree
	return append(inters[:len(inters):len(inters)], otabtree.Interceptors[:]...)
}

func (c *OtaBtreeClient) mutate(ctx context.Context, m *OtaBtreeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OtaBtreeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OtaBtreeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OtaBtreeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OtaBtreeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OtaBtree mutation op: %q", m.Op())
	}
}

// OtaDeployClient is a client for the OtaDeploy schema.
type OtaDeployClient struct {
	config
}

// NewOtaDeployClient returns a client for the OtaDeploy from the given config.
func NewOtaDeployClient(c config) *OtaDeployClient {
	return &OtaDeployClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `otadeploy.Hooks(f(g(h())))`.
func (c *OtaDeployClient) Use(hooks ...Hook) {
	c.hooks.OtaDeploy = append(c.hooks.OtaDeploy, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `otadeploy.Intercept(f(g(h())))`.
func (c *OtaDeployClient) Intercept(interceptors ...Interceptor) {
	c.inters.OtaDeploy = append(c.inters.OtaDeploy, interceptors...)
}

// Create returns a builder for creating a OtaDeploy entity.
func (c *OtaDeployClient) Create() *OtaDeployCreate {
	mutation := newOtaDeployMutation(c.config, OpCreate)
	return &OtaDeployCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OtaDeploy entities.
func (c *OtaDeployClient) CreateBulk(builders ...*OtaDeployCreate) *OtaDeployCreateBulk {
	return &OtaDeployCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OtaDeployClient) MapCreateBulk(slice any, setFunc func(*OtaDeployCreate, int)) *OtaDeployCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OtaDeployCreateBulk{err: fmt.Errorf("calling to OtaDeployClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OtaDeployCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OtaDeployCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OtaDeploy.
func (c *OtaDeployClient) Update() *OtaDeployUpdate {
	mutation := newOtaDeployMutation(c.config, OpUpdate)
	return &OtaDeployUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OtaDeployClient) UpdateOne(od *OtaDeploy) *OtaDeployUpdateOne {
	mutation := newOtaDeployMutation(c.config, OpUpdateOne, withOtaDeploy(od))
	return &OtaDeployUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OtaDeployClient) UpdateOneID(id int) *OtaDeployUpdateOne {
	mutation := newOtaDeployMutation(c.config, OpUpdateOne, withOtaDeployID(id))
	return &OtaDeployUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OtaDeploy.
func (c *OtaDeployClient) Delete() *OtaDeployDelete {
	mutation := newOtaDeployMutation(c.config, OpDelete)
	return &OtaDeployDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OtaDeployClient) DeleteOne(od *OtaDeploy) *OtaDeployDeleteOne {
	return c.DeleteOneID(od.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OtaDeployClient) DeleteOneID(id int) *OtaDeployDeleteOne {
	builder := c.Delete().Where(otadeploy.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OtaDeployDeleteOne{builder}
}

// Query returns a query builder for OtaDeploy.
func (c *OtaDeployClient) Query() *OtaDeployQuery {
	return &OtaDeployQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOtaDeploy},
		inters: c.Interceptors(),
	}
}

// Get returns a OtaDeploy entity by its id.
func (c *OtaDeployClient) Get(ctx context.Context, id int) (*OtaDeploy, error) {
	return c.Query().Where(otadeploy.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OtaDeployClient) GetX(ctx context.Context, id int) *OtaDeploy {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OtaDeployClient) Hooks() []Hook {
	hooks := c.hooks.OtaDeploy
	return append(hooks[:len(hooks):len(hooks)], otadeploy.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OtaDeployClient) Interceptors() []Interceptor {
	inters := c.inters.OtaDeploy
	return append(inters[:len(inters):len(inters)], otadeploy.Interceptors[:]...)
}

func (c *OtaDeployClient) mutate(ctx context.Context, m *OtaDeployMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OtaDeployCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OtaDeployUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OtaDeployUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OtaDeployDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OtaDeploy mutation op: %q", m.Op())
	}
}

// OtaVersionClient is a client for the OtaVersion schema.
type OtaVersionClient struct {
	config
}

// NewOtaVersionClient returns a client for the OtaVersion from the given config.
func NewOtaVersionClient(c config) *OtaVersionClient {
	return &OtaVersionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `otaversion.Hooks(f(g(h())))`.
func (c *OtaVersionClient) Use(hooks ...Hook) {
	c.hooks.OtaVersion = append(c.hooks.OtaVersion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `otaversion.Intercept(f(g(h())))`.
func (c *OtaVersionClient) Intercept(interceptors ...Interceptor) {
	c.inters.OtaVersion = append(c.inters.OtaVersion, interceptors...)
}

// Create returns a builder for creating a OtaVersion entity.
func (c *OtaVersionClient) Create() *OtaVersionCreate {
	mutation := newOtaVersionMutation(c.config, OpCreate)
	return &OtaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OtaVersion entities.
func (c *OtaVersionClient) CreateBulk(builders ...*OtaVersionCreate) *OtaVersionCreateBulk {
	return &OtaVersionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OtaVersionClient) MapCreateBulk(slice any, setFunc func(*OtaVersionCreate, int)) *OtaVersionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OtaVersionCreateBulk{err: fmt.Errorf("calling to OtaVersionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OtaVersionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OtaVersionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OtaVersion.
func (c *OtaVersionClient) Update() *OtaVersionUpdate {
	mutation := newOtaVersionMutation(c.config, OpUpdate)
	return &OtaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OtaVersionClient) UpdateOne(ov *OtaVersion) *OtaVersionUpdateOne {
	mutation := newOtaVersionMutation(c.config, OpUpdateOne, withOtaVersion(ov))
	return &OtaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OtaVersionClient) UpdateOneID(id int) *OtaVersionUpdateOne {
	mutation := newOtaVersionMutation(c.config, OpUpdateOne, withOtaVersionID(id))
	return &OtaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OtaVersion.
func (c *OtaVersionClient) Delete() *OtaVersionDelete {
	mutation := newOtaVersionMutation(c.config, OpDelete)
	return &OtaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OtaVersionClient) DeleteOne(ov *OtaVersion) *OtaVersionDeleteOne {
	return c.DeleteOneID(ov.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OtaVersionClient) DeleteOneID(id int) *OtaVersionDeleteOne {
	builder := c.Delete().Where(otaversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OtaVersionDeleteOne{builder}
}

// Query returns a query builder for OtaVersion.
func (c *OtaVersionClient) Query() *OtaVersionQuery {
	return &OtaVersionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOtaVersion},
		inters: c.Interceptors(),
	}
}

// Get returns a OtaVersion entity by its id.
func (c *OtaVersionClient) Get(ctx context.Context, id int) (*OtaVersion, error) {
	return c.Query().Where(otaversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OtaVersionClient) GetX(ctx context.Context, id int) *OtaVersion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OtaVersionClient) Hooks() []Hook {
	hooks := c.hooks.OtaVersion
	return append(hooks[:len(hooks):len(hooks)], otaversion.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OtaVersionClient) Interceptors() []Interceptor {
	inters := c.inters.OtaVersion
	return append(inters[:len(inters):len(inters)], otaversion.Interceptors[:]...)
}

func (c *OtaVersionClient) mutate(ctx context.Context, m *OtaVersionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OtaVersionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OtaVersionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OtaVersionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OtaVersionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OtaVersion mutation op: %q", m.Op())
	}
}

// PayTxBillClient is a client for the PayTxBill schema.
type PayTxBillClient struct {
	config
}

// NewPayTxBillClient returns a client for the PayTxBill from the given config.
func NewPayTxBillClient(c config) *PayTxBillClient {
	return &PayTxBillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paytxbill.Hooks(f(g(h())))`.
func (c *PayTxBillClient) Use(hooks ...Hook) {
	c.hooks.PayTxBill = append(c.hooks.PayTxBill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paytxbill.Intercept(f(g(h())))`.
func (c *PayTxBillClient) Intercept(interceptors ...Interceptor) {
	c.inters.PayTxBill = append(c.inters.PayTxBill, interceptors...)
}

// Create returns a builder for creating a PayTxBill entity.
func (c *PayTxBillClient) Create() *PayTxBillCreate {
	mutation := newPayTxBillMutation(c.config, OpCreate)
	return &PayTxBillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PayTxBill entities.
func (c *PayTxBillClient) CreateBulk(builders ...*PayTxBillCreate) *PayTxBillCreateBulk {
	return &PayTxBillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PayTxBillClient) MapCreateBulk(slice any, setFunc func(*PayTxBillCreate, int)) *PayTxBillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PayTxBillCreateBulk{err: fmt.Errorf("calling to PayTxBillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PayTxBillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PayTxBillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PayTxBill.
func (c *PayTxBillClient) Update() *PayTxBillUpdate {
	mutation := newPayTxBillMutation(c.config, OpUpdate)
	return &PayTxBillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PayTxBillClient) UpdateOne(ptb *PayTxBill) *PayTxBillUpdateOne {
	mutation := newPayTxBillMutation(c.config, OpUpdateOne, withPayTxBill(ptb))
	return &PayTxBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PayTxBillClient) UpdateOneID(id int) *PayTxBillUpdateOne {
	mutation := newPayTxBillMutation(c.config, OpUpdateOne, withPayTxBillID(id))
	return &PayTxBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PayTxBill.
func (c *PayTxBillClient) Delete() *PayTxBillDelete {
	mutation := newPayTxBillMutation(c.config, OpDelete)
	return &PayTxBillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PayTxBillClient) DeleteOne(ptb *PayTxBill) *PayTxBillDeleteOne {
	return c.DeleteOneID(ptb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PayTxBillClient) DeleteOneID(id int) *PayTxBillDeleteOne {
	builder := c.Delete().Where(paytxbill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PayTxBillDeleteOne{builder}
}

// Query returns a query builder for PayTxBill.
func (c *PayTxBillClient) Query() *PayTxBillQuery {
	return &PayTxBillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePayTxBill},
		inters: c.Interceptors(),
	}
}

// Get returns a PayTxBill entity by its id.
func (c *PayTxBillClient) Get(ctx context.Context, id int) (*PayTxBill, error) {
	return c.Query().Where(paytxbill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PayTxBillClient) GetX(ctx context.Context, id int) *PayTxBill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a PayTxBill.
func (c *PayTxBillClient) QueryBackgroundScenicArea(ptb *PayTxBill) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ptb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(paytxbill.Table, paytxbill.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, paytxbill.BackgroundScenicAreaTable, paytxbill.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(ptb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PayTxBillClient) Hooks() []Hook {
	return c.hooks.PayTxBill
}

// Interceptors returns the client interceptors.
func (c *PayTxBillClient) Interceptors() []Interceptor {
	return c.inters.PayTxBill
}

func (c *PayTxBillClient) mutate(ctx context.Context, m *PayTxBillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PayTxBillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PayTxBillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PayTxBillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PayTxBillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PayTxBill mutation op: %q", m.Op())
	}
}

// PaymentAccountClient is a client for the PaymentAccount schema.
type PaymentAccountClient struct {
	config
}

// NewPaymentAccountClient returns a client for the PaymentAccount from the given config.
func NewPaymentAccountClient(c config) *PaymentAccountClient {
	return &PaymentAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymentaccount.Hooks(f(g(h())))`.
func (c *PaymentAccountClient) Use(hooks ...Hook) {
	c.hooks.PaymentAccount = append(c.hooks.PaymentAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymentaccount.Intercept(f(g(h())))`.
func (c *PaymentAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentAccount = append(c.inters.PaymentAccount, interceptors...)
}

// Create returns a builder for creating a PaymentAccount entity.
func (c *PaymentAccountClient) Create() *PaymentAccountCreate {
	mutation := newPaymentAccountMutation(c.config, OpCreate)
	return &PaymentAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentAccount entities.
func (c *PaymentAccountClient) CreateBulk(builders ...*PaymentAccountCreate) *PaymentAccountCreateBulk {
	return &PaymentAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentAccountClient) MapCreateBulk(slice any, setFunc func(*PaymentAccountCreate, int)) *PaymentAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentAccountCreateBulk{err: fmt.Errorf("calling to PaymentAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentAccount.
func (c *PaymentAccountClient) Update() *PaymentAccountUpdate {
	mutation := newPaymentAccountMutation(c.config, OpUpdate)
	return &PaymentAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentAccountClient) UpdateOne(pa *PaymentAccount) *PaymentAccountUpdateOne {
	mutation := newPaymentAccountMutation(c.config, OpUpdateOne, withPaymentAccount(pa))
	return &PaymentAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentAccountClient) UpdateOneID(id int) *PaymentAccountUpdateOne {
	mutation := newPaymentAccountMutation(c.config, OpUpdateOne, withPaymentAccountID(id))
	return &PaymentAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentAccount.
func (c *PaymentAccountClient) Delete() *PaymentAccountDelete {
	mutation := newPaymentAccountMutation(c.config, OpDelete)
	return &PaymentAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentAccountClient) DeleteOne(pa *PaymentAccount) *PaymentAccountDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentAccountClient) DeleteOneID(id int) *PaymentAccountDeleteOne {
	builder := c.Delete().Where(paymentaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentAccountDeleteOne{builder}
}

// Query returns a query builder for PaymentAccount.
func (c *PaymentAccountClient) Query() *PaymentAccountQuery {
	return &PaymentAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentAccount entity by its id.
func (c *PaymentAccountClient) Get(ctx context.Context, id int) (*PaymentAccount, error) {
	return c.Query().Where(paymentaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentAccountClient) GetX(ctx context.Context, id int) *PaymentAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentAccountClient) Hooks() []Hook {
	return c.hooks.PaymentAccount
}

// Interceptors returns the client interceptors.
func (c *PaymentAccountClient) Interceptors() []Interceptor {
	return c.inters.PaymentAccount
}

func (c *PaymentAccountClient) mutate(ctx context.Context, m *PaymentAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaymentAccount mutation op: %q", m.Op())
	}
}

// PoiClient is a client for the Poi schema.
type PoiClient struct {
	config
}

// NewPoiClient returns a client for the Poi from the given config.
func NewPoiClient(c config) *PoiClient {
	return &PoiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `poi.Hooks(f(g(h())))`.
func (c *PoiClient) Use(hooks ...Hook) {
	c.hooks.Poi = append(c.hooks.Poi, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `poi.Intercept(f(g(h())))`.
func (c *PoiClient) Intercept(interceptors ...Interceptor) {
	c.inters.Poi = append(c.inters.Poi, interceptors...)
}

// Create returns a builder for creating a Poi entity.
func (c *PoiClient) Create() *PoiCreate {
	mutation := newPoiMutation(c.config, OpCreate)
	return &PoiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Poi entities.
func (c *PoiClient) CreateBulk(builders ...*PoiCreate) *PoiCreateBulk {
	return &PoiCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PoiClient) MapCreateBulk(slice any, setFunc func(*PoiCreate, int)) *PoiCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PoiCreateBulk{err: fmt.Errorf("calling to PoiClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PoiCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PoiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Poi.
func (c *PoiClient) Update() *PoiUpdate {
	mutation := newPoiMutation(c.config, OpUpdate)
	return &PoiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PoiClient) UpdateOne(po *Poi) *PoiUpdateOne {
	mutation := newPoiMutation(c.config, OpUpdateOne, withPoi(po))
	return &PoiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PoiClient) UpdateOneID(id int) *PoiUpdateOne {
	mutation := newPoiMutation(c.config, OpUpdateOne, withPoiID(id))
	return &PoiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Poi.
func (c *PoiClient) Delete() *PoiDelete {
	mutation := newPoiMutation(c.config, OpDelete)
	return &PoiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PoiClient) DeleteOne(po *Poi) *PoiDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PoiClient) DeleteOneID(id int) *PoiDeleteOne {
	builder := c.Delete().Where(poi.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PoiDeleteOne{builder}
}

// Query returns a query builder for Poi.
func (c *PoiClient) Query() *PoiQuery {
	return &PoiQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePoi},
		inters: c.Interceptors(),
	}
}

// Get returns a Poi entity by its id.
func (c *PoiClient) Get(ctx context.Context, id int) (*Poi, error) {
	return c.Query().Where(poi.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PoiClient) GetX(ctx context.Context, id int) *Poi {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a Poi.
func (c *PoiClient) QueryBackgroundScenicArea(po *Poi) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poi.Table, poi.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, poi.BackgroundScenicAreaTable, poi.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PoiClient) Hooks() []Hook {
	return c.hooks.Poi
}

// Interceptors returns the client interceptors.
func (c *PoiClient) Interceptors() []Interceptor {
	return c.inters.Poi
}

func (c *PoiClient) mutate(ctx context.Context, m *PoiMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PoiCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PoiUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PoiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PoiDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Poi mutation op: %q", m.Op())
	}
}

// PoiExtendYokeeClient is a client for the PoiExtendYokee schema.
type PoiExtendYokeeClient struct {
	config
}

// NewPoiExtendYokeeClient returns a client for the PoiExtendYokee from the given config.
func NewPoiExtendYokeeClient(c config) *PoiExtendYokeeClient {
	return &PoiExtendYokeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `poiextendyokee.Hooks(f(g(h())))`.
func (c *PoiExtendYokeeClient) Use(hooks ...Hook) {
	c.hooks.PoiExtendYokee = append(c.hooks.PoiExtendYokee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `poiextendyokee.Intercept(f(g(h())))`.
func (c *PoiExtendYokeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PoiExtendYokee = append(c.inters.PoiExtendYokee, interceptors...)
}

// Create returns a builder for creating a PoiExtendYokee entity.
func (c *PoiExtendYokeeClient) Create() *PoiExtendYokeeCreate {
	mutation := newPoiExtendYokeeMutation(c.config, OpCreate)
	return &PoiExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PoiExtendYokee entities.
func (c *PoiExtendYokeeClient) CreateBulk(builders ...*PoiExtendYokeeCreate) *PoiExtendYokeeCreateBulk {
	return &PoiExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PoiExtendYokeeClient) MapCreateBulk(slice any, setFunc func(*PoiExtendYokeeCreate, int)) *PoiExtendYokeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PoiExtendYokeeCreateBulk{err: fmt.Errorf("calling to PoiExtendYokeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PoiExtendYokeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PoiExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PoiExtendYokee.
func (c *PoiExtendYokeeClient) Update() *PoiExtendYokeeUpdate {
	mutation := newPoiExtendYokeeMutation(c.config, OpUpdate)
	return &PoiExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PoiExtendYokeeClient) UpdateOne(pey *PoiExtendYokee) *PoiExtendYokeeUpdateOne {
	mutation := newPoiExtendYokeeMutation(c.config, OpUpdateOne, withPoiExtendYokee(pey))
	return &PoiExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PoiExtendYokeeClient) UpdateOneID(id int) *PoiExtendYokeeUpdateOne {
	mutation := newPoiExtendYokeeMutation(c.config, OpUpdateOne, withPoiExtendYokeeID(id))
	return &PoiExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PoiExtendYokee.
func (c *PoiExtendYokeeClient) Delete() *PoiExtendYokeeDelete {
	mutation := newPoiExtendYokeeMutation(c.config, OpDelete)
	return &PoiExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PoiExtendYokeeClient) DeleteOne(pey *PoiExtendYokee) *PoiExtendYokeeDeleteOne {
	return c.DeleteOneID(pey.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PoiExtendYokeeClient) DeleteOneID(id int) *PoiExtendYokeeDeleteOne {
	builder := c.Delete().Where(poiextendyokee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PoiExtendYokeeDeleteOne{builder}
}

// Query returns a query builder for PoiExtendYokee.
func (c *PoiExtendYokeeClient) Query() *PoiExtendYokeeQuery {
	return &PoiExtendYokeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePoiExtendYokee},
		inters: c.Interceptors(),
	}
}

// Get returns a PoiExtendYokee entity by its id.
func (c *PoiExtendYokeeClient) Get(ctx context.Context, id int) (*PoiExtendYokee, error) {
	return c.Query().Where(poiextendyokee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PoiExtendYokeeClient) GetX(ctx context.Context, id int) *PoiExtendYokee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PoiExtendYokeeClient) Hooks() []Hook {
	return c.hooks.PoiExtendYokee
}

// Interceptors returns the client interceptors.
func (c *PoiExtendYokeeClient) Interceptors() []Interceptor {
	return c.inters.PoiExtendYokee
}

func (c *PoiExtendYokeeClient) mutate(ctx context.Context, m *PoiExtendYokeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PoiExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PoiExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PoiExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PoiExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PoiExtendYokee mutation op: %q", m.Op())
	}
}

// ProfitReceiverClient is a client for the ProfitReceiver schema.
type ProfitReceiverClient struct {
	config
}

// NewProfitReceiverClient returns a client for the ProfitReceiver from the given config.
func NewProfitReceiverClient(c config) *ProfitReceiverClient {
	return &ProfitReceiverClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profitreceiver.Hooks(f(g(h())))`.
func (c *ProfitReceiverClient) Use(hooks ...Hook) {
	c.hooks.ProfitReceiver = append(c.hooks.ProfitReceiver, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profitreceiver.Intercept(f(g(h())))`.
func (c *ProfitReceiverClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfitReceiver = append(c.inters.ProfitReceiver, interceptors...)
}

// Create returns a builder for creating a ProfitReceiver entity.
func (c *ProfitReceiverClient) Create() *ProfitReceiverCreate {
	mutation := newProfitReceiverMutation(c.config, OpCreate)
	return &ProfitReceiverCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfitReceiver entities.
func (c *ProfitReceiverClient) CreateBulk(builders ...*ProfitReceiverCreate) *ProfitReceiverCreateBulk {
	return &ProfitReceiverCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfitReceiverClient) MapCreateBulk(slice any, setFunc func(*ProfitReceiverCreate, int)) *ProfitReceiverCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfitReceiverCreateBulk{err: fmt.Errorf("calling to ProfitReceiverClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfitReceiverCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfitReceiverCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfitReceiver.
func (c *ProfitReceiverClient) Update() *ProfitReceiverUpdate {
	mutation := newProfitReceiverMutation(c.config, OpUpdate)
	return &ProfitReceiverUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfitReceiverClient) UpdateOne(pr *ProfitReceiver) *ProfitReceiverUpdateOne {
	mutation := newProfitReceiverMutation(c.config, OpUpdateOne, withProfitReceiver(pr))
	return &ProfitReceiverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfitReceiverClient) UpdateOneID(id int) *ProfitReceiverUpdateOne {
	mutation := newProfitReceiverMutation(c.config, OpUpdateOne, withProfitReceiverID(id))
	return &ProfitReceiverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfitReceiver.
func (c *ProfitReceiverClient) Delete() *ProfitReceiverDelete {
	mutation := newProfitReceiverMutation(c.config, OpDelete)
	return &ProfitReceiverDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfitReceiverClient) DeleteOne(pr *ProfitReceiver) *ProfitReceiverDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfitReceiverClient) DeleteOneID(id int) *ProfitReceiverDeleteOne {
	builder := c.Delete().Where(profitreceiver.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfitReceiverDeleteOne{builder}
}

// Query returns a query builder for ProfitReceiver.
func (c *ProfitReceiverClient) Query() *ProfitReceiverQuery {
	return &ProfitReceiverQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfitReceiver},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfitReceiver entity by its id.
func (c *ProfitReceiverClient) Get(ctx context.Context, id int) (*ProfitReceiver, error) {
	return c.Query().Where(profitreceiver.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfitReceiverClient) GetX(ctx context.Context, id int) *ProfitReceiver {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a ProfitReceiver.
func (c *ProfitReceiverClient) QueryBackgroundScenicArea(pr *ProfitReceiver) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profitreceiver.Table, profitreceiver.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profitreceiver.BackgroundScenicAreaTable, profitreceiver.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfitReceiverClient) Hooks() []Hook {
	return c.hooks.ProfitReceiver
}

// Interceptors returns the client interceptors.
func (c *ProfitReceiverClient) Interceptors() []Interceptor {
	return c.inters.ProfitReceiver
}

func (c *ProfitReceiverClient) mutate(ctx context.Context, m *ProfitReceiverMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfitReceiverCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfitReceiverUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfitReceiverUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfitReceiverDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProfitReceiver mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// RouteClient is a client for the Route schema.
type RouteClient struct {
	config
}

// NewRouteClient returns a client for the Route from the given config.
func NewRouteClient(c config) *RouteClient {
	return &RouteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `route.Hooks(f(g(h())))`.
func (c *RouteClient) Use(hooks ...Hook) {
	c.hooks.Route = append(c.hooks.Route, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `route.Intercept(f(g(h())))`.
func (c *RouteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Route = append(c.inters.Route, interceptors...)
}

// Create returns a builder for creating a Route entity.
func (c *RouteClient) Create() *RouteCreate {
	mutation := newRouteMutation(c.config, OpCreate)
	return &RouteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Route entities.
func (c *RouteClient) CreateBulk(builders ...*RouteCreate) *RouteCreateBulk {
	return &RouteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RouteClient) MapCreateBulk(slice any, setFunc func(*RouteCreate, int)) *RouteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RouteCreateBulk{err: fmt.Errorf("calling to RouteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RouteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RouteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Route.
func (c *RouteClient) Update() *RouteUpdate {
	mutation := newRouteMutation(c.config, OpUpdate)
	return &RouteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouteClient) UpdateOne(r *Route) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRoute(r))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouteClient) UpdateOneID(id int) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRouteID(id))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Route.
func (c *RouteClient) Delete() *RouteDelete {
	mutation := newRouteMutation(c.config, OpDelete)
	return &RouteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RouteClient) DeleteOne(r *Route) *RouteDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RouteClient) DeleteOneID(id int) *RouteDeleteOne {
	builder := c.Delete().Where(route.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouteDeleteOne{builder}
}

// Query returns a query builder for Route.
func (c *RouteClient) Query() *RouteQuery {
	return &RouteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoute},
		inters: c.Interceptors(),
	}
}

// Get returns a Route entity by its id.
func (c *RouteClient) Get(ctx context.Context, id int) (*Route, error) {
	return c.Query().Where(route.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouteClient) GetX(ctx context.Context, id int) *Route {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RouteClient) Hooks() []Hook {
	hooks := c.hooks.Route
	return append(hooks[:len(hooks):len(hooks)], route.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RouteClient) Interceptors() []Interceptor {
	inters := c.inters.Route
	return append(inters[:len(inters):len(inters)], route.Interceptors[:]...)
}

func (c *RouteClient) mutate(ctx context.Context, m *RouteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RouteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RouteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RouteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Route mutation op: %q", m.Op())
	}
}

// ScenicAreaClient is a client for the ScenicArea schema.
type ScenicAreaClient struct {
	config
}

// NewScenicAreaClient returns a client for the ScenicArea from the given config.
func NewScenicAreaClient(c config) *ScenicAreaClient {
	return &ScenicAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenicarea.Hooks(f(g(h())))`.
func (c *ScenicAreaClient) Use(hooks ...Hook) {
	c.hooks.ScenicArea = append(c.hooks.ScenicArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenicarea.Intercept(f(g(h())))`.
func (c *ScenicAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenicArea = append(c.inters.ScenicArea, interceptors...)
}

// Create returns a builder for creating a ScenicArea entity.
func (c *ScenicAreaClient) Create() *ScenicAreaCreate {
	mutation := newScenicAreaMutation(c.config, OpCreate)
	return &ScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenicArea entities.
func (c *ScenicAreaClient) CreateBulk(builders ...*ScenicAreaCreate) *ScenicAreaCreateBulk {
	return &ScenicAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenicAreaClient) MapCreateBulk(slice any, setFunc func(*ScenicAreaCreate, int)) *ScenicAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenicAreaCreateBulk{err: fmt.Errorf("calling to ScenicAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenicAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenicAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenicArea.
func (c *ScenicAreaClient) Update() *ScenicAreaUpdate {
	mutation := newScenicAreaMutation(c.config, OpUpdate)
	return &ScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenicAreaClient) UpdateOne(sa *ScenicArea) *ScenicAreaUpdateOne {
	mutation := newScenicAreaMutation(c.config, OpUpdateOne, withScenicArea(sa))
	return &ScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenicAreaClient) UpdateOneID(id int) *ScenicAreaUpdateOne {
	mutation := newScenicAreaMutation(c.config, OpUpdateOne, withScenicAreaID(id))
	return &ScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenicArea.
func (c *ScenicAreaClient) Delete() *ScenicAreaDelete {
	mutation := newScenicAreaMutation(c.config, OpDelete)
	return &ScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenicAreaClient) DeleteOne(sa *ScenicArea) *ScenicAreaDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenicAreaClient) DeleteOneID(id int) *ScenicAreaDeleteOne {
	builder := c.Delete().Where(scenicarea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenicAreaDeleteOne{builder}
}

// Query returns a query builder for ScenicArea.
func (c *ScenicAreaClient) Query() *ScenicAreaQuery {
	return &ScenicAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenicArea},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenicArea entity by its id.
func (c *ScenicAreaClient) Get(ctx context.Context, id int) (*ScenicArea, error) {
	return c.Query().Where(scenicarea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenicAreaClient) GetX(ctx context.Context, id int) *ScenicArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCars queries the cars edge of a ScenicArea.
func (c *ScenicAreaClient) QueryCars(sa *ScenicArea) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.CarsTable, scenicarea.CarsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccounts queries the accounts edge of a ScenicArea.
func (c *ScenicAreaClient) QueryAccounts(sa *ScenicArea) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.AccountsTable, scenicarea.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPois queries the pois edge of a ScenicArea.
func (c *ScenicAreaClient) QueryPois(sa *ScenicArea) *PoiQuery {
	query := (&PoiClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(poi.Table, poi.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.PoisTable, scenicarea.PoisColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfitReceivers queries the profit_receivers edge of a ScenicArea.
func (c *ScenicAreaClient) QueryProfitReceivers(sa *ScenicArea) *ProfitReceiverQuery {
	query := (&ProfitReceiverClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(profitreceiver.Table, profitreceiver.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.ProfitReceiversTable, scenicarea.ProfitReceiversColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayTxBills queries the pay_tx_bills edge of a ScenicArea.
func (c *ScenicAreaClient) QueryPayTxBills(sa *ScenicArea) *PayTxBillQuery {
	query := (&PayTxBillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(paytxbill.Table, paytxbill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.PayTxBillsTable, scenicarea.PayTxBillsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarBillingStrategies queries the car_billing_strategies edge of a ScenicArea.
func (c *ScenicAreaClient) QueryCarBillingStrategies(sa *ScenicArea) *BillingStrategyQuery {
	query := (&BillingStrategyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(billingstrategy.Table, billingstrategy.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.CarBillingStrategiesTable, scenicarea.CarBillingStrategiesColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMap queries the map edge of a ScenicArea.
func (c *ScenicAreaClient) QueryMap(sa *ScenicArea) *ScenicAreaMapQuery {
	query := (&ScenicAreaMapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(scenicareamap.Table, scenicareamap.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, scenicarea.MapTable, scenicarea.MapColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMapVersions queries the map_versions edge of a ScenicArea.
func (c *ScenicAreaClient) QueryMapVersions(sa *ScenicArea) *MapVersionQuery {
	query := (&MapVersionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(mapversion.Table, mapversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.MapVersionsTable, scenicarea.MapVersionsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a ScenicArea.
func (c *ScenicAreaClient) QueryUsers(sa *ScenicArea) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.UsersTable, scenicarea.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrders queries the orders edge of a ScenicArea.
func (c *ScenicAreaClient) QueryOrders(sa *ScenicArea) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.OrdersTable, scenicarea.OrdersColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCarOperateLogs queries the car_operate_logs edge of a ScenicArea.
func (c *ScenicAreaClient) QueryCarOperateLogs(sa *ScenicArea) *CarsOperateLogQuery {
	query := (&CarsOperateLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(carsoperatelog.Table, carsoperatelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.CarOperateLogsTable, scenicarea.CarOperateLogsColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatsHourlyCar queries the stats_hourly_car edge of a ScenicArea.
func (c *ScenicAreaClient) QueryStatsHourlyCar(sa *ScenicArea) *StatsHourlyCarQuery {
	query := (&StatsHourlyCarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(statshourlycar.Table, statshourlycar.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.StatsHourlyCarTable, scenicarea.StatsHourlyCarColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConfigFiles queries the config_files edge of a ScenicArea.
func (c *ScenicAreaClient) QueryConfigFiles(sa *ScenicArea) *CarConfigQuery {
	query := (&CarConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicarea.Table, scenicarea.FieldID, id),
			sqlgraph.To(carconfig.Table, carconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, scenicarea.ConfigFilesTable, scenicarea.ConfigFilesColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenicAreaClient) Hooks() []Hook {
	return c.hooks.ScenicArea
}

// Interceptors returns the client interceptors.
func (c *ScenicAreaClient) Interceptors() []Interceptor {
	return c.inters.ScenicArea
}

func (c *ScenicAreaClient) mutate(ctx context.Context, m *ScenicAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenicArea mutation op: %q", m.Op())
	}
}

// ScenicAreaExtendYokeeClient is a client for the ScenicAreaExtendYokee schema.
type ScenicAreaExtendYokeeClient struct {
	config
}

// NewScenicAreaExtendYokeeClient returns a client for the ScenicAreaExtendYokee from the given config.
func NewScenicAreaExtendYokeeClient(c config) *ScenicAreaExtendYokeeClient {
	return &ScenicAreaExtendYokeeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenicareaextendyokee.Hooks(f(g(h())))`.
func (c *ScenicAreaExtendYokeeClient) Use(hooks ...Hook) {
	c.hooks.ScenicAreaExtendYokee = append(c.hooks.ScenicAreaExtendYokee, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenicareaextendyokee.Intercept(f(g(h())))`.
func (c *ScenicAreaExtendYokeeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenicAreaExtendYokee = append(c.inters.ScenicAreaExtendYokee, interceptors...)
}

// Create returns a builder for creating a ScenicAreaExtendYokee entity.
func (c *ScenicAreaExtendYokeeClient) Create() *ScenicAreaExtendYokeeCreate {
	mutation := newScenicAreaExtendYokeeMutation(c.config, OpCreate)
	return &ScenicAreaExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenicAreaExtendYokee entities.
func (c *ScenicAreaExtendYokeeClient) CreateBulk(builders ...*ScenicAreaExtendYokeeCreate) *ScenicAreaExtendYokeeCreateBulk {
	return &ScenicAreaExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenicAreaExtendYokeeClient) MapCreateBulk(slice any, setFunc func(*ScenicAreaExtendYokeeCreate, int)) *ScenicAreaExtendYokeeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenicAreaExtendYokeeCreateBulk{err: fmt.Errorf("calling to ScenicAreaExtendYokeeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenicAreaExtendYokeeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenicAreaExtendYokeeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenicAreaExtendYokee.
func (c *ScenicAreaExtendYokeeClient) Update() *ScenicAreaExtendYokeeUpdate {
	mutation := newScenicAreaExtendYokeeMutation(c.config, OpUpdate)
	return &ScenicAreaExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenicAreaExtendYokeeClient) UpdateOne(saey *ScenicAreaExtendYokee) *ScenicAreaExtendYokeeUpdateOne {
	mutation := newScenicAreaExtendYokeeMutation(c.config, OpUpdateOne, withScenicAreaExtendYokee(saey))
	return &ScenicAreaExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenicAreaExtendYokeeClient) UpdateOneID(id int) *ScenicAreaExtendYokeeUpdateOne {
	mutation := newScenicAreaExtendYokeeMutation(c.config, OpUpdateOne, withScenicAreaExtendYokeeID(id))
	return &ScenicAreaExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenicAreaExtendYokee.
func (c *ScenicAreaExtendYokeeClient) Delete() *ScenicAreaExtendYokeeDelete {
	mutation := newScenicAreaExtendYokeeMutation(c.config, OpDelete)
	return &ScenicAreaExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenicAreaExtendYokeeClient) DeleteOne(saey *ScenicAreaExtendYokee) *ScenicAreaExtendYokeeDeleteOne {
	return c.DeleteOneID(saey.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenicAreaExtendYokeeClient) DeleteOneID(id int) *ScenicAreaExtendYokeeDeleteOne {
	builder := c.Delete().Where(scenicareaextendyokee.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenicAreaExtendYokeeDeleteOne{builder}
}

// Query returns a query builder for ScenicAreaExtendYokee.
func (c *ScenicAreaExtendYokeeClient) Query() *ScenicAreaExtendYokeeQuery {
	return &ScenicAreaExtendYokeeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenicAreaExtendYokee},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenicAreaExtendYokee entity by its id.
func (c *ScenicAreaExtendYokeeClient) Get(ctx context.Context, id int) (*ScenicAreaExtendYokee, error) {
	return c.Query().Where(scenicareaextendyokee.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenicAreaExtendYokeeClient) GetX(ctx context.Context, id int) *ScenicAreaExtendYokee {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ScenicAreaExtendYokeeClient) Hooks() []Hook {
	return c.hooks.ScenicAreaExtendYokee
}

// Interceptors returns the client interceptors.
func (c *ScenicAreaExtendYokeeClient) Interceptors() []Interceptor {
	return c.inters.ScenicAreaExtendYokee
}

func (c *ScenicAreaExtendYokeeClient) mutate(ctx context.Context, m *ScenicAreaExtendYokeeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenicAreaExtendYokeeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenicAreaExtendYokeeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenicAreaExtendYokeeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenicAreaExtendYokeeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenicAreaExtendYokee mutation op: %q", m.Op())
	}
}

// ScenicAreaMapClient is a client for the ScenicAreaMap schema.
type ScenicAreaMapClient struct {
	config
}

// NewScenicAreaMapClient returns a client for the ScenicAreaMap from the given config.
func NewScenicAreaMapClient(c config) *ScenicAreaMapClient {
	return &ScenicAreaMapClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scenicareamap.Hooks(f(g(h())))`.
func (c *ScenicAreaMapClient) Use(hooks ...Hook) {
	c.hooks.ScenicAreaMap = append(c.hooks.ScenicAreaMap, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scenicareamap.Intercept(f(g(h())))`.
func (c *ScenicAreaMapClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScenicAreaMap = append(c.inters.ScenicAreaMap, interceptors...)
}

// Create returns a builder for creating a ScenicAreaMap entity.
func (c *ScenicAreaMapClient) Create() *ScenicAreaMapCreate {
	mutation := newScenicAreaMapMutation(c.config, OpCreate)
	return &ScenicAreaMapCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScenicAreaMap entities.
func (c *ScenicAreaMapClient) CreateBulk(builders ...*ScenicAreaMapCreate) *ScenicAreaMapCreateBulk {
	return &ScenicAreaMapCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScenicAreaMapClient) MapCreateBulk(slice any, setFunc func(*ScenicAreaMapCreate, int)) *ScenicAreaMapCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScenicAreaMapCreateBulk{err: fmt.Errorf("calling to ScenicAreaMapClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScenicAreaMapCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScenicAreaMapCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScenicAreaMap.
func (c *ScenicAreaMapClient) Update() *ScenicAreaMapUpdate {
	mutation := newScenicAreaMapMutation(c.config, OpUpdate)
	return &ScenicAreaMapUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScenicAreaMapClient) UpdateOne(sam *ScenicAreaMap) *ScenicAreaMapUpdateOne {
	mutation := newScenicAreaMapMutation(c.config, OpUpdateOne, withScenicAreaMap(sam))
	return &ScenicAreaMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScenicAreaMapClient) UpdateOneID(id int) *ScenicAreaMapUpdateOne {
	mutation := newScenicAreaMapMutation(c.config, OpUpdateOne, withScenicAreaMapID(id))
	return &ScenicAreaMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScenicAreaMap.
func (c *ScenicAreaMapClient) Delete() *ScenicAreaMapDelete {
	mutation := newScenicAreaMapMutation(c.config, OpDelete)
	return &ScenicAreaMapDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScenicAreaMapClient) DeleteOne(sam *ScenicAreaMap) *ScenicAreaMapDeleteOne {
	return c.DeleteOneID(sam.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScenicAreaMapClient) DeleteOneID(id int) *ScenicAreaMapDeleteOne {
	builder := c.Delete().Where(scenicareamap.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScenicAreaMapDeleteOne{builder}
}

// Query returns a query builder for ScenicAreaMap.
func (c *ScenicAreaMapClient) Query() *ScenicAreaMapQuery {
	return &ScenicAreaMapQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScenicAreaMap},
		inters: c.Interceptors(),
	}
}

// Get returns a ScenicAreaMap entity by its id.
func (c *ScenicAreaMapClient) Get(ctx context.Context, id int) (*ScenicAreaMap, error) {
	return c.Query().Where(scenicareamap.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScenicAreaMapClient) GetX(ctx context.Context, id int) *ScenicAreaMap {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a ScenicAreaMap.
func (c *ScenicAreaMapClient) QueryBackgroundScenicArea(sam *ScenicAreaMap) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sam.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scenicareamap.Table, scenicareamap.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, scenicareamap.BackgroundScenicAreaTable, scenicareamap.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(sam.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScenicAreaMapClient) Hooks() []Hook {
	return c.hooks.ScenicAreaMap
}

// Interceptors returns the client interceptors.
func (c *ScenicAreaMapClient) Interceptors() []Interceptor {
	return c.inters.ScenicAreaMap
}

func (c *ScenicAreaMapClient) mutate(ctx context.Context, m *ScenicAreaMapMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScenicAreaMapCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScenicAreaMapUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScenicAreaMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScenicAreaMapDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScenicAreaMap mutation op: %q", m.Op())
	}
}

// ScheTaskClient is a client for the ScheTask schema.
type ScheTaskClient struct {
	config
}

// NewScheTaskClient returns a client for the ScheTask from the given config.
func NewScheTaskClient(c config) *ScheTaskClient {
	return &ScheTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schetask.Hooks(f(g(h())))`.
func (c *ScheTaskClient) Use(hooks ...Hook) {
	c.hooks.ScheTask = append(c.hooks.ScheTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schetask.Intercept(f(g(h())))`.
func (c *ScheTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheTask = append(c.inters.ScheTask, interceptors...)
}

// Create returns a builder for creating a ScheTask entity.
func (c *ScheTaskClient) Create() *ScheTaskCreate {
	mutation := newScheTaskMutation(c.config, OpCreate)
	return &ScheTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheTask entities.
func (c *ScheTaskClient) CreateBulk(builders ...*ScheTaskCreate) *ScheTaskCreateBulk {
	return &ScheTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheTaskClient) MapCreateBulk(slice any, setFunc func(*ScheTaskCreate, int)) *ScheTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheTaskCreateBulk{err: fmt.Errorf("calling to ScheTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheTask.
func (c *ScheTaskClient) Update() *ScheTaskUpdate {
	mutation := newScheTaskMutation(c.config, OpUpdate)
	return &ScheTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheTaskClient) UpdateOne(st *ScheTask) *ScheTaskUpdateOne {
	mutation := newScheTaskMutation(c.config, OpUpdateOne, withScheTask(st))
	return &ScheTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheTaskClient) UpdateOneID(id int) *ScheTaskUpdateOne {
	mutation := newScheTaskMutation(c.config, OpUpdateOne, withScheTaskID(id))
	return &ScheTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheTask.
func (c *ScheTaskClient) Delete() *ScheTaskDelete {
	mutation := newScheTaskMutation(c.config, OpDelete)
	return &ScheTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheTaskClient) DeleteOne(st *ScheTask) *ScheTaskDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheTaskClient) DeleteOneID(id int) *ScheTaskDeleteOne {
	builder := c.Delete().Where(schetask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheTaskDeleteOne{builder}
}

// Query returns a query builder for ScheTask.
func (c *ScheTaskClient) Query() *ScheTaskQuery {
	return &ScheTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheTask},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheTask entity by its id.
func (c *ScheTaskClient) Get(ctx context.Context, id int) (*ScheTask, error) {
	return c.Query().Where(schetask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheTaskClient) GetX(ctx context.Context, id int) *ScheTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a ScheTask.
func (c *ScheTaskClient) QueryCar(st *ScheTask) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schetask.Table, schetask.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, schetask.CarTable, schetask.CarColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a ScheTask.
func (c *ScheTaskClient) QueryEvents(st *ScheTask) *ScheTaskEventQuery {
	query := (&ScheTaskEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schetask.Table, schetask.FieldID, id),
			sqlgraph.To(schetaskevent.Table, schetaskevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, schetask.EventsTable, schetask.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheTaskClient) Hooks() []Hook {
	return c.hooks.ScheTask
}

// Interceptors returns the client interceptors.
func (c *ScheTaskClient) Interceptors() []Interceptor {
	return c.inters.ScheTask
}

func (c *ScheTaskClient) mutate(ctx context.Context, m *ScheTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheTask mutation op: %q", m.Op())
	}
}

// ScheTaskEventClient is a client for the ScheTaskEvent schema.
type ScheTaskEventClient struct {
	config
}

// NewScheTaskEventClient returns a client for the ScheTaskEvent from the given config.
func NewScheTaskEventClient(c config) *ScheTaskEventClient {
	return &ScheTaskEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schetaskevent.Hooks(f(g(h())))`.
func (c *ScheTaskEventClient) Use(hooks ...Hook) {
	c.hooks.ScheTaskEvent = append(c.hooks.ScheTaskEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `schetaskevent.Intercept(f(g(h())))`.
func (c *ScheTaskEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheTaskEvent = append(c.inters.ScheTaskEvent, interceptors...)
}

// Create returns a builder for creating a ScheTaskEvent entity.
func (c *ScheTaskEventClient) Create() *ScheTaskEventCreate {
	mutation := newScheTaskEventMutation(c.config, OpCreate)
	return &ScheTaskEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheTaskEvent entities.
func (c *ScheTaskEventClient) CreateBulk(builders ...*ScheTaskEventCreate) *ScheTaskEventCreateBulk {
	return &ScheTaskEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheTaskEventClient) MapCreateBulk(slice any, setFunc func(*ScheTaskEventCreate, int)) *ScheTaskEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheTaskEventCreateBulk{err: fmt.Errorf("calling to ScheTaskEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheTaskEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheTaskEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheTaskEvent.
func (c *ScheTaskEventClient) Update() *ScheTaskEventUpdate {
	mutation := newScheTaskEventMutation(c.config, OpUpdate)
	return &ScheTaskEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheTaskEventClient) UpdateOne(ste *ScheTaskEvent) *ScheTaskEventUpdateOne {
	mutation := newScheTaskEventMutation(c.config, OpUpdateOne, withScheTaskEvent(ste))
	return &ScheTaskEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheTaskEventClient) UpdateOneID(id int) *ScheTaskEventUpdateOne {
	mutation := newScheTaskEventMutation(c.config, OpUpdateOne, withScheTaskEventID(id))
	return &ScheTaskEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheTaskEvent.
func (c *ScheTaskEventClient) Delete() *ScheTaskEventDelete {
	mutation := newScheTaskEventMutation(c.config, OpDelete)
	return &ScheTaskEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheTaskEventClient) DeleteOne(ste *ScheTaskEvent) *ScheTaskEventDeleteOne {
	return c.DeleteOneID(ste.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheTaskEventClient) DeleteOneID(id int) *ScheTaskEventDeleteOne {
	builder := c.Delete().Where(schetaskevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheTaskEventDeleteOne{builder}
}

// Query returns a query builder for ScheTaskEvent.
func (c *ScheTaskEventClient) Query() *ScheTaskEventQuery {
	return &ScheTaskEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheTaskEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheTaskEvent entity by its id.
func (c *ScheTaskEventClient) Get(ctx context.Context, id int) (*ScheTaskEvent, error) {
	return c.Query().Where(schetaskevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheTaskEventClient) GetX(ctx context.Context, id int) *ScheTaskEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScheTask queries the sche_task edge of a ScheTaskEvent.
func (c *ScheTaskEventClient) QueryScheTask(ste *ScheTaskEvent) *ScheTaskQuery {
	query := (&ScheTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ste.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schetaskevent.Table, schetaskevent.FieldID, id),
			sqlgraph.To(schetask.Table, schetask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, schetaskevent.ScheTaskTable, schetaskevent.ScheTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ste.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheTaskEventClient) Hooks() []Hook {
	return c.hooks.ScheTaskEvent
}

// Interceptors returns the client interceptors.
func (c *ScheTaskEventClient) Interceptors() []Interceptor {
	return c.inters.ScheTaskEvent
}

func (c *ScheTaskEventClient) mutate(ctx context.Context, m *ScheTaskEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheTaskEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheTaskEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheTaskEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheTaskEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheTaskEvent mutation op: %q", m.Op())
	}
}

// SshAccountClient is a client for the SshAccount schema.
type SshAccountClient struct {
	config
}

// NewSshAccountClient returns a client for the SshAccount from the given config.
func NewSshAccountClient(c config) *SshAccountClient {
	return &SshAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sshaccount.Hooks(f(g(h())))`.
func (c *SshAccountClient) Use(hooks ...Hook) {
	c.hooks.SshAccount = append(c.hooks.SshAccount, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sshaccount.Intercept(f(g(h())))`.
func (c *SshAccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.SshAccount = append(c.inters.SshAccount, interceptors...)
}

// Create returns a builder for creating a SshAccount entity.
func (c *SshAccountClient) Create() *SshAccountCreate {
	mutation := newSshAccountMutation(c.config, OpCreate)
	return &SshAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SshAccount entities.
func (c *SshAccountClient) CreateBulk(builders ...*SshAccountCreate) *SshAccountCreateBulk {
	return &SshAccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SshAccountClient) MapCreateBulk(slice any, setFunc func(*SshAccountCreate, int)) *SshAccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SshAccountCreateBulk{err: fmt.Errorf("calling to SshAccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SshAccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SshAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SshAccount.
func (c *SshAccountClient) Update() *SshAccountUpdate {
	mutation := newSshAccountMutation(c.config, OpUpdate)
	return &SshAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SshAccountClient) UpdateOne(sa *SshAccount) *SshAccountUpdateOne {
	mutation := newSshAccountMutation(c.config, OpUpdateOne, withSshAccount(sa))
	return &SshAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SshAccountClient) UpdateOneID(id int) *SshAccountUpdateOne {
	mutation := newSshAccountMutation(c.config, OpUpdateOne, withSshAccountID(id))
	return &SshAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SshAccount.
func (c *SshAccountClient) Delete() *SshAccountDelete {
	mutation := newSshAccountMutation(c.config, OpDelete)
	return &SshAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SshAccountClient) DeleteOne(sa *SshAccount) *SshAccountDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SshAccountClient) DeleteOneID(id int) *SshAccountDeleteOne {
	builder := c.Delete().Where(sshaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SshAccountDeleteOne{builder}
}

// Query returns a query builder for SshAccount.
func (c *SshAccountClient) Query() *SshAccountQuery {
	return &SshAccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSshAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a SshAccount entity by its id.
func (c *SshAccountClient) Get(ctx context.Context, id int) (*SshAccount, error) {
	return c.Query().Where(sshaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SshAccountClient) GetX(ctx context.Context, id int) *SshAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SshAccountClient) Hooks() []Hook {
	hooks := c.hooks.SshAccount
	return append(hooks[:len(hooks):len(hooks)], sshaccount.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SshAccountClient) Interceptors() []Interceptor {
	inters := c.inters.SshAccount
	return append(inters[:len(inters):len(inters)], sshaccount.Interceptors[:]...)
}

func (c *SshAccountClient) mutate(ctx context.Context, m *SshAccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SshAccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SshAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SshAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SshAccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SshAccount mutation op: %q", m.Op())
	}
}

// StatsDailyClient is a client for the StatsDaily schema.
type StatsDailyClient struct {
	config
}

// NewStatsDailyClient returns a client for the StatsDaily from the given config.
func NewStatsDailyClient(c config) *StatsDailyClient {
	return &StatsDailyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statsdaily.Hooks(f(g(h())))`.
func (c *StatsDailyClient) Use(hooks ...Hook) {
	c.hooks.StatsDaily = append(c.hooks.StatsDaily, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statsdaily.Intercept(f(g(h())))`.
func (c *StatsDailyClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatsDaily = append(c.inters.StatsDaily, interceptors...)
}

// Create returns a builder for creating a StatsDaily entity.
func (c *StatsDailyClient) Create() *StatsDailyCreate {
	mutation := newStatsDailyMutation(c.config, OpCreate)
	return &StatsDailyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatsDaily entities.
func (c *StatsDailyClient) CreateBulk(builders ...*StatsDailyCreate) *StatsDailyCreateBulk {
	return &StatsDailyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatsDailyClient) MapCreateBulk(slice any, setFunc func(*StatsDailyCreate, int)) *StatsDailyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatsDailyCreateBulk{err: fmt.Errorf("calling to StatsDailyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatsDailyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatsDailyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatsDaily.
func (c *StatsDailyClient) Update() *StatsDailyUpdate {
	mutation := newStatsDailyMutation(c.config, OpUpdate)
	return &StatsDailyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatsDailyClient) UpdateOne(sd *StatsDaily) *StatsDailyUpdateOne {
	mutation := newStatsDailyMutation(c.config, OpUpdateOne, withStatsDaily(sd))
	return &StatsDailyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatsDailyClient) UpdateOneID(id int) *StatsDailyUpdateOne {
	mutation := newStatsDailyMutation(c.config, OpUpdateOne, withStatsDailyID(id))
	return &StatsDailyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatsDaily.
func (c *StatsDailyClient) Delete() *StatsDailyDelete {
	mutation := newStatsDailyMutation(c.config, OpDelete)
	return &StatsDailyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatsDailyClient) DeleteOne(sd *StatsDaily) *StatsDailyDeleteOne {
	return c.DeleteOneID(sd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatsDailyClient) DeleteOneID(id int) *StatsDailyDeleteOne {
	builder := c.Delete().Where(statsdaily.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatsDailyDeleteOne{builder}
}

// Query returns a query builder for StatsDaily.
func (c *StatsDailyClient) Query() *StatsDailyQuery {
	return &StatsDailyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatsDaily},
		inters: c.Interceptors(),
	}
}

// Get returns a StatsDaily entity by its id.
func (c *StatsDailyClient) Get(ctx context.Context, id int) (*StatsDaily, error) {
	return c.Query().Where(statsdaily.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatsDailyClient) GetX(ctx context.Context, id int) *StatsDaily {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatsDailyClient) Hooks() []Hook {
	return c.hooks.StatsDaily
}

// Interceptors returns the client interceptors.
func (c *StatsDailyClient) Interceptors() []Interceptor {
	return c.inters.StatsDaily
}

func (c *StatsDailyClient) mutate(ctx context.Context, m *StatsDailyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatsDailyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatsDailyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatsDailyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatsDailyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatsDaily mutation op: %q", m.Op())
	}
}

// StatsDailyCarClient is a client for the StatsDailyCar schema.
type StatsDailyCarClient struct {
	config
}

// NewStatsDailyCarClient returns a client for the StatsDailyCar from the given config.
func NewStatsDailyCarClient(c config) *StatsDailyCarClient {
	return &StatsDailyCarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statsdailycar.Hooks(f(g(h())))`.
func (c *StatsDailyCarClient) Use(hooks ...Hook) {
	c.hooks.StatsDailyCar = append(c.hooks.StatsDailyCar, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statsdailycar.Intercept(f(g(h())))`.
func (c *StatsDailyCarClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatsDailyCar = append(c.inters.StatsDailyCar, interceptors...)
}

// Create returns a builder for creating a StatsDailyCar entity.
func (c *StatsDailyCarClient) Create() *StatsDailyCarCreate {
	mutation := newStatsDailyCarMutation(c.config, OpCreate)
	return &StatsDailyCarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatsDailyCar entities.
func (c *StatsDailyCarClient) CreateBulk(builders ...*StatsDailyCarCreate) *StatsDailyCarCreateBulk {
	return &StatsDailyCarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatsDailyCarClient) MapCreateBulk(slice any, setFunc func(*StatsDailyCarCreate, int)) *StatsDailyCarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatsDailyCarCreateBulk{err: fmt.Errorf("calling to StatsDailyCarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatsDailyCarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatsDailyCarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatsDailyCar.
func (c *StatsDailyCarClient) Update() *StatsDailyCarUpdate {
	mutation := newStatsDailyCarMutation(c.config, OpUpdate)
	return &StatsDailyCarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatsDailyCarClient) UpdateOne(sdc *StatsDailyCar) *StatsDailyCarUpdateOne {
	mutation := newStatsDailyCarMutation(c.config, OpUpdateOne, withStatsDailyCar(sdc))
	return &StatsDailyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatsDailyCarClient) UpdateOneID(id int) *StatsDailyCarUpdateOne {
	mutation := newStatsDailyCarMutation(c.config, OpUpdateOne, withStatsDailyCarID(id))
	return &StatsDailyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatsDailyCar.
func (c *StatsDailyCarClient) Delete() *StatsDailyCarDelete {
	mutation := newStatsDailyCarMutation(c.config, OpDelete)
	return &StatsDailyCarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatsDailyCarClient) DeleteOne(sdc *StatsDailyCar) *StatsDailyCarDeleteOne {
	return c.DeleteOneID(sdc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatsDailyCarClient) DeleteOneID(id int) *StatsDailyCarDeleteOne {
	builder := c.Delete().Where(statsdailycar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatsDailyCarDeleteOne{builder}
}

// Query returns a query builder for StatsDailyCar.
func (c *StatsDailyCarClient) Query() *StatsDailyCarQuery {
	return &StatsDailyCarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatsDailyCar},
		inters: c.Interceptors(),
	}
}

// Get returns a StatsDailyCar entity by its id.
func (c *StatsDailyCarClient) Get(ctx context.Context, id int) (*StatsDailyCar, error) {
	return c.Query().Where(statsdailycar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatsDailyCarClient) GetX(ctx context.Context, id int) *StatsDailyCar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatsDailyCarClient) Hooks() []Hook {
	return c.hooks.StatsDailyCar
}

// Interceptors returns the client interceptors.
func (c *StatsDailyCarClient) Interceptors() []Interceptor {
	return c.inters.StatsDailyCar
}

func (c *StatsDailyCarClient) mutate(ctx context.Context, m *StatsDailyCarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatsDailyCarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatsDailyCarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatsDailyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatsDailyCarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatsDailyCar mutation op: %q", m.Op())
	}
}

// StatsDailyScenicAreaClient is a client for the StatsDailyScenicArea schema.
type StatsDailyScenicAreaClient struct {
	config
}

// NewStatsDailyScenicAreaClient returns a client for the StatsDailyScenicArea from the given config.
func NewStatsDailyScenicAreaClient(c config) *StatsDailyScenicAreaClient {
	return &StatsDailyScenicAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statsdailyscenicarea.Hooks(f(g(h())))`.
func (c *StatsDailyScenicAreaClient) Use(hooks ...Hook) {
	c.hooks.StatsDailyScenicArea = append(c.hooks.StatsDailyScenicArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statsdailyscenicarea.Intercept(f(g(h())))`.
func (c *StatsDailyScenicAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatsDailyScenicArea = append(c.inters.StatsDailyScenicArea, interceptors...)
}

// Create returns a builder for creating a StatsDailyScenicArea entity.
func (c *StatsDailyScenicAreaClient) Create() *StatsDailyScenicAreaCreate {
	mutation := newStatsDailyScenicAreaMutation(c.config, OpCreate)
	return &StatsDailyScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatsDailyScenicArea entities.
func (c *StatsDailyScenicAreaClient) CreateBulk(builders ...*StatsDailyScenicAreaCreate) *StatsDailyScenicAreaCreateBulk {
	return &StatsDailyScenicAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatsDailyScenicAreaClient) MapCreateBulk(slice any, setFunc func(*StatsDailyScenicAreaCreate, int)) *StatsDailyScenicAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatsDailyScenicAreaCreateBulk{err: fmt.Errorf("calling to StatsDailyScenicAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatsDailyScenicAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatsDailyScenicAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatsDailyScenicArea.
func (c *StatsDailyScenicAreaClient) Update() *StatsDailyScenicAreaUpdate {
	mutation := newStatsDailyScenicAreaMutation(c.config, OpUpdate)
	return &StatsDailyScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatsDailyScenicAreaClient) UpdateOne(sdsa *StatsDailyScenicArea) *StatsDailyScenicAreaUpdateOne {
	mutation := newStatsDailyScenicAreaMutation(c.config, OpUpdateOne, withStatsDailyScenicArea(sdsa))
	return &StatsDailyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatsDailyScenicAreaClient) UpdateOneID(id int) *StatsDailyScenicAreaUpdateOne {
	mutation := newStatsDailyScenicAreaMutation(c.config, OpUpdateOne, withStatsDailyScenicAreaID(id))
	return &StatsDailyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatsDailyScenicArea.
func (c *StatsDailyScenicAreaClient) Delete() *StatsDailyScenicAreaDelete {
	mutation := newStatsDailyScenicAreaMutation(c.config, OpDelete)
	return &StatsDailyScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatsDailyScenicAreaClient) DeleteOne(sdsa *StatsDailyScenicArea) *StatsDailyScenicAreaDeleteOne {
	return c.DeleteOneID(sdsa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatsDailyScenicAreaClient) DeleteOneID(id int) *StatsDailyScenicAreaDeleteOne {
	builder := c.Delete().Where(statsdailyscenicarea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatsDailyScenicAreaDeleteOne{builder}
}

// Query returns a query builder for StatsDailyScenicArea.
func (c *StatsDailyScenicAreaClient) Query() *StatsDailyScenicAreaQuery {
	return &StatsDailyScenicAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatsDailyScenicArea},
		inters: c.Interceptors(),
	}
}

// Get returns a StatsDailyScenicArea entity by its id.
func (c *StatsDailyScenicAreaClient) Get(ctx context.Context, id int) (*StatsDailyScenicArea, error) {
	return c.Query().Where(statsdailyscenicarea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatsDailyScenicAreaClient) GetX(ctx context.Context, id int) *StatsDailyScenicArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatsDailyScenicAreaClient) Hooks() []Hook {
	return c.hooks.StatsDailyScenicArea
}

// Interceptors returns the client interceptors.
func (c *StatsDailyScenicAreaClient) Interceptors() []Interceptor {
	return c.inters.StatsDailyScenicArea
}

func (c *StatsDailyScenicAreaClient) mutate(ctx context.Context, m *StatsDailyScenicAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatsDailyScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatsDailyScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatsDailyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatsDailyScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatsDailyScenicArea mutation op: %q", m.Op())
	}
}

// StatsHourlyCarClient is a client for the StatsHourlyCar schema.
type StatsHourlyCarClient struct {
	config
}

// NewStatsHourlyCarClient returns a client for the StatsHourlyCar from the given config.
func NewStatsHourlyCarClient(c config) *StatsHourlyCarClient {
	return &StatsHourlyCarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statshourlycar.Hooks(f(g(h())))`.
func (c *StatsHourlyCarClient) Use(hooks ...Hook) {
	c.hooks.StatsHourlyCar = append(c.hooks.StatsHourlyCar, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statshourlycar.Intercept(f(g(h())))`.
func (c *StatsHourlyCarClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatsHourlyCar = append(c.inters.StatsHourlyCar, interceptors...)
}

// Create returns a builder for creating a StatsHourlyCar entity.
func (c *StatsHourlyCarClient) Create() *StatsHourlyCarCreate {
	mutation := newStatsHourlyCarMutation(c.config, OpCreate)
	return &StatsHourlyCarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatsHourlyCar entities.
func (c *StatsHourlyCarClient) CreateBulk(builders ...*StatsHourlyCarCreate) *StatsHourlyCarCreateBulk {
	return &StatsHourlyCarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatsHourlyCarClient) MapCreateBulk(slice any, setFunc func(*StatsHourlyCarCreate, int)) *StatsHourlyCarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatsHourlyCarCreateBulk{err: fmt.Errorf("calling to StatsHourlyCarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatsHourlyCarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatsHourlyCarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatsHourlyCar.
func (c *StatsHourlyCarClient) Update() *StatsHourlyCarUpdate {
	mutation := newStatsHourlyCarMutation(c.config, OpUpdate)
	return &StatsHourlyCarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatsHourlyCarClient) UpdateOne(shc *StatsHourlyCar) *StatsHourlyCarUpdateOne {
	mutation := newStatsHourlyCarMutation(c.config, OpUpdateOne, withStatsHourlyCar(shc))
	return &StatsHourlyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatsHourlyCarClient) UpdateOneID(id int) *StatsHourlyCarUpdateOne {
	mutation := newStatsHourlyCarMutation(c.config, OpUpdateOne, withStatsHourlyCarID(id))
	return &StatsHourlyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatsHourlyCar.
func (c *StatsHourlyCarClient) Delete() *StatsHourlyCarDelete {
	mutation := newStatsHourlyCarMutation(c.config, OpDelete)
	return &StatsHourlyCarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatsHourlyCarClient) DeleteOne(shc *StatsHourlyCar) *StatsHourlyCarDeleteOne {
	return c.DeleteOneID(shc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatsHourlyCarClient) DeleteOneID(id int) *StatsHourlyCarDeleteOne {
	builder := c.Delete().Where(statshourlycar.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatsHourlyCarDeleteOne{builder}
}

// Query returns a query builder for StatsHourlyCar.
func (c *StatsHourlyCarClient) Query() *StatsHourlyCarQuery {
	return &StatsHourlyCarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatsHourlyCar},
		inters: c.Interceptors(),
	}
}

// Get returns a StatsHourlyCar entity by its id.
func (c *StatsHourlyCarClient) Get(ctx context.Context, id int) (*StatsHourlyCar, error) {
	return c.Query().Where(statshourlycar.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatsHourlyCarClient) GetX(ctx context.Context, id int) *StatsHourlyCar {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a StatsHourlyCar.
func (c *StatsHourlyCarClient) QueryBackgroundScenicArea(shc *StatsHourlyCar) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := shc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(statshourlycar.Table, statshourlycar.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, statshourlycar.BackgroundScenicAreaTable, statshourlycar.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(shc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCar queries the car edge of a StatsHourlyCar.
func (c *StatsHourlyCarClient) QueryCar(shc *StatsHourlyCar) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := shc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(statshourlycar.Table, statshourlycar.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, statshourlycar.CarTable, statshourlycar.CarColumn),
		)
		fromV = sqlgraph.Neighbors(shc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StatsHourlyCarClient) Hooks() []Hook {
	return c.hooks.StatsHourlyCar
}

// Interceptors returns the client interceptors.
func (c *StatsHourlyCarClient) Interceptors() []Interceptor {
	return c.inters.StatsHourlyCar
}

func (c *StatsHourlyCarClient) mutate(ctx context.Context, m *StatsHourlyCarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatsHourlyCarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatsHourlyCarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatsHourlyCarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatsHourlyCarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatsHourlyCar mutation op: %q", m.Op())
	}
}

// StatsHourlyScenicAreaClient is a client for the StatsHourlyScenicArea schema.
type StatsHourlyScenicAreaClient struct {
	config
}

// NewStatsHourlyScenicAreaClient returns a client for the StatsHourlyScenicArea from the given config.
func NewStatsHourlyScenicAreaClient(c config) *StatsHourlyScenicAreaClient {
	return &StatsHourlyScenicAreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statshourlyscenicarea.Hooks(f(g(h())))`.
func (c *StatsHourlyScenicAreaClient) Use(hooks ...Hook) {
	c.hooks.StatsHourlyScenicArea = append(c.hooks.StatsHourlyScenicArea, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statshourlyscenicarea.Intercept(f(g(h())))`.
func (c *StatsHourlyScenicAreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatsHourlyScenicArea = append(c.inters.StatsHourlyScenicArea, interceptors...)
}

// Create returns a builder for creating a StatsHourlyScenicArea entity.
func (c *StatsHourlyScenicAreaClient) Create() *StatsHourlyScenicAreaCreate {
	mutation := newStatsHourlyScenicAreaMutation(c.config, OpCreate)
	return &StatsHourlyScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatsHourlyScenicArea entities.
func (c *StatsHourlyScenicAreaClient) CreateBulk(builders ...*StatsHourlyScenicAreaCreate) *StatsHourlyScenicAreaCreateBulk {
	return &StatsHourlyScenicAreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatsHourlyScenicAreaClient) MapCreateBulk(slice any, setFunc func(*StatsHourlyScenicAreaCreate, int)) *StatsHourlyScenicAreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatsHourlyScenicAreaCreateBulk{err: fmt.Errorf("calling to StatsHourlyScenicAreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatsHourlyScenicAreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatsHourlyScenicAreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatsHourlyScenicArea.
func (c *StatsHourlyScenicAreaClient) Update() *StatsHourlyScenicAreaUpdate {
	mutation := newStatsHourlyScenicAreaMutation(c.config, OpUpdate)
	return &StatsHourlyScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatsHourlyScenicAreaClient) UpdateOne(shsa *StatsHourlyScenicArea) *StatsHourlyScenicAreaUpdateOne {
	mutation := newStatsHourlyScenicAreaMutation(c.config, OpUpdateOne, withStatsHourlyScenicArea(shsa))
	return &StatsHourlyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatsHourlyScenicAreaClient) UpdateOneID(id int) *StatsHourlyScenicAreaUpdateOne {
	mutation := newStatsHourlyScenicAreaMutation(c.config, OpUpdateOne, withStatsHourlyScenicAreaID(id))
	return &StatsHourlyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatsHourlyScenicArea.
func (c *StatsHourlyScenicAreaClient) Delete() *StatsHourlyScenicAreaDelete {
	mutation := newStatsHourlyScenicAreaMutation(c.config, OpDelete)
	return &StatsHourlyScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatsHourlyScenicAreaClient) DeleteOne(shsa *StatsHourlyScenicArea) *StatsHourlyScenicAreaDeleteOne {
	return c.DeleteOneID(shsa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatsHourlyScenicAreaClient) DeleteOneID(id int) *StatsHourlyScenicAreaDeleteOne {
	builder := c.Delete().Where(statshourlyscenicarea.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatsHourlyScenicAreaDeleteOne{builder}
}

// Query returns a query builder for StatsHourlyScenicArea.
func (c *StatsHourlyScenicAreaClient) Query() *StatsHourlyScenicAreaQuery {
	return &StatsHourlyScenicAreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatsHourlyScenicArea},
		inters: c.Interceptors(),
	}
}

// Get returns a StatsHourlyScenicArea entity by its id.
func (c *StatsHourlyScenicAreaClient) Get(ctx context.Context, id int) (*StatsHourlyScenicArea, error) {
	return c.Query().Where(statshourlyscenicarea.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatsHourlyScenicAreaClient) GetX(ctx context.Context, id int) *StatsHourlyScenicArea {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StatsHourlyScenicAreaClient) Hooks() []Hook {
	return c.hooks.StatsHourlyScenicArea
}

// Interceptors returns the client interceptors.
func (c *StatsHourlyScenicAreaClient) Interceptors() []Interceptor {
	return c.inters.StatsHourlyScenicArea
}

func (c *StatsHourlyScenicAreaClient) mutate(ctx context.Context, m *StatsHourlyScenicAreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatsHourlyScenicAreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatsHourlyScenicAreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatsHourlyScenicAreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatsHourlyScenicAreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatsHourlyScenicArea mutation op: %q", m.Op())
	}
}

// SystemConfigClient is a client for the SystemConfig schema.
type SystemConfigClient struct {
	config
}

// NewSystemConfigClient returns a client for the SystemConfig from the given config.
func NewSystemConfigClient(c config) *SystemConfigClient {
	return &SystemConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemconfig.Hooks(f(g(h())))`.
func (c *SystemConfigClient) Use(hooks ...Hook) {
	c.hooks.SystemConfig = append(c.hooks.SystemConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemconfig.Intercept(f(g(h())))`.
func (c *SystemConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemConfig = append(c.inters.SystemConfig, interceptors...)
}

// Create returns a builder for creating a SystemConfig entity.
func (c *SystemConfigClient) Create() *SystemConfigCreate {
	mutation := newSystemConfigMutation(c.config, OpCreate)
	return &SystemConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemConfig entities.
func (c *SystemConfigClient) CreateBulk(builders ...*SystemConfigCreate) *SystemConfigCreateBulk {
	return &SystemConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemConfigClient) MapCreateBulk(slice any, setFunc func(*SystemConfigCreate, int)) *SystemConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemConfigCreateBulk{err: fmt.Errorf("calling to SystemConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemConfig.
func (c *SystemConfigClient) Update() *SystemConfigUpdate {
	mutation := newSystemConfigMutation(c.config, OpUpdate)
	return &SystemConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemConfigClient) UpdateOne(sc *SystemConfig) *SystemConfigUpdateOne {
	mutation := newSystemConfigMutation(c.config, OpUpdateOne, withSystemConfig(sc))
	return &SystemConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemConfigClient) UpdateOneID(id int) *SystemConfigUpdateOne {
	mutation := newSystemConfigMutation(c.config, OpUpdateOne, withSystemConfigID(id))
	return &SystemConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemConfig.
func (c *SystemConfigClient) Delete() *SystemConfigDelete {
	mutation := newSystemConfigMutation(c.config, OpDelete)
	return &SystemConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemConfigClient) DeleteOne(sc *SystemConfig) *SystemConfigDeleteOne {
	return c.DeleteOneID(sc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemConfigClient) DeleteOneID(id int) *SystemConfigDeleteOne {
	builder := c.Delete().Where(systemconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemConfigDeleteOne{builder}
}

// Query returns a query builder for SystemConfig.
func (c *SystemConfigClient) Query() *SystemConfigQuery {
	return &SystemConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemConfig entity by its id.
func (c *SystemConfigClient) Get(ctx context.Context, id int) (*SystemConfig, error) {
	return c.Query().Where(systemconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemConfigClient) GetX(ctx context.Context, id int) *SystemConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemConfigClient) Hooks() []Hook {
	return c.hooks.SystemConfig
}

// Interceptors returns the client interceptors.
func (c *SystemConfigClient) Interceptors() []Interceptor {
	return c.inters.SystemConfig
}

func (c *SystemConfigClient) mutate(ctx context.Context, m *SystemConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemConfig mutation op: %q", m.Op())
	}
}

// SystemLogClient is a client for the SystemLog schema.
type SystemLogClient struct {
	config
}

// NewSystemLogClient returns a client for the SystemLog from the given config.
func NewSystemLogClient(c config) *SystemLogClient {
	return &SystemLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemlog.Hooks(f(g(h())))`.
func (c *SystemLogClient) Use(hooks ...Hook) {
	c.hooks.SystemLog = append(c.hooks.SystemLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemlog.Intercept(f(g(h())))`.
func (c *SystemLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemLog = append(c.inters.SystemLog, interceptors...)
}

// Create returns a builder for creating a SystemLog entity.
func (c *SystemLogClient) Create() *SystemLogCreate {
	mutation := newSystemLogMutation(c.config, OpCreate)
	return &SystemLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemLog entities.
func (c *SystemLogClient) CreateBulk(builders ...*SystemLogCreate) *SystemLogCreateBulk {
	return &SystemLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemLogClient) MapCreateBulk(slice any, setFunc func(*SystemLogCreate, int)) *SystemLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemLogCreateBulk{err: fmt.Errorf("calling to SystemLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemLog.
func (c *SystemLogClient) Update() *SystemLogUpdate {
	mutation := newSystemLogMutation(c.config, OpUpdate)
	return &SystemLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemLogClient) UpdateOne(sl *SystemLog) *SystemLogUpdateOne {
	mutation := newSystemLogMutation(c.config, OpUpdateOne, withSystemLog(sl))
	return &SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemLogClient) UpdateOneID(id uint64) *SystemLogUpdateOne {
	mutation := newSystemLogMutation(c.config, OpUpdateOne, withSystemLogID(id))
	return &SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemLog.
func (c *SystemLogClient) Delete() *SystemLogDelete {
	mutation := newSystemLogMutation(c.config, OpDelete)
	return &SystemLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemLogClient) DeleteOne(sl *SystemLog) *SystemLogDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemLogClient) DeleteOneID(id uint64) *SystemLogDeleteOne {
	builder := c.Delete().Where(systemlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemLogDeleteOne{builder}
}

// Query returns a query builder for SystemLog.
func (c *SystemLogClient) Query() *SystemLogQuery {
	return &SystemLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemLog},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemLog entity by its id.
func (c *SystemLogClient) Get(ctx context.Context, id uint64) (*SystemLog, error) {
	return c.Query().Where(systemlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemLogClient) GetX(ctx context.Context, id uint64) *SystemLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemLogClient) Hooks() []Hook {
	return c.hooks.SystemLog
}

// Interceptors returns the client interceptors.
func (c *SystemLogClient) Interceptors() []Interceptor {
	return c.inters.SystemLog
}

func (c *SystemLogClient) mutate(ctx context.Context, m *SystemLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemLog mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBackgroundScenicArea queries the background_scenic_area edge of a User.
func (c *UserClient) QueryBackgroundScenicArea(u *User) *ScenicAreaQuery {
	query := (&ScenicAreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(scenicarea.Table, scenicarea.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.BackgroundScenicAreaTable, user.BackgroundScenicAreaColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Access, Account, ActivityOrder, AppPush, AppVersion, BillingStrategy, Car,
		CarAlarm, CarConfig, CarConfigDownload, CarConfigPack, CarConfigStatus,
		CarCumulative, CarExtendYokee, CarLogUpload, CarsFlight, CarsFlightExtendYokee,
		CarsModels, CarsModelsGroups, CarsModelsGroupsParams, CarsOperateLog, Coupon,
		Feedback, File, MapVersion, OperationUser, Order, OrderAppeal, OrderBilling,
		OrderExtendFlight, OrderRefund, OrderSharing, OtaBtree, OtaDeploy, OtaVersion,
		PayTxBill, PaymentAccount, Poi, PoiExtendYokee, ProfitReceiver, Role, Route,
		ScenicArea, ScenicAreaExtendYokee, ScenicAreaMap, ScheTask, ScheTaskEvent,
		SshAccount, StatsDaily, StatsDailyCar, StatsDailyScenicArea, StatsHourlyCar,
		StatsHourlyScenicArea, SystemConfig, SystemLog, Task, User []ent.Hook
	}
	inters struct {
		Access, Account, ActivityOrder, AppPush, AppVersion, BillingStrategy, Car,
		CarAlarm, CarConfig, CarConfigDownload, CarConfigPack, CarConfigStatus,
		CarCumulative, CarExtendYokee, CarLogUpload, CarsFlight, CarsFlightExtendYokee,
		CarsModels, CarsModelsGroups, CarsModelsGroupsParams, CarsOperateLog, Coupon,
		Feedback, File, MapVersion, OperationUser, Order, OrderAppeal, OrderBilling,
		OrderExtendFlight, OrderRefund, OrderSharing, OtaBtree, OtaDeploy, OtaVersion,
		PayTxBill, PaymentAccount, Poi, PoiExtendYokee, ProfitReceiver, Role, Route,
		ScenicArea, ScenicAreaExtendYokee, ScenicAreaMap, ScheTask, ScheTaskEvent,
		SshAccount, StatsDaily, StatsDailyCar, StatsDailyScenicArea, StatsHourlyCar,
		StatsHourlyScenicArea, SystemConfig, SystemLog, Task, User []ent.Interceptor
	}
)
